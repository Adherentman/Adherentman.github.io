<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[学习CSS(二)]]></title>
      <url>%2F%E5%AD%A6%E4%B9%A0CSS(%E4%BA%8C).html</url>
      <content type="text"><![CDATA[盒模型页面上的每个元素被看做一个矩形框，这个框由元素的内容、内边距（padding）、边框（border）、和外边距（margin）组成。 ##外边距叠加 本小节参考W3school。 当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并。 尽管看上去有些奇怪，但是外边距甚至可以与自身发生合并。 假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并： 如果这个外边距遇到另一个元素的外边距，它还会发生合并： 外边距合并初看上去可能有点奇怪，但是实际上，它是有意义的。以由几个段落组成的典型文本页面为例。第一个段落上面的空间等于段落的上外边距。如果没有外边距合并，后续所有段落之间的外边距都将是相邻上外边距和下外边距的和。这意味着段落之间的空间是页面顶部的两倍。如果发生外边距合并，段落之间的上外边距和下外边距就合并在一起，这样各处的距离就一致了。 定位概述可视化格式模型和定位模型。 可视化格式模型h1,p,div等元素常常称为块级元素。 strong,span等元素称为行内元素。 当行内元素你把它们的display属性设置成block，此元素会被显示为块级元素。 块级框从上到下一个接一个地垂直排列。 相对定位如果对一个元素进行相对定位，其实就是让这个元素“相对于”它的起点移动。 1234567891011121314151617181920212223#myBox &#123;width: 200px;height: 200px;background: red;&#125;#myBox1 &#123;position: relative;width: 200px;height: 200px;background: blue;&#125;#myBox2 &#123;position: relative;left: 20px;top: 20px;width: 200px;height: 200px;background: gray;&#125;&lt;div id="myBox"&gt;&lt;/div&gt;&lt;div id="myBox1"&gt;&lt;/div&gt;&lt;div id="myBox2"&gt;&lt;/div&gt; 绝对定位绝对定位使元素的位置与文档流无关。 绝对定位的元素的位置是相对于距离它最近的那个已定位的祖先元素确定的。如果元素没有已定位的祖先元素，那么它的位置是相对于初始包含块的。 接下来我们让一个文本段落对准一个大框的右下角： 1234567891011121314151617#branding &#123;width: 20em;height: 10em;position: relative;background: black;&#125;#branding .tel &#123;position: absolute;right: 1em;bottom: 1em;text-align: right;color: white;&#125;&lt;div id="branding"&gt; &lt;p class="tel"&gt;Tel: 0845 838 6163&lt;/p&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学习CSS(一)]]></title>
      <url>%2F%E5%AD%A6CSS%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
      <content type="text"><![CDATA[给自己的要求 class应该用在概念上相似的元素，这些元素可以出现在同一页面上的多个位置。 ID应该用于不同的唯一的元素。 DTD（文档类型定义）DOCTYPE声明是指HTML文档开头处的一行或两行代码。它描述使用哪个DTD。 但是在HTML5中就不需要URL，浏览器一般不读取这些文件。而是只识别常见的DOCTYPE声明。 选择器选择器最常用的两种： 类型选择器 和 后代选择器 。 123/*类型选择器*/p &#123; color: black; &#125;h1 &#123; font-weight: bold; &#125; 12/*后代选择器*/blockquote p &#123; padding: 15px; &#125; 还有两种就是： ID选择器 和 类选择器 。 12#intro &#123; font-weight: bold; &#125; /*ID选择器*/.date-posted &#123; color: #ccc; &#125; /*类选择器*/ 但是类选择器和ID选择器用太多也不是很好。下面有一种方法可以以一种方式对主体和副的地方操作css 1234567891011#main-content h2 &#123; font-weight: 1.8em; &#125;#secondary-content h2 &#123; font-weight: 1.2em; &#125;&lt;div id="main-content"&gt; &lt;h2&gt;Hello&lt;/h2&gt; .....&lt;/div&gt;&lt;div id="secondary-content"&gt; &lt;h2&gt;Hi&lt;/h2&gt; ....&lt;/div&gt; 伪类1234567891011a:link &#123; color : blue; &#125; /*链接伪类*/a:visited &#123; color : green; &#125; /*链接伪类*//*链接伪类只能用于锚元素*/动态伪类a:hover, a:focus, a:active &#123; color: red; &#125; tr:hover &#123; background-color: red; &#125;input:focus &#123; background-color: yellow; &#125;伪类链接a:visited:hover &#123; color: olive; &#125; 通用选择器12345* &#123; padding: 0; margin: 0;&#125;/*删除每个元素上默认的浏览器内边距和外边距*/ 高级选择器之—-子选择器后代选择器选择一个元素的所有后代，那么子选择器就只选择元素的直接后代啦！ 1234567891011121314#nav&gt;li &#123; font-size: 30px;&#125;&lt;ul id="nav"&gt; &lt;li&gt;&lt;a href="/home/"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/Services/"&gt;Services&lt;/a&gt;&lt;/li&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="/Services/design"&gt;Design&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/Services/development"&gt;Development&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/Services/consultancy"&gt;Consultancy&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;li&gt;&lt;a href="/contact"&gt;Contact Us&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 子选择器指定列表子元素的样式，但是不影响他的孙元素。 还有根据一个元素与另一个元素的相邻关系对它应用样式。 123456789h2 + p &#123; font-size: 1.4em; font-weight: blod; color: #777;&#125;&lt;h2&gt;Hello World&lt;/h2&gt; &lt;p&gt;I'm here&lt;/p&gt; &lt;p&gt;wow,me too&lt;/p&gt; 更新于2017-09-05 21：30 属性选择器12345678910[title=hi]&#123;border:5px solid blue;&#125;&lt;h1&gt;可以应用样式：&lt;/h1&gt;&lt;img title="hi" src="/nihao.gif" /&gt;&lt;br /&gt;&lt;a title="hi" href="/"&gt;W3School&lt;/a&gt;&lt;hr /&gt; 层叠和特殊性层叠性有 !important 标志的规则，它优先于任何规则。 特殊性 选择器 特殊性 以10为基数的特殊性 Style=“ ” 1,0,0,0 1000 #wrapper #content {} 0,2,0,0 200 #content .datePosted {} 0,1,1,0 110 div#content {} 0,1,0,1 101 #content {} 0,1,0,0 100 p.comment .dateposted {} 0,0,2,1 21 p.comment {} 0,0,1,1 11 div p {} 0,0,0,2 2 p {} 0,0,0,1 1 1234567891011121314151617181920212223242526272829#content div#main-content h2&#123;color: gray;&#125;#content #main-content&gt;h2 &#123;color: blue;&#125;body #content div[div="main-content"] h2 &#123;color: green;&#125;#main-content div.news-story h2 &#123;color: orange;&#125;#main-content [class="news-story"] h2 &#123;color: yellow;&#125;div#main-content div.news-story h2.first &#123;color: red;&#125;&lt;div id="content"&gt; &lt;div id="main-content"&gt; &lt;h2&gt;Hello&lt;/h2&gt; &lt;p&gt;哇&lt;/p&gt; &lt;div class="news-story"&gt; &lt;h2 class="first"&gt;BigBong&lt;/h2&gt; &lt;p&gt;嘻嘻&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用阿里云oss踩得坑]]></title>
      <url>%2F%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91oss%E8%B8%A9%E5%BE%97%E5%9D%91.html</url>
      <content type="text"><![CDATA[Provisional headers are shown首先我现在console里看见以下报错： 接着我去了network里看： 最后找到了根本问题所在： 因为我在https的网页中，是不允许我去发http的请求，所以我需要去自己发起请求的client代码中加入secure：true。 ErrorCode: AccessForbidden 如果遇到以上问题，那肯定是你的 CORS没有配置或者配置不对。 我们需要到阿里云的的OSS控制台中做以下设置： 以下也是上述没设置好的错，错误为：出错请求的HTTP状态码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[支付宝小程序踩坑（一）]]></title>
      <url>%2F%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F.html</url>
      <content type="text"><![CDATA[这是支付宝小程序编译器的主界面 这是 hello，world的文件树。是基于js语言。小程序开发者工具默认支持 ES5/ES6/ES7，推荐使用 ES6 以上语法。而且还内置了 ESLint 支持]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CO函数，异步]]></title>
      <url>%2FCO%E5%87%BD%E6%95%B0%EF%BC%8C%E5%BC%82%E6%AD%A5.html</url>
      <content type="text"><![CDATA[CO函数库co 函数库是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行。 有一个 Generator 函数，用于依次读取两个文件。 123456var gen = function* ()&#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; co 函数库可以让你不用编写 Generator 函数的执行器。 12var co = require('co');co(gen); 上面代码中，Generator 函数只要传入 co 函数，就会自动执行。 co 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。 123co(gen).then(function ()&#123; console.log('Generator 函数执行完成');&#125;) co 函数库的源码co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。 首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。 123456function co(gen) &#123; var ctx = this; return new Promise(function(resolve, reject) &#123; &#125;);&#125; 在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为 resolved 。 12345678function co(gen) &#123; var ctx = this; return new Promise(function(resolve, reject) &#123; if (typeof gen === 'function') gen = gen.call(ctx); if (!gen || typeof gen.next !== 'function') return resolve(gen); &#125;);&#125; 接着，co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulefilled 函数。这主要是为了能够捕捉抛出的错误。 12345678910111213141516171819function co(gen) &#123; var ctx = this; return new Promise(function(resolve, reject) &#123; if (typeof gen === 'function') gen = gen.call(ctx); if (!gen || typeof gen.next !== 'function') return resolve(gen); onFulfilled(); function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; &#125;);&#125; 最后，就是关键的 next 函数，它会反复调用自身。 12345678function next(ret) &#123; if (ret.done) return resolve(ret.value); var value = toPromise.call(ctx, ret.value); if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: "' + String(ret.value) + '"')); &#125;&#125;); 上面代码中，next 函数的内部代码，一共只有四行命令。 第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。 第二行，确保每一步的返回值，是 Promise 对象。 第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。 第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。 并发的异步操作co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。 这时，要把并发的操作都放在数组或对象里面。 1234567co(function* ()&#123; var values = [n1,n2,n3]; yield values.map(somethingAsync);&#125;);function* somethingAsync(x)&#123; return y&#125;; #]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript函数]]></title>
      <url>%2FJavaScript%E5%87%BD%E6%95%B0.html</url>
      <content type="text"><![CDATA[在JavaScript中，函数是一等公民。函数是第一型对象。 所以说，我们可以将其视为其他任意类型的JavaScript对象。 在JavaScript中函数可以： 可以赋值给变量，数组，或其他对象的属性 可以通过字面量进行创建 将其作为参数进行传递 可以作为函数的返回值进行返回 可以拥有动态创建并赋值的属性 最重要是的，它们还可以被调用。这些调用通常是以异步方式进行调用。 回调回调函数的术语源于：我们定义一个函数，以便其他一些代码在适当的时机回头再调用他。 123function useless(callback)&#123; return callback();&#125; 123456789101112var text = 'Demo arigato';assert(useless(function()&#123; return text;&#125;) ===text, "This useless function works!" + text);//assert是测试函数function assert(value, desc)&#123; var li = document.createElement("li"); li.className = value ? "pase" : "fail"; li.appendChild(document.createTextNode(desc)); document.getElementById("results").appendChild(li);&#125;; 函数字面量函数字面量由4个部分组成 function关键字 可选名称。 括号内部，一个以逗号分隔的参数列表。 包含在大括号内的一系列JavaScript语句叫 函数体。 注意： 所有的函数都有name属性，该属性保存的是他们的名称的字符串。 当然没有名称的函数也有name属性，只是为空字符串。 123var canFly = function() &#123; return true;&#125;; 这个函数我们可以通过它的引用 canFly 进行调用。它与canFly函数几乎一模一样，但是不一样的地方在于它的字符串值为” ”，而不是“canFly”。 123window.isDeadly = function() &#123; return true;&#125;; 我们可以（ window.isDeadly() || isDeadly() ）去调用这个函数，其实这就跟命名函数几乎一模一样了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native iOS/android环境配置]]></title>
      <url>%2FReact%20Native%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
      <content type="text"><![CDATA[React Native环境配置Ios开发环境因为我是在mac下搭建环境的。所以比较方便。 Xcode时必须的！ brew install node //电脑需要有node brew install watchman //这是用来监视文件系统中的更改的工具 npm install -g react-native-cli 然后我们打开 Xcode 接下来我们需要执行命令 react-native init AwesomeProject Then：我们需要在Xcode里打开 1234接着在终端里cd AwesomeProjectthen：react-native run-ios 接下来我们等就好了 这就是成功界面 恭喜🎉！ Android环境第一步与ios一样 brew install node brew install watchman 我们就不做了。 接下来 我们需要安装Java的环境。Download and install JDK 8 or newer 安装Android环境 安装 Android studio 勾选Performance和Android Virtual Device 安装完成后，在Android Studio的启动欢迎界面中选择Configure | SDK Manager。 在SDK Platforms窗口中，选择Show Package Details 然后tools里 ANDROID_HOME环境变量确保ANDROID_HOME环境变量正确地指向了你安装的Android SDK的路径。具体的做法是把下面的命令加入到~/.bash_profile文件中：(译注：~表示用户目录，即/Users/你的用户名/，而小数点开头的文件在Finder中是隐藏的，并且这个文件有可能并不存在。请在终端下使用vi ~/.bash_profile命令创建或编辑。如不熟悉vi操作，请点击这里学习） 12# 如果你不是通过Android Studio安装的sdk，则其路径可能不同，请自行确定清楚。export ANDROID_HOME=~/Library/Android/sdk 然后使用下列命令使其立即生效（否则重启后才生效）： 1source ~/.bash_profile 可以使用echo $ANDROID_HOME检查此变量是否已正确设置。 最后同样我们需要在Android studio中打开创建的文件夹下Android文件 然后去build 圆圈是选手机机型。 我们在正方形框框中先点击锤子然后点击绿色箭头之后在终端里输入以下： 123react-native init AwesomeProjectcd AwesomeProjectreact-native run-android 下面就是成功画面！恭喜🎉！ 在搭建环境下踩得坑Android下 这是我运行安卓的时候遇到的问题。我们需要在 Android studio先启动一个手机模拟器再去终端里输入指令：react-native run-android 就可以了 这个问题是说Build Tools 23.0.0.1太低至少需要25.0.0 但是我升级过后还不行。发现是配置文件里的问题。 这样就行啦！ Ios下具体出错问题描述找不到了，但是情况还是记得的。 就是说我ios的虚拟机打开了但是我在上面看不见自己的项目。 这时候google到答案。。 需要开一个终端，然后去在你的项目下npm install 就是这样。。具体情况我也不知道发生了什么哈哈哈]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript对象]]></title>
      <url>%2FJavascript%E5%AF%B9%E8%B1%A1.html</url>
      <content type="text"><![CDATA[Javascript对象在JavaScript中，数组是对象，函数是对象，正则表达式是对象。那么对象自然也是对象。 JavaScript中的对象是无类型的。 对象是属性的容器，其中每个属性都拥有名字和值。 JavaScript包含一种原型链的特性，允许对象继承另一个对象的属性。 对象字面量12345var empty_project = &#123;&#125;;var stooge = &#123; //对象字面量 "first-name": "Jerome", "last-name": "Howard"&#125;; 一个对象字面量就是包围在一对花括号中的零或多个“名/值”对。 1234567891011121314var flight = &#123; airline: "Oceanic", number: 815, departure: &#123; IATA: "SYD", time: "2014-09-22 14:55", city: "Sydney" &#125;, arrival:&#123; IATA: "LAX", time: "2004-09-23 10:42", city: "Los Angeles" &#125;&#125;; 属性的值可以从包括另一个对象字面量在内的任意表达式中获得。对象是可以嵌套的。 检索12stooge["first-name"] //Jeromeflight.departure.IATA //SYD 需要检索对象里包含的值，可以采用[ ]后缀中括住一个字符串表达式的方式。 但是最好用.表示法。因为它可读性好。 我们去检索不存在的： 12stooge["middle-name"] //undefinedflight.status //undefined ||运算符可以用来填充默认值： 12var middle = stooge["middle-name"] || "(none)";var status = flight.status || "unkown"; 如果我们从undefined的成员属性中取值会导致TypeError异常。这时候我们可以通过 &amp;&amp; 运算符来避免错误。 123flight.equipment //undefinedflight.equipment.model //throw "TypeError"flight.equipment &amp;&amp; flight.equipment.model //undefined 更新对象里的值可以通过赋值语句来更新。如果属性吗已经存在于对象里，那么这个属性的值会被替换。 1stooge['first-name'] = 'Jerome'; 123456stooge['middle-name'] = 'Lester';stooge.nickname = 'Curly';flight.equipment = &#123; model: 'Boeing 777'&#125;;flight.status = 'overdue'; 那么这些属性全部会扩充到对象中。 引用对象通过引用来传递，他们永远不会被复制 12345678910var x = hi;x.hello = 'what';var how = hi.hello; // how为what。//因为x和hi是指向同一个对象的引用。var a = &#123;&#125;,b = &#123;&#125;,c = &#123;&#125;;//a,b,c每个都引用一个不同的对象a = b = c = &#123;&#125;;//a,b,c都是引用同一个空对象 原型每个对象都连接一个原型对象，并且可以从中继承属性。 所有通过对象字面量创建的对象都连接到Object.prototype，它是JavaScript中的标配对象。 12345678if (typeof Object.beget !== 'function')&#123; Object.create = function (o)&#123; var F = function ()&#123;&#125;; F.prototype = o; return new F(); &#125;;&#125;var another_stooge = Object.create(stooge); Object增加一个create方法，这个方法创建一个使用原对象作为其原型的新对象。 原型连接在更新时是不起作用的123another_stooge['first-name'] = 'Harry';another_stooge['middle-name'] = 'Moses';another_stooge.nickname = 'Moe'; 原型连接只有在检索值得时候才被用到。 如果我们尝试去获取对象的某个属性值，但对象没有此属性名。 JavaScript会从原型对象中获取属性值 ——&gt; 原型对象中没，就回去它原型中寻找 ——&gt;直到最后到达终点Object.prototype。 假如想要的属性不存在于原型链，那么结果就只能是undefined。 以上的过程为委托。 原型关系我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见。 12stooge.profession = 'actor';another_stooge.profession //'actor 反射typeof操作符对确定属性的类型很有帮助。 1234typeof flight.number //numbertypeof flight.status //stringtypeof flight.arrival //objecttypeof flight.manifest //undefined 原型链中的任何值都会产生值 12typeof flight.toString //functiontypeof flight.constructor //function 有两种方法去处理掉这些不需要的属性。 第一个是让你的程序做检查并丢弃为函数的属性。 另一个方法是hasOwnProperty 方法，如果对象拥有独有的属性，它将返回true。不会检查原型链 12flight.hasOwnProperty('number') //trueflight.hasOwnProperty('constructor') //true 减少全局变量污染最小化使用全局变量的方法之一是为你的应用只创建一个唯一的全局变量！！ 1234567891011121314151617181920var MYAPP = &#123;&#125;; //该变量此时变成你的应用的容器MYAPP.stooge = &#123; "first-name": "Joe", "last-name": "Howard"&#125;;MYAPP.flight = &#123; airline: "Oceanic", number: 815, departure: &#123; IATA: "SYD", time: "2004-09-22 14:55", city: "Sydney" &#125;, arrival: &#123; IATA: "LAX", time: "2004-09-23 21:59", city: "Los Angeles" &#125;&#125;; 只要把全局性的资源都纳入一个名称空间之下，你的程序与其他应用程序、组件、类库直接发送冲突的可能性就会显著降低。 因为MYAPP.stooge指向的是顶层结构。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Promise && Generator && Async]]></title>
      <url>%2F%E5%BC%82%E6%AD%A5.html</url>
      <content type="text"><![CDATA[异步操作回调函数JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字 callback，直译过来就是”重新调用“。 读取文件进行处理，是这样写的: 1234fs.readFile('/etc/passwd', function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码中，readFile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了 /etc/passwd 这个文件以后，回调函数才会执行。 为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象err？ 设计一个回调函数的时候，第一个参数是err，用于优先解决错误，后面再传递参数。 123456fs.readFile(filePath, function(err, data) &#123; if (err) &#123; //handle the error &#125; // use the data object&#125;); 原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。 那么我们可以用Promise来解决回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。 12345fs.readFile(fileA, function (err, data) &#123; fs.readFile(fileB, function (err, data) &#123; // ... &#125;);&#125;); 如果依次读取多个文件，就会出现多重嵌套。代码就横向发展 Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。写法如下。 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function(data)&#123; console.log(data.toString());&#125;).then(function()&#123; return readFile(fileB);&#125;).then(function(data)&#123; console.log(data.toString());&#125;).catch(function(err) &#123; console.log(err);&#125;); 我们会发现一眼看去都是一堆 then，原来的语义变得很不清楚。 那么我们就要用到Generator函数我们可以这样去理解协程: 123456dota2游戏开始了,你开始操刀祈求者--卡尔.这时你妈妈打电话让你赶紧把楼顶的被子和衣服收一下,这时候你很着急.你游戏才玩到一半,但是又不得不去执行你老妈的指令.没办法,你只好敲击F12选择了暂停游戏.紧接着你把被子和衣服收好了,再次敲击F12游戏继续开始.你开始了自己的3杀/4杀/5杀之旅,很舒服. 协程A(游戏开始)开始执行 协程A执行到一半,暂停(敲击F12游戏暂停),执行权交给了协程B(收被子,衣服) (收好后)协程B交还执行权 协程A(敲击F12游戏继续)恢复执行 用代码来说: 12345function play()&#123; //... var f = yield dota2; //...&#125; 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 Generator函数概念Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 1234function* gen(x)&#123; var y = yield x + 2; return y;&#125; 其他的概念可以看我上篇Generator函数概念 Thunk 函数编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。 123456789101112131415function f(m)&#123; return m * 2; &#125;f(x + 5);// 等同于var thunk = function () &#123; return x + 5;&#125;;function f(thunk)&#123; return thunk() * 2;&#125; 上面代码中，函数 f 的参数 被thunk函数替换了. 这就是 Thunk 函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。 终极武器—-Async函数异步编程的最高境界，就是根本不用关心它是不是异步。 async 函数就是隧道尽头的亮光，很多人认为它是异步操作的终极解决方案。 所谓async函数，其实是Generator函数的语法糖。 前文有一个 Generator 函数，依次读取两个文件。 1234567891011121314151617var fs = require('fs');var readFile = function (fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if (error) reject(error); resolve(data); &#125;); &#125;);&#125;;var gen = function* ()&#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 写成 async 函数，就是下面这样。 123456var asyncReadFile = async function ()&#123; var f1 = await readFile('/etc/fstab'); var f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。 async 函数的优点async 函数对 Generator 函数的改进，体现在以下三点。 （1）内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。 1var result = asyncReadFile(); (2) 上面的代码调用了asyncReadFile函数,然后他就会自动执行,输出最后的结果.完全不像Generator函数,需要调用next方法,或者co模块,才能得到真正的执行,从而得到最终结果. （3）更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 （4）更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 (5）返回值是Promise，这比Generator函数返回的是Iterator对象方便多了。你可以用then()指定下一步操作。 实现原理async函数的实现就是将Generator函数和自动执行器包装在一个函数中。如下代码： 1234567891011121314151617181920212223242526272829303132async function fn(args) &#123; // ...&#125;// 等同于 function fn(args) &#123; return spawn(function*() &#123; // ... &#125;)&#125;// 自动执行器function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; var gen = genF(); function step(nextF) &#123; try &#123; var next = nextF() &#125; catch(e) &#123; return reject(e) &#125; if (next.done) &#123; return resolve(next.value) &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v) &#125;) &#125;,function(e) &#123; step(function() &#123; return gen.throw(e) &#125;) &#125;) &#125; step(function() &#123; return gen.next(undefined) &#125;) &#125;)&#125; async函数用法（1）async函数返回一个Promise对象，可以是then()方法添加回调函数。（2）当函数执行时，一旦遇到await()就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。 下面是一个延迟输出结果的例子： 12345678910111213function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms) &#125;)&#125;async function asyncPrint(value, ms) &#123; await timeout(ms) console.log(value)&#125;// 延迟500ms后输出 "Hello World!"asyncPrint('Hello World!', 500) Async 后面是一个promise，await 后面也要跟一个promise注意事项（1）await命令后面的Promise对象，运行结果可能是reject，所以最好把await命令放在try...catch代码块中。 （2）await命令只能用在async函数中，用在普通函数中会报错。 （3）ES6将await增加为保留字。如果使用这个词作为标识符，在ES5中是合法的，但是ES6会抛出 SyntaxError（语法错误）。 参考阮一峰 《ES6标准入门》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Redux、Redux]]></title>
      <url>%2Fredux.html</url>
      <content type="text"><![CDATA[react无法让两个组件互相交流，使用对方数据。 Redux 需要回调通知state（等同于回调参数）-&gt;action 需要根据回调处理（等同于父级方法） -&gt;reducer 需要state(等同于总状态) -&gt;store 现在您只需要记住 reducer 是一个函数，负责更新并返回一个新的state 而 initialState 主要用于前后端同构的数据同步 Action 是把数据从应用传到store的有效载荷。 是store数据的唯一来源 描述发生了什么的普通对象 也可以理解成新闻的摘要-“任务列表里添加了学习Redux文档”。 Store Redux应用中只有一个单一的store 维持应用的state 提供 getState() 获取state 提供dispatch() 更新state 通过subscribe(listener) 注册监听器 通过subscribe(listener) 返回的函数注销监听器. 会把2个参数传入reducer：当前的state树和action。 ReducerReducerreducer就是实现(state,action) -&gt; newState的纯函数. 也就是真正处理state的地方. Redux不希望我们修改老的state ,而且通过直接返回新的state的方式去修改. 永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。 指明根据action更新state。 通俗点讲，就是 reducer 返回啥，state 就被替换成啥 view(React) store(state) action reducer view(React) = 家具的摆放在视觉的效果上 store(state) = 每个家具在空间内的坐标(如：电视的位置是x:10, y: 400) action = 小明分配任务(谁应该干什么) reducer = 具体任务都干些什么(把电视搬到沙发正对面然后靠墙的地方) 所以这个过程应该是这样的： view —&gt; action —&gt; reducer —&gt; store(state) —&gt; view React-Redux Provider是一个普通组件，可以作为顶层app的分发点，它只需要store属性就可以。他会将state分发给所有被connect的组件，不管它在哪里，被嵌套多少层。 connect是真正的重点，它是一个科里化函数，意思是先接受两个参数（数据绑定mapStateToProps和事件绑定mapDispatchToProps），再接受一个参数（将要绑定的组件本身）：mapStateToProps：构建好Redux系统的时候，它会被自动初始化，但是你的React组件并不知道它的存在，因此你需要分拣出你需要的Redux状态，所以你需要绑定一个函数，它的参数是state，简单返回你关心的几个值。 mapDispatchToProps：声明好的action作为回调，也可以被注入到组件里，就是通过这个函数，它的参数是dispatch，通过redux的辅助方法bindActionCreator绑定所有action以及参数的dispatch，就可以作为属性在组件里面作为函数简单使用了，不需要手动dispatch。这个mapDispatchToProps是可选的，如果不传这个参数redux会简单把dispatch作为属性注入给组件，可以手动当做store.dispatch使用。这也是为什么要科里化的原因。 做好以上流程Redux和React就可以工作了。简单地说就是： ​ 1.顶层分发状态，让React组件被动地渲染。 ​ 2.监听事件，事件有权利回到所有状态顶层影响状态。 Redux 与传统后端 MVC 的对照 Redux 传统后端 MVC store 数据库实例 state 数据库中存储的数据 dispatch(action) 用户发起请求 action: { type, payload } type 表示请求的 URL，payload 表示请求的数据 reducer 路由 + 控制器（handler） reducer 中的 switch-case 分支 路由，根据 action.type 路由到对应的控制器 reducer 内部对 state 的处理 控制器对数据库进行增删改操作 reducer 返回 nextState 将修改后的记录写回数据库 总结redux 三个基本原则 整个应用只有唯一一个 Store 实例 State 只能通过触发 Action 来更改 State 的更改 必须写成纯函数(Reducer)，(oldState, action) =&gt; newState，也就是每次更改总是返回一个新的 State redux 两个显著的特点 可预测性（Reducer 是纯函数）。 扩展性强（middleware）。 reducer 可以根据场景分为以下几种: root reducer :根reducer ,作为createStore的第一个参数 slice reducer : 分片reducer,相对根reducer 来说的.用来操作state的一部分数据.多个分片reducer可以合并成一个根reducer. higher-order reducer : 高阶reducer 接受reducer作为函数/返回reducer作为返回的函数. case function: 功能函数,接受指定action后的更新逻辑,可以是简单的reducer函数,也可以接受其他参数. reducer 的最佳实践主要分为以下几个部分 抽离工具函数,以便复用. 抽离功能函数(case function),精简reducer声明部分的代码 根据数据类别拆分,维护多个独立的slice reducer. 合并slice reducer. 通过crossReducer在多个slice reducer中共享数据. 减少reducer的模板代码.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初入Express]]></title>
      <url>%2FExpress.html</url>
      <content type="text"><![CDATA[expressjs里的请求参数，4.x里只有3种(都引用官方例子) req.params req.body req.query req.params123app.get('/user/:id',function(req,res)&#123; res.send('user' + req.parms.id);&#125;); 就是取带冒号的参数. req.body123456789101112var app = require('express')();var bodyParser = require('body-parser');var multer = require('multer'); app.use(bodyParser.json()); // 用于解析application / jsonapp.use(bodyParser.urlencoded(&#123; extended: true &#125;)); // 用于解析 application/x-www-form-urlencodedapp.use(multer()); // 用于解析多部分/表单数据app.post('/', function (req, res) &#123; console.log(req.body); res.json(req.body);&#125;) req.body一定是post请求.但是在express里面依赖中间件bodyparser,不然req.body都没有. req.query12345678910111213// GET /search?q=tobi+ferretreq.query.q// =&gt; "tobi ferret"// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=conversereq.query.order// =&gt; "desc"req.query.shoe.color// =&gt; "blue"req.query.shoe.type// =&gt; "converse"]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Generator函数]]></title>
      <url>%2FGenerator.html</url>
      <content type="text"><![CDATA[Generator最大的特点就是定义的函数可以被暂停执行. 作用迭代器 iterator, infinite range, 可以暂停函数, lazy evaluation, 用来实现 async/await 啊, 棒棒哒. async generator/iterator 摘自MDN 生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。 摘自ES6标准入门 可以把它理解成一个状态机,封装了多个内部状态.还是一个遍历器对象生成函数. 123456789function* hi()&#123;yield 'nihao';yield 'hello';return 'ending';&#125;var hw = hi();hw.next();hw.next();hw.next(); 通过gen.next()取得的输出是一个对象，包含value和done两个属性，其中value是真正返回的值，而done则用来标识Generator是否已经执行完毕。因为自然数生成器是一个无限循环，所以不存在done: true的情况。 在Generator函数返回的遍历器对象只有调用next方法才会遍历下一个内部状态,所以yield语句就是暂停标志. yield语句后面的表达式,只有当调用到next方法,内部指针指向该语句时才会执行. 1234function* add()&#123; yield 123+123;&#125;//在上面代码里123+123不去求值.当有next();时,才去求值 每个yield将代码分割成两个部分，需要执行两次next才能执行完。 yield其实由两个动作组成，输入 + 输出（输入在输出前面），每次执行next，代码会暂停在yield 输出执行后，其它的语句不再执行（很重要）。 for…of循环可以自动遍历generator函数,不用去调用next方法. 123456789101112function* foo()&#123; yiled 1; yiled 2; yiled 3; yiled 4; yiled 5; return 6;&#125;for(let v of foo())&#123; console.log(v);&#125;//1 2 3 4 5 Generator函数的数据交换和错误处理next()方法返回值的value属性，是Generator函数向外输出的数据；next()方法还可以接受参数，向Generator函数体内输入数据。 12345678function* gen(x) &#123; var y = yield x + 2; return y;&#125; var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next(2) // &#123; value: 2, done: true &#125; Generator函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 123456789101112function* gen(x) &#123; try &#123; var y = yield x + 2 &#125; catch(e) &#123; console.log(e) &#125; return y&#125;var g = gen(1);g.next();g.throw(&apos;出错了&apos;); 上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try...catch 代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Promise]]></title>
      <url>%2FPromise.html</url>
      <content type="text"><![CDATA[Promise1234new Promise(/* executor */ function(resolve,reject)&#123;...&#125;) executor 函数在Promise构造函数执行时同步执行，被传递resolve和reject函数（executor 函数在Promise构造函数返回新建对象前被调用）。 一个 Promise有以下几种状态: pending: 初始状态，不是成功或失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 Promise对象 Promise是一个构造函数 对象的状态不受外界影响 一旦状态改变就不会再变,任何时候都可以得到这个结果. 状态改变只有两种可能:从Pending 变为Resolved(‘’未完成’’变为’’成功’’将异步操作成功的结果作为参数传递出去) 从Pending变为Rejected(“未完成”变为”失败”将异步操作报出错误的结果作为参数传递出去). Promise原型then()方法MDN的例子1234567891011let p1 = new Promise(function(resolve, reject) &#123; resolve("Success!"); // or // reject ("Error!");&#125;);p1.then(function(value) &#123; console.log(value); // Success!&#125;, function(reason) &#123; console.log(reason); // Error!&#125;); 当我把reject去掉注释 说明p1已经被声明过了,而且状态改变过了就不会在改变了. 我只能把p1 改成别的才能得到Error. 链式例子来自 1234567getJSON("/post/1.json").then(function(post)&#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments)&#123; consloe.log("Resolved:",comments);&#125;,function funcB(err)&#123; consloe.log("Rejected:",err);&#125;); 第一个then方法指定的回调函数返回的是另一个Promise对象.第二个then方法指定的回调函数会等待这个新的Promise对象状态发送变化再进行调用下面的funcA或者funcB函数. catch()方法例子来自 catch() 方法返回一个Promise，只处理拒绝的情况。它的行为与调用then()相同。 其实是 .then(null,rejection) 的别名. 1234567p.then((val) =&gt; console.log("fulfilled:", val)) .catch((err) =&gt; console.log("rejected:", err));//等同于p.then((val) =&gt; console.log("fulfilled", val)) .then(null,(err) =&gt; console.log("rejected:", val)); Promise对象的错误具有”冒泡”性质,会一直向后传递,直到被捕获为止.也就是说,错误总是会被下一个catch语句捕获. Promise方法Promise.all()Promise.all(iterable) 方法指当所有在可迭代参数中的 promises 已完成，或者第一个传递的 promise（指 reject）失败时，返回 promise。 1Promise.all(iterable); iterable 一个可迭代对象，例如 Array。参见 iterable. 来自MDN的例子 123456789var p1 = Promise.resolve(3);var p2 = 1337;var p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, "foo");&#125;); Promise.all([p1, p2, p3]).then(values =&gt; &#123; console.log(values); // [3, 1337, "foo"] &#125;); Promise.resolve(value)Promise.reject(reason)Promise.race(iterable)回调函数一个回调函数，也被称为高阶函数，是一个被作为参数传递给另一个函数. 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。 作者：常溪玲链接：https://www.zhihu.com/question/19801131/answer/13005983来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mongodb之旅(一)]]></title>
      <url>%2Fmongodb.html</url>
      <content type="text"><![CDATA[Mongodb之旅(一)插入,insertOne/ManyinsertOne( )123db.inventory.insertOne( &#123; item: &quot;canvas&quot;, qty: 100, tags: [&quot;cotton&quot;], size: &#123; h: 28, w: 35.5, uom: &quot;cm&quot; &#125; &#125;) insertMany([ ])12345db.inventory.insertMany([ &#123; item: &quot;journal&quot;, qty: 25, tags: [&quot;blank&quot;, &quot;red&quot;], size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125; &#125;, &#123; item: &quot;mat&quot;, qty: 85, tags: [&quot;gray&quot;], size: &#123; h: 27.9, w: 35.5, uom: &quot;cm&quot; &#125; &#125;, &#123; item: &quot;mousepad&quot;, qty: 25, tags: [&quot;gel&quot;, &quot;blue&quot;], size: &#123; h: 19, w: 22.85, uom: &quot;cm&quot; &#125; &#125;]) 查找,findfind( )1db.inventory.find( &#123;&#125; ) 更新,updateOne/Many$set123456789db.memberplan.update(&#123;_id:&quot;xxx&quot;&#125;,&#123;$set:&#123;tags:[&quot;coats&quot;,&quot;outerwear&quot;]&#125;&#125;) $currentDate,当前时间1234567db.inventory.updateOne( &#123; item: &quot;paper&quot; &#125;, &#123; $set: &#123; &quot;size.uom&quot;: &quot;cm&quot;, status: &quot;P&quot; &#125;, $currentDate: &#123; lastModified: true &#125; &#125;) updateMany1234567db.inventory.updateMany( &#123; &quot;qty&quot;: &#123; $lt: 50 &#125; &#125;, &#123; $set: &#123; &quot;size.uom&quot;: &quot;in&quot;, status: &quot;P&quot; &#125;, $currentDate: &#123; lastModified: true &#125; &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学Node日志(一)]]></title>
      <url>%2FNode.html</url>
      <content type="text"><![CDATA[学Node日志(一)node实例1234567891011121314const http = require('http');const hostname = '127.0.0.1';const port = 9000;const server = http.createServer((req,res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type','text/plain'); res.end('Hello World\n');&#125;);server.listen(port,hostname, () =&gt; &#123; console.log('服务器运行在 http://$&#123;hostname&#125;:$&#123;port&#125;/');&#125;); response.statusCode()控制响应头刷新时将被发送到客户端的状态码 res.statusCode = 200 状态码 11xx的代码代表请求已被接受，需要继续处理。2xx这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。3xx 重定向。4xx 请求错误。5xx表示服务器错误。 ​ response.setHeader() 响应头如果存在,则值会被覆盖 如果要发送多个名称相同的响应头,则使用字符串数组 res.setHeader(&#39;Content-Type&#39;,&#39;text/plain&#39;) Content-Type表明信息类型,缺省值为” text/plain”.它包含了主要类型（primary type）和次要类型（subtype）两个部分，两者之间用”/“分割. 12345678text/plain：纯文本，文件扩展名.txttext/html：HTML文本，文件扩展名.htm和.htmlimage/jpeg：jpeg格式的图片，文件扩展名.jpgimage/gif：GIF格式的图片，文件扩展名.gifaudio/x-wave：WAVE格式的音频，文件扩展名.wavaudio/mpeg：MP3格式的音频，文件扩展名.mp3video/mpeg：MPEG格式的视频，文件扩展名.mpgapplication/zip：PK-ZIP格式的压缩文件，文件扩展名.zip ​ response.end() 每次响应都必须调用 response.end() 方法. 该方法会通知服务器,所有响应头和响应主体都已被发送,即服务器就将他看成已完成 res.end(&#39;Hello World\n&#39;) Hello World已经被发送. server.listen(port,hostname)开始在指定的 port 和 hostname 上接受连接 端口 端口号是一个 16位的 uint, 所以其范围为 1 to 65535 URL 定义的url格式笼统版本&lt;scheme&gt;:&lt;scheme-specific-part&gt; scheme有我们很熟悉的http、https、ftp，以及著名的ed2k，thunder 通常我们熟悉的url定义成这个样子 1&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt; 用过ftp的估计能体会这么长的，网页上很少带auth信息，所以就精简成这样: 1&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt; 在上面的例子中, scheme=http, host=localhost, port=3000, url-path=/. ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git基本操作]]></title>
      <url>%2Fgit.html</url>
      <content type="text"><![CDATA[Git addgit add -A 和 git add . 和 git add -u git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。 git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add –update的缩写) git add -A ：是上面两个功能的合集（git add –all的缩写） 自我理解: git add -A 提交所有变化 git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 commit过程 git status 检查工作区是否干净 git add 命令主要用于把我们要提交的文件的信息添加到索引库中。当我们使用git commit时，git将依据索引库中的内容来进行文件的提交。 git commit -am “xxxxxxx” git branch git push origin xxxx 删除分支 git branch -D xx 删除本地分支 git push origin :br (origin 后面有空格) 删除远程分支 解决冲突 git fetch origin cms:new 创建新本地分支new git branch git merge new 合并 git branch -D new 删除本地分支 diff查看自上次提交以来，本地代码改动的具体情况 Git log在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 Git log 命令查看 Git showgit show 查看某次commit的修改内容 Git reset –hard 现在让我们来重置回那次提交的状态： Git rebase对于git rebase, 你亦可以选择进行交互式的rebase。这种方法通常用于在向别处推送提交之前对它们进行重写。交互式rebase提供了一个简单易用的途径让你在和别人 分享提交之前对你的提交进行分割、合并或者重排序。在把从其他开发者处拉取的提交应用到本地时，你也可以使用交互式rebase对它们进行清理。 如果你想在rebase的过程中对一部分提交进行修改，你可以在’git rebase’命令中加入’-i’或’–interactive’参数去调用交互模式。 $ git rebase -i origin/master 这个命令会执行交互式rebase操作，操作对象是那些自最后一次从origin仓库拉取或者向origin推送之后的所有提交。 若想查看一下将被rebase的提交，可以用如下的log命令： $ git log github/master.. git branch -a查看远程分支 masterremotes/origin/HEAD -&gt; origin/masterremotes/origin/Releaseremotes/origin/master git checkout -b myRelease origin/Release切换到 origin/Release分支，并在本地新建分支 myRelease]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实习谈业务时所学]]></title>
      <url>%2Fyewu.html</url>
      <content type="text"><![CDATA[一些。。。1.业务员可能都没有理清业务或者需求，需要自己去帮他们理清，好让自己设计开发的产品更健壮和在未来更有扩展性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多说挂了好久。现在换成来必力]]></title>
      <url>%2F%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%E8%BF%81%E7%A7%BB.html</url>
      <content type="text"><![CDATA[多说已挂，将评论迁移到来必力有很多可替代的方案 网易云跟帖 畅言 友言 Disqus 来必力 还有许多评论功能就不一一举例了. 具体说下该如何迁移因为我是hexo搭建的博客，然后我用的主题是next。 打开来必力官网，注册完毕。 登陆后我们来到管理页面。 之后再点击代码管理，我们将会看见一堆代码。 我们在代码中找到data-uid：“xxxxxxxxxx”。 这段将是我们要用的uid。 打开主题文件下的_config.yml我们 livere_uid: #your livere_uid 之后hexo clean &amp;&amp; hexo g -d即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据库E-R图]]></title>
      <url>%2FE-R%E5%9B%BE.html</url>
      <content type="text"><![CDATA[E-R图E-R图是指实体-关系-属性三个基本概括数据的基本结构. 强调ER模型设计的两大内容：一是将需求通过ER表达，另一个是将ER转换为关系模型。ER图是从实践归纳出来的理论方法，可以重新指导实践行为，既可以作为理解和表达用户数据需求的手段，同时也构成如何生成关系模型的依据。 ER图的实体（entity）即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示，每个实体都有自己的实体成员（entity member）或者说实体对象（entity instance），例如学生实体里包括张三、李四等，实体成员（entity member）/实体实例（entity instance） 不需要出现在ER图中。 ER图的属性（attribute）即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性，用椭圆形表示，属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。 ER图的关系（relationship）用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系，关系用菱形来表示。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GraphQL基本操作]]></title>
      <url>%2FGraphQL.html</url>
      <content type="text"><![CDATA[GraphQL()强类型 也就是说，你可以查询值类型：Int, Float, String, Boolean和ID GraphQL不是像MySQL或Redis这样直接面向数据的接口，而是面向你已经存在的应用代码的接口。 你可以把GraphQL看作是为了调用应用服务器上的方法的一些内嵌的RPC。 操作(operation)操作（Operations） GraphQL 规范支持两种操作： query：仅获取数据（fetch）的只读请求 mutation：获取数据后还有写操作的请求 123456query&#123; clent(id:1)&#123; id name &#125;&#125; client 是查询的operation (id:1)包含了传入给Query的参数 查询包含id和name字段,这些字段也是我们希望查询可以返回的. server会给这个查询返回什么： 12345678&#123; "data": &#123; "client": &#123; "id": "1", "name": "Uncle Charlie" &#125; &#125;&#125; server会返回一个JSON串。这个JSON的schema和查询的基本一致。 变量(Variable)1234567891011121314151617181920212223query($clientId: Int) &#123; client(id: $clientId) &#123; name dob &#125; purchases(client_id: $clientId) &#123; date quantity total product &#123; name price product_category &#123; name &#125; &#125; client &#123; name dob &#125; &#125;&#125; 123&#123; "clientId": 1&#125; Graphql的schema下1234567schema&#123; query: Query, mutation: Mutation,&#125; Mutation（修改）增、删、改一类的operation在GraphQL里统称为变异（mutation，即修改数据） GraphQL中将对数据的修改操作称为 mutation。在 GraphQL Schema 中按照如下形式来定义一个 mutation： mutation 查询和普通查询请求（query）的重要区别在于 mutation 操作是序列化执行的。例如 GraphQL 规范中给出的示例，服务器一定会序列化处理下面的 mutation 请求： 请求结束时 theNumber 的值会是 2。 create_client增加 12345678910mutation &#123; create_client ( name: "查理大叔" dob: "2017/01/28" ) &#123; id name dob &#125;&#125; update_client更新 12345678910mutation &#123; update_client ( id: 5 dob: "1990/01/01" ) &#123; id name dob &#125;&#125; destroy_client删除 123456mutation &#123; destroy_client(id: 5) &#123; name dob &#125;&#125; 修改数据就像Rest以PUT／POST约定为修改服务器端数据一样，Mutations操作在GraphQL的意义就是修改数据库。就像官网中的例子： 12345678910111213mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123; //!表示必须填写的查询条件 createReview(episode: $ep, review: $review) &#123; stars commentary &#125;&#125;&#123; &quot;ep&quot;: &quot;JEDI&quot;, &quot;review&quot;: &#123; &quot;stars&quot;: 5, &quot;commentary&quot;: &quot;This is a great movie!&quot; &#125;&#125; 需要注意的是，为了保证mutation操作不冲突，mutation只能序列执行。而query可以并行。 强类型由于 GraphQL 是一个强类型语言，所以它可以在执行查询之前检查每个查询语句是否满足事先设定的 schema，符合则合法，如果查询语句不合法则不进行查询。 Fragments(组合)GraphQL 可以组合使用查询。比如可以定义一种叫 fragment 的东西，就是查询片断，然后我们可以在不同的地方重复的去使用查询。比如下面的这个例子： 1234567891011&#123; me &#123; name friends &#123; name events &#123; name &#125; &#125; &#125;&#125; 可以转换成这样： 123456789101112131415&#123; me &#123; name friends &#123; ...firendFragment &#125; &#125;&#125;fragment friendFragment on User &#123; name events &#123; name &#125;&#125; 上面定义了一个叫 friendFragment 的查询片断，它返回用户朋友的名字，还有参加的活动的名字，然后我们可以在其它的查询里面使用这个查询片断。 简单的说，GraphQL 是一种描述请求数据方法的语法，通常用于客户端从服务端加载数据。GraphQL 有以下三个主要特征： 它允许客户端指定具体所需的数据。 它让从多个数据源汇总取数据变得更简单。 它使用了类型系统来描述数据。 一个 GraphQL API 主要由三个部分组成：schema（类型），queries（查询） 以及 resolvers（解析器）。 Arguments(参数)123456&#123; human(id: "1000") &#123; name height &#125;&#125; 12345678&#123; "data": &#123; "human": &#123; "name": "Luke Skywalker", "height": 1.72 &#125; &#125;&#125; 当然在字段里我们也可以传参数. 123456&#123; human(id: "1000") &#123; name height(unit: FOOT//or METER) &#125;&#125; 12345678&#123; "data": &#123; "human": &#123; "name": "Luke Skywalker", "height": 5.6430448 // or 1.72 &#125; &#125;&#125; Aliases(别名)12345678&#123; empireHero: hero(episode: EMPIRE) &#123; name &#125; jediHero: hero(episode: JEDI) &#123; name &#125;&#125; 12345678910&#123; "data": &#123; "empireHero": &#123; "name": "Luke Skywalker" &#125;, "jediHero": &#123; "name": "R2-D2" &#125; &#125;&#125; Variables(变量)当我们开始使用变量的时候,我们需要做三件事情 Replace the static value in the query with $variableName Declare $variableName as one of the variables accepted by the query Pass variableName: value in the separate, transport-specific (usually JSON) variables dictionary 用$ 替换查询中的静态值 将$ 声明为查询接受变量之一 通常传递json. 123456789101112131415161718queryHeroNameAndFriends( $episode: Episode, )&#123; hero( episode: $episode)&#123; name friends&#123; name &#125; &#125;&#125;//variables&#123; "episode": "JEDI"&#125; 123456789101112131415161718&#123; "data": &#123; "hero": &#123; "name": "R2-D2", "friends": [ &#123; "name": "Luke Skywalker" &#125;, &#123; "name": "Han Solo" &#125;, &#123; "name": "Leia Organa" &#125; ] &#125; &#125;&#125; fieldsFields就是客户端要求GraphQL返回的数据说明，一个Fields也可以包含参数 Root fields &amp; resolvers1234567Query: &#123; human(obj, args, context) &#123; return context.db.loadHumanByID(args.id).then( userData =&gt; new Human(userData) ) &#125;&#125; obj上一个对象，其对于根查询类型的字段通常不被使用 args提供给GraphQL查询中的字段的参数。 context提供给每个解析器并保存重要的上下文信息（如当前登录的用户）或访问数据库的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Router v3]]></title>
      <url>%2FReact-Router.html</url>
      <content type="text"><![CDATA[React-Router3路径语法路由路径是匹配一个（或一部分）URL 的 一个字符串模式。大部分的路由路径都可以直接按照字面量理解，除了以下几个特殊的符号： :paramName – 匹配一段位于 /、? 或 # 之后的 URL。 命中的部分将被作为一个参数 () – 在它内部的内容被认为是可选的 * – 匹配任意字符（非贪婪的）直到命中下一个字符或者整个 URL 的末尾，并创建一个 splat 参数 12345678910//匹配 /hello/michael 和 /hello/ryan&lt;Route path=&quot;/hello/:name&quot;&gt; //匹配 /hello, /hello/02 和 /hello/01&lt;Route path=&quot;/hello(/:id)&quot;&gt; //匹配 /files/hello.jpg和/files/path/to/hello.jpg&lt;Route path=&quot;/files/*.*&quot;&gt; Histories常用的 history 有三种形式， 但是你也可以使用 React Router 实现自定义的 history。 browserHistory (推荐) hashHistory createMemoryHistory 1&lt;Router history=&#123;browserHistory&#125;&gt; browserHistoryBrowser history 是使用 React Router 的应用推荐的 history。它使用浏览器中的 History API 用于处理 URL，创建一个像example.com/some/path这样真实的 URL 。 在组件外部使用导航虽然在组件内部可以使用 this.context.router 来实现导航，但许多应用想要在组件外部使用导航。使用Router组件上被赋予的history可以在组件外部实现导航。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React State与Props的小心思]]></title>
      <url>%2FReact-State%E4%B8%8EProps%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D.html</url>
      <content type="text"><![CDATA[忙于期末考。。很久都没有更新博客了！因为找了个实习需要React所以这里写写自己在看React的官方文档中，遇到的问题。 Props与State很容易让我经常弄混先来说说Props 官方解释 组件从概念上看就是函数，之后这个组件可以接受任意的输入值，并返回一个需要页面上展示的React元素。那么这个输入值就为props。 个人理解 props是不可变的，传入什么值进去，最后返回的也是传入的值。也就是说，只读。 props父子传递12345678910111213141516function Uesr(props)&#123; return( &lt;div className=&#123;'abc'+ props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; );&#125;------------------------------------------------------------------------ function My()&#123; return( &lt;User color="red"&gt; &lt;h1&gt;nihao&lt;/h1&gt; &lt;/User&gt; );&#125; 在JSX标签内的任何内容都将通过children属性传入User。因为User在一个div内渲染了{props.children}，所以被传递的所有元素都会出现在最终输出中。 其实，我们也可以不用children。借用React官方文档的例子： 1234567891011121314151617181920212223242526272829303132function Contacts() &#123; return &lt;div className="Contacts" /&gt;;&#125;function Chat() &#123; return &lt;div className="Chat" /&gt;;&#125;function SplitPane(props) &#123; return ( &lt;div className="SplitPane"&gt; &lt;div className="SplitPane-left"&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className="SplitPane-right"&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; );&#125; 接下来Statestate怎么工作？通过调用setState(data,callback)方法，改变状态，就会触发React更新UI。 什么时候组件需要state呢？一般来说，大部分的组件应该从props属性中获取数据然后渲染。那么在！ 用户输入，服务器交互，这些情况下会用到State。在官方上说，尽可能的保持你的组件无状态化。 通过看官方文档。。我发现他们的模式是：构建几个无状态的组件用来渲染数据，然后在这些之上去构建一个有状态的组件同用户和服务器交互，数据通过props传递给无状态组件。 setState:更新组件状态。 setState会触发diff算法：判断state和页面结果的区别，是否需要更新。 状态(state)和属性(props)对比 状态和属性都会触发render更新，都是纯JS对象 状态：是和自己相关的，既不受父组件也不受子组件影响 属性：本身是不能自己去修改的，只能从父组件获取属性，父组件也能修改它的属性 根本的区别：组件在运行时需要去修改维护的就是状态]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript闭包]]></title>
      <url>%2FJavaScript%E9%97%AD%E5%8C%85.html</url>
      <content type="text"><![CDATA[闭包/bibao/Closures什么是闭包MDN对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 阮老师对闭包的定义为： 闭包就是能够读取其他函数内部变量的函数。 可以把闭包简单理解成”定义在一个函数内部的函数”。 红宝书对闭包的定义为： 闭包是指有权访问另一个函数作用域中的变量的函数 那么圣经犀牛书对闭包定义为： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为‘闭包’” 我个人比较认同红宝书的定义。 12345678function foo()&#123; var a = 2; function bar()&#123; console.log(a); // 2 &#125; bar();&#125;foo(); 我们来做一个数组求和 123456function sum(arr)&#123; return arr.reduce(function(x,y)&#123; return x+y; &#125;);&#125;sum([3,4,5,6]); //18 但是我们想要返回函数 12345678function smallsum(arr)&#123; var sum = function()&#123; return arr.reduce(function(x,y)&#123; return x+y; &#125;); &#125; return sum;&#125; 当我们想要用smallsum的时候返回的却是个函数。 1var result = smallsum([3,4,5,6]); //function sum() 直到我们调用result 1result(); //18 在这个例子中，我发现内部函数sum可以调用外部函数smallsum的参数和局部变量。 当我们调用smallsum的时候，每次调用都会产生一个新的函数。即使你传入的值相同。 123var result1 = smallsum([3,4,5,6]);var result2 = smallsum([3,4,5,6]);result1 === result2; //false 假如123456789function l()&#123; var arr= []; for(var i=0;i&lt;4;i++)&#123; arr.push(function()&#123; return i; &#125;); &#125; return arr;&#125; 12345678var a= l();var f1=a[0];var f2=a[1];var f3=a[2];f1(); //4f2(); //4f3(); //4 12345678910111213141516171819function l()&#123; var arr= []; for(var i=0;i&lt;4;i++)&#123; arr.push((function(n)&#123; return function()&#123; return n; &#125; &#125;)(i)); &#125; return arr;&#125;var a= l();var f1=a[0];var f2=a[1];var f3=a[2];f1(); //0f2(); //1f3(); //2 注意这里用了一个“创建一个匿名函数并立刻执行”的语法： 123(function (n) &#123; return n;&#125;)(1); //1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript作用域与作用域链]]></title>
      <url>%2FJavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F.html</url>
      <content type="text"><![CDATA[Javascript作用域与作用域链作用域简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。 变量作用域全局变量拥有全局作用域。在JavaScript任何地方都是有定义的。123456var l="我是全局变量"; //声明了一个全局变量function scope()&#123; var l="我是局部变量"; //声明了一个同名的局部变量 return l;&#125;scope() //输出“我是局部变量” 在函数内声明变量前不加var就是一个全局变量。 123456789var l="我是全局变量";function scope()&#123; l="我还是全局变量"; //改变了全局变量 m="我是一个新的全局变量"; //声明了一个新的全局变量 return [l,m];&#125;scope() //输出"我是一个新的全局变量"lm 在函数内声明的变量只在函数内有定义，它们是局部变量，作用域是局部性的。12345678910var l="我是全局变量";function scope()&#123; var l="我是局部变量"; function scope1()&#123; var l="我是一个新的局部变量"; //嵌套作用域内的局部变量 return l; //返回当前作用域内的值 &#125; return scope1();&#125;scope(); //嵌套作用域 函数作用域和声明提前函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。只是改变函数内部。 变量在声明它们的函数体以及这个函数体嵌套的任意的函数体内都是有定义的。 123456function func() &#123; console.log(num); //输出：undefined，而非报错，因为变量num在整个函数体内都是有定义的 var num = 1; //声明num 在整个函数体func内都有定义 console.log(num); //输出：1 &#125; func(); 再看看下面这个例子： 123456789var num=2;function func() &#123; var num; console.log(num); //输出：undefined，而非报错，因为变量num在整个函数体内都是有定义的 var num = 1; //声明num 在整个函数体func内都有定义 console.log(num); //输出：1 &#125; console.log(num); //输出2 func(); 作用域链用途： 保证对执行环境有权访问的所有变量和函数的有序访问。 作用域链上有两个对象。 第一个是定义函数参数和局部变量的对象 第二个是全局对象 当定义一个函数时，它实际上保存一个作用域链。 高程三下这个例子就特别好 1234567891011121314var color = "blue";function changeColor()&#123; var anotherColor = "red"; function swapColors()&#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; //能访问 color、anotherColor、tempColor。 &#125; swapColors(); //能访问color、anotherColor不能访问tempColor。&#125;changeColor(); //只能访问color changeColor()的作用域链中只包含2个对象：它自己的变量对象和全局变量对象。所以它不能访问swapColor()的环境。 那么在swapColors()的作用域链中又3个对象：swapColors()的变量对象、changeColor()的变量对象和全局变量对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript——16道算法题]]></title>
      <url>%2FJavaScript%E2%80%94%E2%80%9416%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98.html</url>
      <content type="text"><![CDATA[Let‘s go1.Reverse a String翻转字符串 先把字符串转化成数组，再借助数组的reverse方法翻转数组顺序，最后把数组转化成字符串。 你的结果必须得是一个字符串 这是一些对你有帮助的资源: Global String Object String.split() Array.reverse() Array.join() reverseString(&quot;hello&quot;) 应该返回 &quot;olleh&quot;. 1234function reverseString(str) &#123; return str.split('').reverse().join('');&#125;reverseString("hello"); 2.Factorialize a Number计算一个整数的阶乘 如果用字母n来代表一个整数，阶乘代表着所有小于或等于n的整数的乘积。 阶乘通常简写成 n! 例如: 5! = 1 * 2 * 3 * 4 * 5 = 120 这是一些对你有帮助的资源: Arithmetic Operators factorialize(5) 应该返回 120. 12345678910function factorialize(num) &#123; if(num&lt;0)&#123; return -1; &#125;else if(num ===0||num===1)&#123; return 1; &#125;else&#123; return (num*factorialize(num-1)); &#125;&#125;factorialize(5); 3.Check for Palindromes如果给定的字符串是回文，返回true，反之，返回false。 如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)。 注意你需要去掉字符串多余的标点符号和空格，然后把字符串转化成小写来验证此字符串是否为回文。 函数参数的值可以为&quot;racecar&quot;，&quot;RaceCar&quot;和&quot;race CAR&quot;。 这是一些对你有帮助的资源: String.replace() String.toLowerCase() palindrome(&quot;race car&quot;) 应该返回 true. palindrome(&quot;not a palindrome&quot;) 应该返回 false. 123456789101112function palindrome(str) &#123; // Good luck! var re = /[\W_]/g; var slo=str.toLowerCase().replace(re,""); var slow=slo.split('').reverse().join(''); if(slo==slow)&#123; return true;&#125; else&#123; return false; &#125;&#125;palindrome("我爱你"); 4.Find the Longest Word in a String找到提供的句子中最长的单词，并计算它的长度。 函数的返回值应该是一个数字。 这是一些对你有帮助的资源: String.split() String.length findLongestWord(&quot;The quick brown fox jumped over the lazy dog&quot;) 应该返回 6. 123456789101112function findLongestWord(str) &#123; var arr=str.split(' '); var long=0; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i].length&gt;long)&#123; long=arr[i].length; &#125; &#125; return long;&#125;findLongestWord("The quick brown fox jumped over the lazy dog"); 5.Title Case a Sentence确保字符串的每个单词首字母都大写，其余部分小写。 像’the’和’of’这样的连接符同理。 这是一些对你有帮助的资源: String.split titleCase(&quot;I&#39;m a little tea pot&quot;) 应该返回 “I’m A Little Tea Pot”. 1234567891011function titleCase(str) &#123; var arr=str.toLowerCase().split(' '); var l=[]; for(var i=0;i&lt;arr.length;i++)&#123; var str1=arr[i].slice(0,1).toUpperCase()+arr[i].slice(1); l.push(str1); &#125; return l.join(' ');&#125;titleCase("I'm a little tea pot"); 首先我们需要把这个字符串的每一项都变成小写字母并转换成数组 创建一个保存新的空数组 用遍历数组的长度。之后我们把每一项数组的第一个字母用slice()变成大写。 再push到空的数组里。 最后用join()数组返回字符串。 6.Return Largest Numbers in Arrays右边大数组中包含了4个小数组，分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新数组。 提示：你可以用for循环来迭代数组，并通过arr[i]的方式来访问数组的每个元素。 这是一些对你有帮助的资源: Comparison Operators largestOfFour([[13, 27, 18, 26], [4, 5, 1, 3], [32, 35, 37, 39], [1000, 1001, 857, 1]]) 应该返回 [27,5,39,1001]. 第一种方法1234567891011function largestOfFour(arr) &#123; // You can do this! var l=[]; for(var i=0;i&lt;arr.length;i++)&#123; arr[i].sort(function(a,b)&#123;return b-a&#125;); &#125; l.push(arr[i][0]);&#125;return l;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); 第二种方法 123456789101112function largestOfFour(arr) &#123; // You can do this! var temp = []; for(var i = 0; i &lt; arr.length; i++)&#123; var l = arr[i].reduce(function(prev,cur,index,array)&#123; return prev &gt; cur ? prev : cur; &#125;); temp.push(l); &#125; return temp;&#125;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端面试题]]></title>
      <url>%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
      <content type="text"><![CDATA[前端面试题题目来自朴灵大大的github 介绍JavaScript的基本数据类型JavaScript有5种简单数据类型： Undefined、Null、Boolean、Number、String。还有一种复杂数据类型Object。 typeof操作符用typeof操作符能检测给定变量的数据类型。（括号中是自己的理解意思） “undefined” ————这个值没有被定义。（这个变量存在但是没有给它值） “boolean” ————这个值是布尔值。（这个值有true或false输出） “string” ————这个值是字符串。（字符串或字符序列） “number” ————这个值是数值。（字面意思） “object” ————这个值是对象或null。(这个值可能是个对象或者空) “function” ————这个值是函数。(字面意思) 12var message="wa";alert(typeof wa); //string Undefined类型使用var声明变量但没有给它加以初始化，这个变量的值就是undefined。 12var message;alert(message == undefined); //true Null类型null表示一个空对象指针，但是用typeof操作符检测null会返回object的原因是什么？ 12var car =null;alert("typeof car"); //"object" 只要意在保存对象的变量还没有真正的保存对象，就应该明确地让该变量保存null值。这样有助于进一步区分null和undefined。 Boolean类型这个字母值就是true、false。但是这两个值和数字不是一回事情。所以 true不一定等于 1 ， false不一定等于 0 。 还有布尔值是区分大小的 True和 False都不是 Boolean值。 Number类型 浮点数值 数值范围 最小值保存在Number.MIN_VALUE ： 5e-324。 保存着-Infinity 最大值保存在Number.MAX_VALUE : 1.796931348623157e+308。保存着Infinity。 想确定一个数值是否有穷可以用isFinite()函数。这个函数会在最小和最大数值之间会返回 true。 1alert(isFinite(result)); NaN（Not a Number） 任何涉及NaN的操作（NaN/10）都会返回 NaN。 还有 NaN与任何值都不想等，包括 NaN本身。 实际上0除以0才会返回 NaN，正数除以0返回 Infinity，负数除以0返回 -Infinity。 isNaN()函数可以确定这个函数是否不是数值。这个函数在收到一个值后会去尝试将转换为数值。不能被转换就返回true。 数值转换 三个函数 可以 把非数值转换为数值。 Number() 可以用于任何数据类型 parseInt() 字符串转换成数值 parseFloat() 字符串转换成数值 String类型由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以用双引号（”）或单引号（’）表示。 字符字面量——转义序列 （\n 换行 ​ \t 制表···） 字符串的特点——字符串是不可改变的。一旦创建，它们的值就不能改变。要改变就要先摧毁。 12var lang="Java";lang=lang+"Script"; 转换为字符串 使用 toString()方法 但是null和undefined没有这个方法所以， 就使用String()方法 Object类型对象其实就是一组数据和功能的集合。 1var o =new Object(); 说说写JavaScript的基本规范？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue.js小记]]></title>
      <url>%2FVue.js%E5%B0%8F%E8%AE%B0.html</url>
      <content type="text"><![CDATA[#Vue小记 v-bind 缩写： ： 修饰符 .prop - 被用于绑定DOM属性 .camel 用法 动态的绑定一个或多个特性，或一个组件prop到表达式 1&lt;a v-bind:href="url" href="#"&gt;&lt;/a&gt; 在这里:href是参数，通过v-bind指令将该元素的href属性与表达式的url绑定。 v-if1&lt;p v-if="seen"&gt;Now you see me&lt;/p&gt; 这个v-if指令将判断seen的真假值来移出/插入&lt;p&gt;元素。 v-on 缩写：@ 1&lt;a v-on:click="doSomething"&gt; 这个指令是用来监听DOM事件。 事件修饰符 .stop .prevent .capture .self .once 12345678910111213141516&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;2.1.4新增&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once="doThis"&gt;&lt;/a&gt; 按键修饰符1234567&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13="submit"&gt;记住keyCode各种值很难所以提供了别名&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt; .enter .tab .delete(捕获“删除”和“退格”按键) .esc .space .up .down .left .right 2.1.0新增 .ctrl .alt .shift .meta(Mac上为(⌘)在windows上为(⊞)) v-for我们用 v-for 指令根据一组数组的选项列表进行渲染。 v-for 指令需要以 item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名。 12345&lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789var example1 = new Vue(&#123; el: '#example-1', data: &#123; items: [ &#123;message: 'Foo' &#125;, &#123;message: 'Bar' &#125; ] &#125;&#125;) 结果： Foo Bar v-model你可以用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。 具体看]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初入React+Webpack(入门)]]></title>
      <url>%2F%E5%88%9D%E5%85%A5React.html</url>
      <content type="text"><![CDATA[因为需要做一个自己的小想法以后需要去实现把这个想法变成项目，在重多得框架中选择React.js，因为它需要学习成本，所以我觉得我在学习的过程中能学到很多东西。 通过npm使用React建议在 React 中使用 CommonJS 模块系统，比如 browserify 或 webpack。使用 react 和 react-dom npm 包. 我使用webpack来安装React DOM的 12$ npm install --save react react-dom babelify babel-preset-react$ browserify -t [ babelify --presets [ react ] ] main.js -o bundle.js 那么第一步肯定是创建Hello World啦~ 我们需要创建一个helloworld.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Hello React!&lt;/title&gt; &lt;script src="build/react.js"&gt;&lt;/script&gt; &lt;script src="build/react-dom.js"&gt;&lt;/script&gt; &lt;script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在代码中 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); 这是jsx语法。可以去 JSX 语法 里学习更多 JSX 相关的知识。为了把 JSX 转成标准的 JavaScript，我们用 &lt;script type=&quot;text/babel&quot;&gt; 标签，并引入 Babel 来完成在浏览器里的代码转换。在浏览器里打开这个html，你应该可以看到成功的消息！ 分离文件那么我们在React中也是可以分离js的。 我们需要创建一个下面的build/helloworld.js 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example')); 之后我们在html的文件中像以前引用文件一样去引用就可以了。 1&lt;script type="text/babel" src="src/helloworld.js"&gt;&lt;/script&gt; 但是我是用chrome不会显示效果。之后我用safari效果成功显示，后来打开控制台发现http以外的协议加载失败了。读取不了&lt;script src=&quot;https://npmcdn.com/babel-core@5.8.38/browser.min.js&quot;&gt;&lt;/script&gt;那么就我就去跟着开发文档配置了babel。 BabelBabel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看：Babel Webpack(入门)webpack是什么？webpack是一个模块化打包工具，使用js作为载体将所有静态资源打包在一起，支持的loader和plugin等能对各种静态资源进行预处理，极大地方便了前端的工程化开发。详情参考官网 ###开始使用Webpack我们来一步一步去开始学习使用Webpack。 ###安装Webpack可以使用npm安装，新建一个空白的文件夹（我的为webpackwhat），在终端中转到该文件夹下（cd webpackwhat）进行安装。 1234//全局安装npm install -g webpack//安装到你的项目目录npm install --save-dev webpack 我们在终端中使用npm init的命令可以自动创建这个package.json文件 1npm init 输入后，会有一些需要你输入的信息，你只需要一直回车就行了。 接下来我们在这个文件夹下进行安装Webpack作为依赖包 12//安装Webpacknpm install --save-dev webpack 回到之前的空文件夹，并在里面创建两个文件夹,app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放准备给浏览器读取的数据（包括使用webpack生成的打包后的js文件以及一个index.html文件）。在这里还需要创建三个文件，index.html 文件放在public文件夹中，两个js文件（Greeter.js和main.js）放在app文件夹中. index.html文件只有最基础的html代码，它唯一的目的就是加载打包后的js文件（bundle.js） 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='root'&gt; &lt;/div&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Greeter.js只包括一个用来返回包含问候信息的html元素的函数。 123//main.js var greeter = require(&apos;./Greeter.js&apos;);document.getElementById(&apos;root&apos;).appendChild(greeter()); main.js用来把Greeter模块返回的节点插入页面。 123456// Greeter.jsmodule.exports = function() &#123; var greet = document.createElement(&apos;div&apos;); greet.textContent = &quot;Hi there and greetings!&quot;; return greet;&#125;; 正式使用Webpack12//webpack非全局安装的情况node_modules/.bin/webpack app/main.js public/bundle.js 可以看出webpack同时编译了main.js 和Greeter,js,现在打开index.html,可以看到如下结果 通过配置文件来使用WebpackWebpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如已经提到的，这样不太方便且容易出错的，一个更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，可以把所有的与构建相关的信息放在里面。 还是继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，并在其中进行最最简单的配置，如下所示，它包含入口文件路径和存放打包后文件的地方的路径。 1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 更快捷的执行打包任务执行类似于node_modules/.bin/webpack这样的命令其实是比较烦人且容易出错的，不过值得庆幸的是npm可以引导任务执行，对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可，设置方法如下。 12345678910111213&#123; &quot;name&quot;: &quot;webpack-sample-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Sample webpack project&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令 &#125;, &quot;author&quot;: &quot;zhang&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^1.12.9&quot; &#125;&#125; 注：package.json中的脚本部分已经默认在命令前添加了node_modules/.bin路径，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。 npm的start是一个特殊的脚本名称，它的特殊性表现在，在命令行中使用npm start就可以执行相关命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build Loaders鼎鼎大名的Loaders登场了！ Loaders是webpack中最让人激动人心的功能之一了。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。 Loaders需要单独安装并且需要在webpack.config.js下的modules关键字下进行配置，Loaders的配置选项包括以下几方面： test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 继续上面的例子，我们把Greeter.js里的问候消息放在一个单独的JSON文件里,并通过合适的配置使Greeter.js可以读取该JSON文件的值，配置方法如下 12//安装可以装换JSON的loadernpm install --save-dev json-loader 12345678910111213141516171819202122232425module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123;//在配置文件里添加JSON loader loaders: [ &#123; test: /\.json$/, loader: &quot;json&quot; &#125; ] &#125;, devServer: &#123; contentBase: &quot;./public&quot;, colors: true, historyApiFallback: true, inline: true &#125;&#125; 创建带有问候信息的JSON文件(命名为config.json) 1234//config.json&#123; &quot;greetText&quot;: &quot;Hi there and greetings from JSON!&quot;&#125; 更新后的Greeter.js 1234567var config = require(&apos;./config.json&apos;);module.exports = function() &#123; var greet = document.createElement(&apos;div&apos;); greet.textContent = config.greetText; return greet;&#125;; Loaders很好，不过有的Loaders使用起来比较复杂，比如说Babel。 BabelBabel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过编译帮你达到以下目的： 下一代的JavaScript标准（ES6，ES7），这些标准目前并未被当前的浏览器完全的支持； 使用基于JavaScript进行了拓展的语言，比如React的JSX Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，不过webpack把它们整合在一起使用，但是对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包）。 我们先来一次性安装这些依赖包 12// npm一次性安装多个依赖模块，模块之间用空格隔开npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react 在webpack中配置Babel的方法如下 123456789101112131415161718192021222324252627282930313233module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json-loaders&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loaders&apos;,//在webpack的module部分的loaders里进行配置即可 query: &#123; presets: [&apos;es2015&apos;,&apos;react&apos;] &#125; &#125; ] &#125;, devServer: &#123; contentBase: &quot;./public&quot;, colors: true, historyApiFallback: true, inline: true &#125;&#125; 现在你的webpack的配置已经允许你使用ES6以及JSX的语法了。继续用上面的例子进行测试，不过这次我们会使用React，记得先安装 React 和 React-DOM 1npm install --save react react-dom 使用ES6的语法，更新Greeter.js并返回一个React组件 123456789101112131415//Greeter,jsimport React, &#123;Component&#125; from &apos;react&apos;import config from &apos;./config.json&apos;;class Greeter extends Component&#123; render() &#123; return ( &lt;div&gt; &#123;config.greetText&#125; &lt;/div&gt; ); &#125;&#125;export default Greeter 使用ES6的模块定义和渲染Greeter模块 12345import React from &apos;react&apos;;import &#123;render&#125; from &apos;react-dom&apos;;import Greeter from &apos;./Greeter&apos;;render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;)); Babel的配置选项Babel其实可以完全在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下： 1234567891011121314151617181920212223242526// webpack.config.jsmodule.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json-loaders&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loaders&apos; &#125; ] &#125;, devServer: &#123;...&#125; // Omitted for brevity&#125; 1234//.babelrc&#123; &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;]&#125; 到目前为止，我们已经知道了，对于模块，Webpack能提供非常强大的处理功能，那那些是模块呢。 CSSwebpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(...)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。 继续上面的例子 12//安装npm install --save-dev style-loader css-loader 123456789101112131415161718192021222324252627282930//使用module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/build&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json-loaders&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loaders&apos; &#125;, &#123; test: /\.css$/, loader: &apos;style-loaders!css-loaders&apos;//添加对样式表的处理 &#125; ] &#125;, devServer: &#123;...&#125;&#125; 注：感叹号的作用在于使同一文件能够使用不同类型的loader 接下来，在app文件夹里创建一个名字为”main.css”的文件，对一些元素设置样式 12345678910111213141516171819html &#123; box-sizing: border-box; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125;body &#123; margin: 0; font-family: &apos;Helvetica Neue&apos;, Helvetica, Arial, sans-serif;&#125;h1, h2, h3, h4, h5, h6, p, ul &#123; margin: 0; padding: 0;&#125; 你还记得吗？webpack只有单一的入口，其它的模块需要通过 import, require, url等导入相关位置，为了让webpack能找到”main.css“文件，我们把它导入”main.js “中，如下 12345678//main.jsimport React from &apos;react&apos;;import &#123;render&#125; from &apos;react-dom&apos;;import Greeter from &apos;./Greeter&apos;;import &apos;./main.css&apos;;//使用require导入css文件render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;)); 通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独的文件的。 不过这也只是webpack把css当做模块而已，咱们继续看看一个真的CSS模块的实践。 感谢网上各大资源 参考以及转载（其中在原文中有些错误我已经更改） 入门Webpack，看这篇就够了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6箭头函数]]></title>
      <url>%2FEs6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0.html</url>
      <content type="text"><![CDATA[简单地说， 12345var a = x =&gt; x;//var a =function(x)&#123; return x;&#125;; 这个就是最简单的箭头函数。 接着如果箭头函数不需要参数或者多个参数的话， 1234567var a = () =&gt; 1;//var a =function()&#123; return 1;&#125;;或者var a = _ =&gt;1; 12345var sum = (num1,num2) =&gt;num1 +num2;//var sum =function(num1,num2)&#123; return num1+num2;&#125;; 箭头函数没有自己的this， 123456(function ()&#123; return [ (()=&gt; this.x).bind(&#123;x :'inner'&#125;)() ]&#125;).call(&#123;x :'outer'&#125;);//['outer'] 所以bind的方法无效。并且call(),apply(),也无效。 MDN上的 1234567891011121314151617181920var adder = &#123; base : 1, add : function(a) &#123; var f = v =&gt; v + this.base; return f(a); &#125;, addThruCall: function(a) &#123; var f = v =&gt; v + this.base; var b = &#123; base : 2 &#125;; return f.call(b, a); &#125;&#125;;console.log(adder.add(1)); // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript变量+方法]]></title>
      <url>%2FJavaScript%E5%8F%98%E9%87%8F.html</url>
      <content type="text"><![CDATA[JavaScript变量+方法ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。 基本类型值指的是简单的数据段，而引用类型值指那些可能有多个值构成的对象。 传递参数12345678function addTen(num)&#123; num +=10; return num;&#125;var count =20;var result = addTen(count);alert(count); //20,没变化alert(result); //30 在这上面看了高程三的话懵懵懂懂，实际上在说的是，要执行alert(count);时count只是把20复制给参数num，以便20在addTen()中使用，在函数里面num的值确实+10变成了30，但是不影响外部count的变量。 方法 split() 方法讲一个字符串对象的每个字符拆出来，并且将每个字符串当数组的每个元素。 重排序方法 reverse()和sort() reverse()方法会反转数组项的顺序。 123var values = [1,2,3,4,5];values.reverse();alert(values); //5,4,3,2,1 而 sort()方法是按升序排列数组项。——最小的值位于前面，最大的值排在最后面。而且sort()方法会调用每个数组项的toString()转型方法，然后去比较得到的字符串。 123var values = [0,1,5,10,15];values.sort();alert(values); //0,1,10,15,5 在字符串的比较时，10则位于5的前面，于是数组的顺序就被修改了。当然改为降序也行参考注释 123456789function compare (value1,value2)&#123; if(value1 &lt;value2)&#123; return -1; //return 1; &#125;else if(value1 &gt;value2)&#123; return 1; //return -1; &#125;else&#123; return 0; &#125;&#125; 然后我们再把这个参数传给sort()方法即可。 123var values = [0,1,5,10,15];values.sort(compare);alert(values); //0,1,5,10,15]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基本概念（高程3）]]></title>
      <url>%2FJavaScript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5copy.html</url>
      <content type="text"><![CDATA[JavaScript基本概念（高程3）数据类型typeof操作符“undefined”——如果这个值未定义; “boolean”——如果这个值是布尔值; “string”——如果这个值是字符串; “number”——如果这个值是数值; “object”——如果这个值是对象或null; “function”——如果这个值是函数; Undefined类型 Undefined类型只有一个值，即特殊的undefined。 Null类型 Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值会返回”object”的原因。 Boolean类型 Boolean类型是ECMAScript中使用得最多的一种类型，该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0. Number类型整数通过八进制（以8为基数）或十六进制（以16为基数）的字面值来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0~7）。 十六进制字面值的前两位必须是0x，后跟任何十六进制数字（0~9及A~F）。 浮点数值 永远不要测试某个特定的浮点数值。 如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。 数值范围 12var result= Number.MAX_VALUE +Number.MAX_VALUE;alert(isFinite(result)); //false NaN NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。 它本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不想等，包括NaN本身。例如， 1alert(NaN == NaN); //false 数值转换 1234var num1 = Number("Hello world"); //NaNvar num2 = Number(" "); //0var num3 = Number("000011"); //11var num4 = Number("true"); //1 String类型 字符字面量-也叫转义序列 字符串的特定 字符串一旦创建，它们的值就不能改变。 转换为字符串 要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的toString()方法。第二用String方法。 Object类型 constructor:保存着用于创建当前对象的函数。 hasOwnProperty（propertyName）:用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(“name”)）。 isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型。 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。与2方法一样，作为参数必须以字符串形式指定。 toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。 toString():返回对象的字符串表示。 valueOf():返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。 操作符一元操作符 递增和递减操作符 ​ 递增和递减操作符直接借鉴C。 位操作符 符号位的值决定了其他为数值的格式。 负数同样以二进制码存储，但使用的格式是二进制补码 按位非（NOT） 按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码。 1234var num1 = 25;//二进制00000000000000000000000000011001//二进制11111111111111111111111111100110var num2 = ~num1;alert(num2);//-26 按位与（AND） 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 0 0 1 0 0 0 0 简而言之，按位与操作只在两个数值的对应位都是1时才返回1，任何一位是0，结果都是0. 按位或（OR） 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 1 0 1 1 0 0 0 按位或操作在有一个位是1的情况下就返回1，而只有在两个位都是0的情况下才返回0. 按位异或（XOR） 第一个数值的位 第二个数值的位 结果 1 1 0 1 0 1 0 1 1 0 0 0 按位异或与按位或的不同之处在于，这个操作两个数值对应位上只有一个1时才返回1，如果对应的两位都是1或是0，则返回0. 左移 左移操作符由两个小于号（&lt;&lt;）表示。 12var oldValue = 2; //等于二进制的10var newValue = oldValue &lt;&lt; 5;//等于二进制的1000000,十进制的64 有符号的右移 有符号的右移操作符由两个大于号（&gt;&gt;）表示。 12var oldValue = 64;//等于二进制的1000000var newValue = oldValue &gt;&gt; 5;//等于二进制的10，即十进制的2 无符号右移 无符号右移操作符由3个大于号（&gt;&gt;&gt;）表示。 12var oldValue = 64;//等于二进制的1000000var newValue =oldValue &gt;&gt;&gt; 5;//等于二进制的10，即十进制的2 无符号右移操作符会把负数的二进制码当成正数的二进制码。而且由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。 12var oldValue = -64;//等于二进制的11111111111111111111111111000000var newValue = oldValue &gt;&gt;&gt;5;//等于十进制的134217726 布尔操作符 逻辑非（！） 123456alert(!false); //truealert(!"blue"); //falsealert(!0); //truealert(!NaN); //truealert(!""); //truealert(!12345); //false 逻辑与（&amp;&amp;） 第一个操作数 第二个操作数 结果 true true true true false false false true false false false false 在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值。 逻辑或 true true true true false true false true true false false false 第一个操作数 第二个操作数 结果 与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值，]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript DOM编程艺术学习笔记一（第三章兼高程三）]]></title>
      <url>%2FJavascript%20Dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%85%BC%E9%AB%98%E7%A8%8B%E4%B8%89%EF%BC%89.html</url>
      <content type="text"><![CDATA[1.Dom基础Element 三种DOM方法可获取元素节点，分别是通过元素ID、通过标签名字和通过类名字来获取 getElementById 根据Id获取元素节点 getElementByTagName 根据Html获取元素节点 getElementByClassName 根据ClassName（class）获取元素节点 高程三中学到Html元素 id，元素在文档中的唯一标识 - title，有关元素的附加说明信息，一般通过工具提示条显示出来 lang，元素内容的语言比如中文zh-hans dir，语言的方向，值为”ltr”（left-to-right，从左至右）或”rtl”（right-to-left，从右至左），很少使用 className，与元素的class特性对应，即为元素指定的CSS类，没有将这个属性命名为class。 1&lt;div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr"&gt;Some text&lt;/div&gt; 可以获得元素中指定的所有信息。 123456div = document.getElementById("myDiv"); alert(div.id); //"myDiv" alert(div.className); //"bd" alert(div.title); //"Body text" alert(div.lang); //"en" alert(div.dir); //"ltr" 还可以为每个属性赋予新的值。 123456div = document.getElementById("myDiv"); div.id = "someOtherId"; div.className = "ft"; div.title = "Some other text"; div.lang = "fr"; div.dir ="rtl"; 获取和设置属性 getAttribute getAttribute是一个函数。它只有一个参数——你打算查询的属性名字：1object.getAttribute(attribute); setAttribute 它允许我们对属性节点的值做出修改。 1object.setAttribute(&quot;attribute&quot;,value);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017Web程序员技术发展路线图]]></title>
      <url>%2F2017Web%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E8%B7%AF%E7%BA%BF%E5%9B%BE.html</url>
      <content type="text"><![CDATA[这个是国外一个工程师的总结，在知乎上的前端技术文章精选专栏看见的，看着实用转来到这。 2017 年 Web 开发工程师技术发展路线图 下面的脑图展现了前端、后端以及 devops 技术栈的发展路线图，作者起初做这份技术发展脑图是给初学者和学生们准备的。 简介 前端开发工程师路线图 后端开发工程师路线图对于后端方面的技术，原作者表示比较喜欢和看好Nodejs、PHP7 以及 Ruby ，我自己觉得在国内来说 Nodejs 和 React Native 是目前很多前端开发工程师热衷探索的技术，而 Ruby 技术在国内始终不温不火，PHP技术比较传统。建议初学者们还是选择岗位更多的技术栈学习，当然如果你有自己喜欢的技术栈，那就可以暂时不考虑市场因素！ DevOps [GitHub链接:][1] [1] : kamranahmedse/developer-roadmap]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[配置SSH Key+Next主题以及个性化改动]]></title>
      <url>%2F%E9%85%8D%E7%BD%AESSH%20Key%2BNext%E4%B8%BB%E9%A2%98%E4%BB%A5%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E6%94%B9%E5%8A%A8.html</url>
      <content type="text"><![CDATA[Git SSH Key 生成步骤Git是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。 第一次使用要设置Git的user name 和email1$ git config --global user.name 1$ git config --global user.email 查看你是否已经拥有密钥 1$cd ~/.ssh 如果没有的话就不会有此文件，有的话就会备份删除掉 生成密钥 1$ ssh-keygen -t rsa -C “user.email” 你将会遇到以下情况的处理： 12345678 Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): 直接回车Enter passphrase (empty for no passphrase): 直接回车Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa. 公钥Your public key has been saved in /root/.ssh/id_rsa.pub. 私钥The key fingerprint is:4d:dd:48:af:76:c2:ba:a8:bc:20:f3:28:1d:6a:28:53 就是按3次回车，密码为空！最后你会得到两个文件：id_rsa和id_rsa.pub 把密钥加到Github或者码云或者Coding的SSH上我们需要把id_rsa.pub中的内容全选复制，然后粘贴进Pages的各自SSH地方，当然需要输入密码。 测试SSHGithub：1$ssh -T git@github.com 码云：1$ssh -T git@git.oschina.net Coding:1$ssh -T git@coding.net 若返回则配置成功github:1234The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added ‘github.com,207.97.227.239′ (RSA) to the list of known hosts. 码云：Welcome to Git@OSC, yourname!Coding：Enter passphrase for key ‘/c/Users/Yuankai/.ssh/id_rsa’: Coding.net Tips : [ Hello Kyle_lyk! You have connected to Coding.net by SSH successfully! ]那么配置好，我们就可以把Hexo部署到Git上了1$hexo deploy Hexo之Next Hexo有很多主题，有大道至简的maupassant 也有casper还有uno。但是我还是最喜欢next的风格。 安装Next安装Next是非常的简单。如果你熟悉Git那么你就可以直接使用Git checkout代码：12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 还有一种方法是下载稳定版本 前往Next版本发布页面 一直下拉找到Source code(zip)点击即可下载 之后把下载的压缩包至站点的themes目录下，并将解压后的文件名改为next。 启用Next 你需要打开你的站点目录找到_config.yml这个文件，记住不是themes下next中的_config.yml。 我们需要在站点文件_config.yml中ctrl+F打入theme字段，并将其值改为next：1theme:next 验证主题是否生成完成首先我们要右击你的站点然后选择Git Bash Here，并开启调试模式。1$ hexo s --debug 命令行出现：1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 那么我们就可以在网址上输入http://0.0.0.0:4000去查看效果，检查站点是否正确运行。 Next各种细节主题设定Scheme 是Next提供的一种特性，就因为Scheme我们有三种选择外观。 Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新Scheme 的切换通过更改 主题配置文件（theme/next下的_config.yml），搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。123#scheme: Muse#scheme: Mistscheme: Pisces 还有更多的小东西大家可以去Next官方文档看。比如说 菜单， 侧栏， 头像， 作者昵称， 站点描述， 第三方服务等。 Next中foot更改我把原来的什么Hexo啊..Next.Pisces啊通通改了，这才像我们自己的博客呀！没得说。我们需要打开next下的layout接着打开_partials下的footer.swig。然后我们要把其中红框里的删除。紧接着我们回到next下，找到languages，打开zh-Hans.yml。我们可以改成如下：123footer: powered: &quot;个人专属 &quot; theme: Adherent 看大家的想法自己随意发挥！好啦，我要去研究SEO了！！祝大家建博成功]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node.js+hexo部署博客]]></title>
      <url>%2FNode.js%2Bhexo%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2.html</url>
      <content type="text"><![CDATA[初衷想了很久，还是要弄个博客来勉励自己来督促自己学习去记录。因为学生党，没能抢到腾讯云+阿里云学生优惠，又用过github pages而且挺想用markdown写作，就选择Hexo来搭建自己的博客。也许有人会说为什么不用Jekyll，因为我所用的是windows系统，而且不建议在windows系统下安装Jekyll，还有我准备发展方向是前端。hexo是基于Node.js而Jekyll是基于Ruby所以你懂的！还有我查了一下Hexo是台湾的程序员开发的，原生态支持中文。Node.js+Hexo。是因为我对js的热爱还有因为是台湾同胞的作品，所去选择的。现在我也就把自己搭建流程说一下以及自己遇到的问题着重提一下。 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Node下载安装Node注意事项Node.js根据自己电脑/喜好去选择是否用安装包还是绿色安装！建议路径中不要包含空格或者其他特殊字符，防止出现莫名其妙的错误，最好纯英文。 环境配置各种都要配置环境，Node也不例外。如果你的文件路径为D:\node也就是你Node.exe所在的位置。回到桌面点击（我是win10，win7,win8方法类似）我的电脑右键-属性-高级系统设置-高级-环境变量在Path项中加入D:\node这个路径。之后我们win+R打入cmd命令行去执行npm命令，如果没有提示找不到命令，则说明Node安装成功，如果有的话去看看自己是不是环境配置没有配置好。 配置国内镜像在国内可以用淘宝NPM镜像，这样各种安装和使用npm快很多而且还可以代替npm。你只要运行下面的命令1npm install -g cnpm --registry=https://registry.npm.taobao.org 同样测试有没有安装好，这次打cnpm就行拉，结果显示与上述相同。那么以后我们只要执行跟npm的命令时我们只要把npm替换成cnpm就行了！ 安装Git下载Git程序包作为萌新最希望能一步一步来，我也就一步一步和大家说，也为了以后自己注意一些Git的小细节。 windows下安装Git SCM Mac下安装GitSCM Linux and Unix下安装GitSCM 附上git使用简易指南 环境配置同样Git也需要环境配置，与Node配置一致。你Git的路径C:\Git\bin那么在Path中就可以这样写C:\Git\bin。下面要进入重点了！ 安装HexoHexo中文文档，我们把Hexo两大依赖Node.js和Git都已经安装配置完成。不出问题，那么下面则是水到渠成。接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli 有些人会发现执行上面那句下载缓慢还出错，那么因为我们已经用了淘宝NPM镜像我们直接使用以下命令：1$ cnpm install -g hexo-cli Windows Mac Linux Unix系统编译时遇到的问题则可以去Hexo中文文档里面寻找解决办法。 使用Hexo建站Hexo建站后产生的文件如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中最重要的是_config.yml这是网站的配置信息，我们可以在里面配置大部分的参数。去让我们的博客变得更加个性化。 创建站点找一个你自己想放你项目的目录，按住Shift然后在空白处右击打开Git Bash here执行下列命令，Hexo则会在指定的文件夹中新建所需要的文件。1$ hexo init site 然后我们再右键site文件夹执行以下命令：1$ hexo generate 这时，我们点开site会发现里面有个public的目录。这里面就是网站的静态文件。我们可以手动的把这些静态文件纳入git的仓库接着推送到开启page服务的分支上或者发布到Web服务器上。但是我还是推荐你们用Hexo的自动化部署。 自动化部署Hexo自动Git部署需要安装hexo-deployer-git，执行下列命令1cnpm install hexo-deployer-git --save 然后修改系统配置文件_config.yml（不是themes子目录下的主题配置文件）。修改deploy这一项的值，按照以下格式配置。如果没有这一项，直接在文件末尾添加即可。注意缩进，yml中使用缩进表示从属关系，用-表示一个序列（可以同时部署到多个仓库）。这里减号后有一个空格。以我的项目为例，配置内容如下：1234deploy:- type: git repo: git@git.coding.net:Adherent/Adherent.git branch: coding-pages type值不用修改，因为这里使用的是git的pages服务，类型就是git。repo为仓库地址，为了方便部署（免输账号密码），使用的是ssh协议的仓库地址。这需要配置ssh秘钥，具体参考生成并部署SSH key。branch为开启pages服务的分支名称。一般的，码云为osc-pages，Coding为coding-pages，GitHub为gh-pages。配置好部署信息后，即可用Hexo把静态页面部署到git上了。1hexo deploy 部署完成后，通过域名，应该就能访问到这些页面了。 部署SSH key则可以看我的部署SSH key的文章 Pages服务的选择都说做编程必须有GitHub而且上面还聚集了世界各地的开发者吧，因此很多人都在使用github的pages服务建站。但我还是推荐使用国内的码云或者Coding以获得更好的访问速度。Coding是支持自己添加域名的所以我选择用Coding。首先要创建一个项目，才能开启pages服务。可以去Coding Pages帮助中心看看如何开启以我的网站为例，项目地址为https://coding.net/u/Adherent/p/Adherent/git，开启pages服务的分支名称为coding-pages。项目初始化时并没有codingc-pages分支，可以等Hexo部署静态文件后再开启pages服务。 添加新文章博客建成，那么我们就可以写自己的博文了！执行下列命令：1$ hexo n 文章题目 以上命令就可以在source/_posts/目录中生成一个文件名为文章题目后缀名为.md`的文件。剩下的文件内容我们就可以用markdown语法写文章就好了。markdown语法参见Markdown 语法说明 (简体中文版)我推荐一款Cmd Markdown个人感觉用的还是很舒服的。这是Cmd Markdown的简明语法手册。然后执行以下命令即可生成新的页面，部署到git。1hexo g -d 同样的，把新添加的文件纳入git仓库，并推送到网上的仓库。123git add *git commit -m &quot;新的文章&quot;git push 到了这里，该系统已经能很好的运行了。更多的使用以及设置方法参考文档|Hexo即可。 参考文章 淘宝NPM镜像 git使用简易指南 文档|Hexo Cmd Markdown 启蒙`]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello, World!]]></title>
      <url>%2FHello%20World.html</url>
      <content type="text"><![CDATA[Hello World Hello World 第一篇就和大家打个招呼！ 多种语言的Hello World C 123456#include &lt;stdio.h&gt;int main()&#123; printf("Hello, World"); return 0;&#125; Java 12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("Hello World!"); &#125;&#125; Javascript 1console.log("Hello, World!"); Python 1print("Hello, World!") PHP 1echo 'Hello,World!'; Go 12345package mainimport "fmt"func main()&#123; fmt.Print("Hello, World!");&#125; setTimeout(function(){ console.log("I Love Mu"); alert("Hello, World!"); }, 5000);]]></content>
    </entry>

    
  
  
</search>
