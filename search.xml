<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vscode快捷键提升效率]]></title>
    <url>%2Fvscode%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87.html</url>
    <content type="text"><![CDATA[vscode快捷键提升效率windows： cmd = ctrl, option = alt 重开一行 不在行尾向下： cmd + enter 不在行尾向上： shift + cmd + enter 删除一行 cmd + x shift + cmd + k 移动换位 option + ↑ option + ↓ 复制一行 shift + option + ↑ shift + option + ↓ 选一个词 cmd + d 搜索 cmd + f cmd + option + f 替换 cmd + shift + f 项目中替换]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微微学习Docker]]></title>
    <url>%2F%E5%BE%AE%E5%BE%AE%E5%AD%A6%E4%B9%A0%20Docker.html</url>
    <content type="text"><![CDATA[微微学习 Docker1234567891011121314跑镜像docker run -it imageName bash创建一个容器，但不启动docker create改镜像名docker tag ca1b6b825289 registry.cn-hangzhou.aliyuncs.com/xxxxxxx:v1.0commit容器docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]none就随便删呗docker image prune Docker file FROM 拉镜像 MAINTAINER 指定创建镜像的用户 RUN 在当前镜像基础上执行指定命令，并提交为新的镜像 CMD 启动容器时提供一个默认的命令执行选项 EXPOSE 告诉 Docker 服务端容器对外映射的本地端口，需要在 docker run 的时候使用-p或者-P选项生效。 ENV 指定一个环节变量，会被后续RUN指令使用，并在容器运行时保留 ADD 复制本地主机文件、目录或者远程文件 URLS 从 并且添加到容器指定路径中 COPY 复制新文件或者目录从 并且添加到容器指定路径中 。用法同ADD，唯一的不同是不能指定远程文件 URLS ENTRYPOINT 配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖，而CMD是可以被覆盖的。 VOLUME 创建一个可以从本地主机或其他容器挂载的挂载点 USER 指定运行容器时的用户名或 UID，后续的操作也会使用指定用户 WORKDIR 为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。 ONBUILD 配置当所创建的镜像作为其它新创建镜像的基础镜像时]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置阿里云服务器之Docker服务]]></title>
    <url>%2F%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8BDocker%E6%9C%8D%E5%8A%A1.html</url>
    <content type="text"><![CDATA[配置阿里云服务器之Docker服务阿里云搜索容器镜像服务。网址地址 具体操作看别人的博文:博文地址下面讲一点使用docker注意事项和上传至阿里云 保存容器我们进到容器里一顿apt update &amp;&amp; apt install 巴拉巴拉但是只要exit一pull就发现所有做的都没了。原来我是没commit命令如下：docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] OPTIONS: –author , -a 作者 –change , -c 将Docker file指令应用于创建的映像 –message , -m 提交信息 –pause , -p 在提交期间暂停容器因为我得是私有镜像仓库可能会有以下情况：如果出现这种情况那么我们可以直接pull该镜像即可]]></content>
      <categories>
        <category>阿里云服务的使用、docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typescript配置采坑之路]]></title>
    <url>%2FTypescript%E9%85%8D%E7%BD%AE%E9%87%87%E5%9D%91%E4%B9%8B%E8%B7%AF.html</url>
    <content type="text"><![CDATA[这是没有@typesc/node导致的。但是安装最新的10.0.0也不行。我就安装了@types/node@8 tsconfig文件加这条： “module”: “commonjs”, tsconfig文件加这条： “lib”: [“es2015”]]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack4配置指南！Up！]]></title>
    <url>%2FWebpack4%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[first1234567mkdir simpleFE &amp;&amp; cd simpleFEnpm init -ynpm install webpack webpack-cli --save-devormkdir simpleFE &amp;&amp; cd simpleFEyarn init -yyarn add webpack webpack-cli -D 不要问为什么装了webpack 还要装webpack-cli。。因为你不装就报错。。官方提示还让你去装。。 配置Sass12345npm install css-loader node-sass sass-loader style-loader --save-devoryarn add css-loader node-sass sass-loader style-loader -D 配置文件： 123456789101112131415161718192021222324252627282930313233// 提取css文件成单独的文件const extractSass = new ExtractTextPlugin(&#123; filename: "styles/[name].[hash].css", disable: process.env.NODE_ENV === "development"&#125;);module: &#123; rules: [ &#123; test: /\.scss$/, use: extractSass.extract(&#123; use: [ &#123; loader: "css-loader", // 将CSS翻译成CommonJS options: &#123; sourceMap: true // 会导致速度变慢 &#125; &#125;, &#123; loader: "sass-loader", // 将Sass编译成CSS options: &#123; sourceMap: true // 会导致速度变慢 &#125; &#125; ], // 在dev环境下配置这条 fallback: "style-loader" &#125;) &#125; ] &#125;, plugins: [extractSass] 安装extract-text-webpack-plugin这是为了把css呀这些文件单独打包成一个 但是会遇到报错： 然后我们去package.json会发现他的版本才3.0.2。。那么升级下吧因为我们webpack都4.6了。。 yarn add extract-text-webpack-plugin@next -D CommonsChunkPluginCommonsChunkPlugin已被移除。。被 SplitChunksPlugin 和 runtimeChunk 替代了。 CommonsChunkPlugin存在很多问题： 它可能导致更多的代码被下载 它在异步块上效率低下。 很难用 实施难以理解 SplitChunksPlugin很棒的地方： 它对异步块也有效 它在默认情况下用于异步块 它处理vendor并拆分多个verdor块 它更容易使用 它不依赖chunk块 大部分是自动的 我们只要把原有的new webpack.optimize.CommonsChunkPlugin(options)删了。加上 1234567891011121314151617181920splitChunks: &#123; chunks: "async", minSize: 30000, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\/]node_modules[\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125;&#125;]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件处理]]></title>
    <url>%2F%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[事件简要分析： 事件类型 “load”..etc.. 事件目标 各种load、load事件 事件处理程序 事件对象 事件传播 注册事件 addEventListener() IE9 之前: attachEvent() 按照约定，事件处理程序属性的名字由”on”后面跟着时间名组成：onclick、onchange、onload、onmouseover.并且所有都是小写。 但是在 addEventListener() 中第一个参数却是不用带on的，attachEvent() 却要加的。 Demo 事件调用顺序 通过设置对象属性或者HTML属性注册的处理程序一直优先调用 使用addEventListener() 注册的处理程序按照它们的注册顺序调用 使用 attachEvent() 注册的处理程序可能按照任何顺序调用，所以代码不应该依赖于调用顺序]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contenteditable与变成输入普通文本]]></title>
    <url>%2Fcontenteditable.html</url>
    <content type="text"><![CDATA[我们需要实现富文本的方法有一个很方便那就是在任意元素你都可以给个属性叫contenteditable 1&lt;div contenteditable&gt;我是个富文本哟！&lt;/div&gt; 很简单这就是一个富文本啦！ 经过百度一番，看见张鑫旭大神的很久以前的文章。为了实现普通输入文本我们只能借助css啦！ user-modify user-modify: read-only; 只能看 user-modify: read-write; 支持富文本 user-modify: write-only; 无所谓的东西 user-modify: read-write-plaintext-only; 纯文本 OK~~问题解决啦。那就是只要给那个元素设个css 123&lt;div contenteditable style="user-modify:read-write-plaintext-only"&gt; 我是纯文本&lt;/div&gt; 参考： 张鑫旭大神博客]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂模式js和ts实现]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[简单工厂简单来说就是：由一个对象决定创建某一种产品对象类的实例。 Js: 12345678910111213141516171819function Book(name, price, type)&#123; let a = new Object(); a.name = name; a.price = price; a.type = type; a.getName = function() &#123; console.log(this.name); &#125; a.getPrice = function() &#123; console.log(this.price); &#125; a.getType = function() &#123; console.log(this.type) &#125; return a;&#125;var b = Book("Js", 14, "语言书籍");b.getName(); Ts: 1234567891011121314151617181920212223242526272829303132333435363738394041enum BookType&#123; Js, Ts,&#125;interface BookAction&#123; read();&#125;abstract class Book implements BookAction&#123; // 抽象产品 - 书 abstract read();&#125;class JSbook extends Book&#123; //具体产品 - Jsbook read()&#123; console.log('js book.'); &#125;&#125;class Tsbook extends Book&#123; //具体产品 - Tsbook read()&#123; console.log('ts book.'); &#125;&#125;class BookFactory&#123; static createBook(type: BookType): Book&#123; switch(type)&#123; case BookType.Js: return new JSbook(); case BookType.Ts: return new Tsbook(); default: throw Error('not support book'); &#125; &#125;&#125;BookFactory.createBook(BookType.Js).read();BookFactory.createBook(BookType.Ts).read(); 工厂方法模式通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。 JS: 123456789101112131415var Factory = function(type, content)&#123; var s = new Factory(type, content) return s;&#125;Factory.prototype = &#123; Book: function(content)&#123; console.log(this.content) &#125;, Note: function(content)&#123; console.log(this.content) &#125;&#125;Factory('Book', 'Hello, i\'m a book');]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React新生命周期]]></title>
    <url>%2FReact%E6%96%B0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
    <content type="text"><![CDATA[React16.3.1React发生了重大的变化。并且更新了新的生命周期我们来了解一下。 献上一个图！ 地址：React新生命周期图 生命周期Mounting/挂载 constructor() static getDerivedStateFromProps() UNSAFE_componentWillMount() render() componentDidMount() Updating/更新 UNSAFE_componentWillReceiveProps() static getDerivedStateFromProps() shouldComponentUpdate(prevProps, prevState) UNSAFE_componentWillUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate(prevProps, prevState, snapshot) Unmounting/卸载 componentWillUnmount() Demo-getDerivedStateFromProps&amp;&amp;componentDidUpdate:链接： 小demo，了解一下 componentDidUpdate是个做网络请求的好地方。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React from "react";import &#123; render &#125; from "react-dom";const App = () =&gt; ( &lt;div style=&#123;styles&#125;&gt; &lt;Hello name="CodeSandbox" /&gt; &lt;h2&gt;Start editing to see some magic happen &#123;"\u2728"&#125;&lt;/h2&gt; &lt;B /&gt; &lt;/div&gt;);class B extends React.Component &#123; state = &#123; myParentValue: "" &#125;; componentDidMount() &#123; setTimeout(() =&gt; &#123; this.setState(&#123; myParentValue: "XuZiHao" &#125;); &#125;, 1000); &#125; render() &#123; return &lt;C foo=&#123;this.state.myParentValue&#125; /&gt;; &#125;&#125;class C extends React.Component &#123; state = &#123; foo: "" &#125;; static getDerivedStateFromProps(nextProps, prevState) &#123; if (nextProps.foo === "XuZiHao") &#123; return &#123; foo: "bar" &#125;; &#125; return null; &#125; componentDidUpdate() &#123; if (this.state.foo === "bar") &#123; setTimeout(() =&gt; &#123; this.setState(&#123; foo: "Hello!!!!" &#125;); &#125;, 4000); &#125; &#125; render() &#123; return &lt;h1&gt;Value of `foo` is &#123;this.state.foo&#125;&lt;/h1&gt;; &#125;&#125;render(&lt;App /&gt;, document.getElementById("root")); Demo-shouldComponentUpdate(prevProps, prevState)1234567891011121314151617181920212223242526272829import React from 'react'class Test extends React.Component&#123; constructor(props) &#123; super(props); this.state = &#123; Number:1 &#125; &#125; //这里调用了setState但是并没有改变setState中的值 handleClick = () =&gt; &#123; const preNumber = this.state.Number this.setState(&#123; Number:this.state.Number &#125;) &#125; //在render函数调用前判断：如果前后state中Number不变，通过return false阻止render调用 shouldComponentUpdate(nextProps,nextState)&#123; if(nextState.Number == this.state.Number)&#123; return false &#125; &#125; render()&#123; //当render函数被调用时，打印当前的Number console.log(this.state.Number) return(&lt;h1 onClick = &#123;this.handleClick&#125; style =&#123;&#123;margin:30&#125;&#125;&gt; &#123;this.state.Number&#125; &lt;/h1&gt;) &#125;&#125; Demo-getSnapshotBeforeUpdate()官方例子： 官网地址 123456789101112131415161718192021222324252627class ScrollingList extends React.Component &#123; listRef = React.createRef(); getSnapshotBeforeUpdate(prevProps, prevState) &#123; // 是否将新项目添加到列表中？ // 捕获列表的当前高度，以便稍后调整滚动。 if (prevProps.list.length &lt; this.props.list.length) &#123; return this.listRef.current.scrollHeight; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // 如果我们有快照值，我们刚刚添加了新items // 调整滚动条，以便这些新items不会将旧的推出视图。 if (snapshot !== null) &#123; this.listRef.current.scrollTop += this.listRef.current.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt; ); &#125;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp正则表达式]]></title>
    <url>%2FRegExp.html</url>
    <content type="text"><![CDATA[仨标志 g 全局查 i 忽略大小写 m 多行查 123var a = /a/g;var b = /at/i;var c = /.at/gi;]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《高性能JavaScript》读书笔记]]></title>
    <url>%2F%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[First&lt;script&gt;方面的我写了一篇博文链接地址：浅谈script标签 Second数据存储： 把数据存在访问字面量和局部变量是然后去访问速度最快的。 全局变量总是在作用域的最末端所以访问速度也是最慢的。 对象的深度嵌套拿值会影响性能。 例子： 123456789101112131415//beforefunction b()&#123; var getId = document.getElementById("id"); var getClass = documnent.getElementsByClassName("class"); getId.style.width......&#125; //after function a()&#123; var doc = document; var getId = doc.getElementById("id"); var getClass = doc.getElementsByClassName("class"); .... &#125;]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局]]></title>
    <url>%2FCSS%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[两栏——左固定右自适应布局方法一12345678910111213141516&lt;div class="left"&gt;&lt;/div&gt;&lt;div class="right"&gt;&lt;/div&gt;// css .left &#123; width: 40px; height: 200px; background: red; float: left&#125;.right &#123; height: 200px; margin-left: 40px; background: blue;&#125; Demo 方法二123456789101112131415&lt;div class="left"&gt;&lt;/div&gt;&lt;div class="right"&gt;&lt;/div&gt;//css.left &#123; position: absolute; height: 200px; width: 40px; background: red;&#125;.right &#123; height: 200px; margin-left: 40px; background: blue;&#125; Demo]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Saga笔记]]></title>
    <url>%2FReduxSaga.html</url>
    <content type="text"><![CDATA[监听takeEvery:123function* watchFetchData() &#123; yield* takeEvery('FETCH_REQUESTED', fetchData)&#125; 允许多个fetchData同时进行，即使上一个还没执行完成。 takeLatest：123function* watchFetchData() &#123; yield* takeLatest('FETCH_REQUESTED', fetchData)&#125; 始终执行最新的那个请求的响应。 总结一下就是： 我们疯狂点击一个按钮，它触发也疯狂触发了多次fetchData。 如果我们是takeEvery那将你点击几次他执行几次fetchData。 如果我们是takeLatest那将只执行你最后点击的那一次fetchData。 ##Effect 从 Generator 里 yield 纯 JavaScript 对象以表达 Saga 逻辑。 我们称呼那些对象为 Effect。 可以使用 redux-saga/effects 包里提供的函数来创建 Effect。 call：call(fn, ...args) 这个函数。现在我们不立即执行异步调用，相反，call 创建了一条描述结果的信息 简单来说，call就是redux里的Action Creator。 ###put： 这个函数用于创建 dispatch Effect。 1234567891011121314//beforefunction* fetchProducts(dispatch) const products = yield call(Api.fetch, '/products') dispatch(&#123; type: 'PRODUCTS_RECEIVED', products &#125;)&#125;//afterimport &#123; call, put &#125; from 'redux-saga/effects';function* fetchProducts() &#123; const products = yield call(Api.fetch, '/products') // 创建并 yield 一个 dispatch Effect yield put(&#123; type: 'PRODUCTS_RECEIVED', products &#125;)&#125; take：它将会暂停 Generator 直到一个匹配的 action 被发起。 12345678function* loginFlow() &#123; while(true) &#123; yield take('LOGIN') // ... perform the login logic yield take('LOGOUT') // ... perform the logout logic &#125;&#125; 也就是说我们可以用take去监听还未发生的事情。比如我们Login之后必定跟着一个Logout，或者说我们Logout后面必定跟着一个Login。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative热更新之微软CodePush]]></title>
    <url>%2FReactNativeCodePush.html</url>
    <content type="text"><![CDATA[微软 CodePush 使用安装yarn global add code-push-cli 注册账户code-push register 会弹出一个浏览器,让你注册,可以使用 github 帐号对其进行授权,授权成功会给一串 Token,点击复制，在控制进行粘贴回车(或者使用 code-push login 命令)。 CodePush 登录相关命令 code-push login 登陆 code-push logout 注销 code-push access-key ls 列出登陆的 token code-push access-key rm 删除某个 access-key CodePush 创建 App 相关命令 code-push app add 如: code-push app add yimutest-ios ios/android react-native code-push app add 在账号里面添加一个新的 app code-push app remove rm 在账号里移除一个 app code-push app rename 重命名一个存在 app code-push app list ls 列出账号下面的所有 app code-push app transfer 把 app 的所有权转移到另外一个账号 在项目中  加包 yarn add react-native-code-push react-native link 之后会让你将刚才添加的 ios/Android App 的 Staging Key 复制粘贴到这里 Staging 为测试的 key，Production 为生产打包时用的 key。 如果忘了  则在终端下做查看: code-push deployment ls 您的应用名 -k App.js123456789101112import codePush from "react-native-code-push";const codePushOptions = &#123; checkFrequency: codePush.CheckFrequency.MANUAL &#125;;componentDidMount()&#123; codePush.sync(&#123; updateDialog: true, installMode: codePush.InstallMode.IMMEDIATE, mandatoryInstallMode:codePush.InstallMode.IMMEDIATE, //deploymentKey为刚才生成的,打包哪个平台的App就使用哪个Key,这里用IOS的打包测试 deploymentKey: 'xxxxxxx', &#125;);&#125; 附上其他的详细 API: 详细配置 发布新版本 code-push release &lt;应用名称&gt; &lt;Bundles所在目录&gt; &lt;对应的应用版本&gt; --deploymentName： 更新环境 --description： 更新描述 --mandatory： 是否强制更新 code-push release codepush01 ./bundles/ 1.0.0 --deploymentName Production --description &quot;我也不知道要写啥&quot; --mandatory false code-push app add aaa-ios ios react-native yarn start-ios Android 新版本发布修改 App.js 的 deploymentKey 为安卓的 deploymentKey:&#39;android key&#39; code-push release-react aaa-android android yarn start-android]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac通过ssh连接ecs]]></title>
    <url>%2Fmac%E8%BF%9E%E6%8E%A5ssh.html</url>
    <content type="text"><![CDATA[通过学生优惠买了半年的阿里云服务器ecs！好便宜啊。。想想马上就毕业了，甚至有点小可惜不能时间长点享受优惠。。 那不说多的直接进入正题。 起初通过阿里云控制台进行远程控制自己买的云服务器。。总是感觉在网页端操作终端有点变扭，就准备用tmux直接通过ssh连接我自己的云服务器。 它居然说！！！ Timed out!! 这是Why！！ 之后帮助中心走了一遭，发现原来我是安全组没配置。。 然后我们点击安全组配置。 之后进入重点！ 我们在出和入都配置一样的设置。 然后我们就可以愉快的去终端里通过ssh连接我们的云服务器啦~]]></content>
      <categories>
        <category>阿里云服务的使用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源与跨域资源共享]]></title>
    <url>%2F%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB.html</url>
    <content type="text"><![CDATA[说到跨域，我们需要先说说什么是同源策略。 同源策略浏览器安全的基石是”同源政策”（same-origin policy）。 也就是说要满足以下条件： 协议相同 域名相同 端口相同 也就是说，如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 如果非同源，共有三种行为受到限制： Cookie、LocalStorage 和 IndexDB 无法读取。 DOM 无法获得。 AJAX 请求不能发送。 同源策略是对XMLHTTPRequest的一种约束。所以有时候我们想要去获取别的消息，我们需要跨过同源策略。 但是有些的跨域请求是被允许的比如： &lt;script&gt;标签 &lt;link&gt;标签 &lt;img&gt;标签 &lt;a&gt;标签 &lt;video&gt;和 &lt;audio&gt;嵌入多媒体资源。 &lt;iframe&gt;与&lt;frame&gt; CORS跨域资源共享那么为了解决这个问题，CORS横空出世！ IE8可以通过XDomainRequest对象支持CORS。 其他浏览器我们都可以通过XMLHttpRequest对象支持CORS。 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。 其实CORS背后的思想就是，使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 CORS分简单请求和非简单请求，满足以下条件就为简单请求： 简单请求 HTTP 响应首部字段Access-Control-Allow-Origin根据Reuqest请求头中的Origin来判断该请求的资源是否可以被共享。 Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。 Access-Control-Expose-Headers让服务器把允许浏览器访问的头放入白名单 在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头 Access-Control-Allow-Credentials指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容。 所以我们需要附带身份凭证的请求: 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 我们不这样去做处理的话，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 HTTP请求首部字段用于发起跨域请求的首部字段，其实这些字段都不用我们去手动设置。当我们使用 XMLHttpRequest 对象发起跨域请求时，它们已经被设置就绪。 Origin Access-Control-Request-Method Access-Control-Request-Headers 参考MDN-HTTP请求首部字段]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax与Fetch？]]></title>
    <url>%2FAjax%E4%B8%8EFetch.html</url>
    <content type="text"><![CDATA[虽说现有Fetch和Axios，但我们还是需要了解下当初那传奇的Ajax！ AjaxAjax是基于XMLHttpRequest对象来请求数据的。所以我们需要先了解下XMLHttpRequest对象。当我们发起一个请求时： 1234567function reqListener () &#123; console.log(this.responseText);&#125;let xhr = new XMLHttpRequest();xhr.onload = reqListener;xhr.open("get", "yourfile.txt", false)xhr.send(); 那么逐条解释， XMLHttpRequest简称XHR。 在XHR的属性有responseText，也就是代码第2行中，它是作为响应主体被返回的文本，而且无论内容类型是什么，它们都会保存在该属性中。 第4行代码，构造函数XMLHttpRequest初始化了一个XMLHttpRequest对象。 第5行代码，看以下图： 我们会发现onload是XMLHttpRequestEventTarget的事件处理程序的接口。 XMLHttpRequestEventTarget.onabort 当请求失败时调用该方法 XMLHttpRequestEventTarget.onerror 当请求发生错误时调用该方法 XMLHttpRequestEventTarget.onload 当一个HTTP请求正确加载出内容后返回时调用。 XMLHttpRequestEventTarget.onloadstart 当一个HTTP请求开始加载数据时调用。 XMLHttpRequestEventTarget.onprogress 间歇调用该方法用来获取请求过程中的信息。 XMLHttpRequestEventTarget.ontimeout 当时间超时时调用；只有通过设置XMLHttpRequest对象的timeout属性来发生超时时，这种情况才会发生。 XMLHttpRequestEventTarget.onloadend 当内容加载完成，不管失败与否，都会调用该方法 参考资料MDN 第6行就都是XMLHttpRequest对象的方法。 open(method, url, async, user, password) 请求使用Http的方法，如method = ‘GET’ | ‘POST’ | ‘PUT’ | ‘DELET’ url就是url async： boolean。是否异步操作。如果为false只有你得到服务器返回的数据send()方法才会返回数据。如果为值为true，一个对开发者透明的通知会发送到相关的事件监听者。 user，password: 可选参数,为授权使用 另外在我们接收到响应之前还可以调用abort()方法来取消异步请求。 当然XMLHttpRequest对象也有一些重要的属性而且这个对象也继承了EvenTarget和XMLHttpRequestEvenTarget的属性（如上图所示）。 最重要的是当readyState属性的值由一个值变为另一个值得时候，都会触发一次readystatechange事件。 那么readyState有哪些值呢？ 0，未初始化。还没调用open()方法 1，启动。已经调用了open()方法 2，发送。已经调用了send()方法 3，接受。已经接收到部分响应数据 4，完成。已经接收到全部的响应数据，而且已经可以再客户端使用了。 我们一般对值为4这个阶段感兴趣。因为这时候所有的数据已经到位了，我们就可以做许多事情了。比如说： 123456let xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; balbalbal...... &#125;&#125; 还有response，responseText，responseType，responseXML，status，statusText，statusText，withCredentials属性。 FetchFetch是什么？Fetch 是浏览器提供的原生 AJAX 接口。使用 window.fetch 函数可以代替以前的 $.ajax、$.get 和 $.post。 Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如 CORS和HTTP的扩展。 请注意，fetch 规范与 jQuery.ajax() 主要有两种方式的不同，牢记： 当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ）， 仅当网络故障时或请求被阻止时，才会标记为 reject。 默认情况下, fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）. 参考资料MDN 例子12345fetch('/').then(function(response)&#123; response.text().then(function(text)&#123; console.log(text) &#125;)&#125;) 这是个很简单的Fetch的小例子。 .then…这不是和Promise好像吗？ 没错。Fetch API就是基于Promise的。但是因为基于Promise所以我们无法像XHR一样调用.abort()去中断请求。。 自定义请求的参数那么，Fetch第二个参数我们可以传一个可以控制不同配置的 init 对象： 1234var myInit = &#123; method: 'GET'|'POST'|'PUT'|'DELETE', headers: myHeaders, mode: 'cors', cache: 'default' &#125;; mode: 请求的模式，如 cors、 no-cors 或者 same-origin。 cache: 请求的 cache 模式: default、 no-store 、 reload 、 no-cache 、 force-cache或者 only-if-cached 。 其他可以去参考MDN。 header在Fetch下可以很方便的操作header： 123fetch(url).then(function(responen)&#123; console.log(responen.headers.get('Content-Type'));&#125;) 12345var myHeaders = new Header();myHeaders.append("Content-Type", "text/html");fetch(url).then(function()&#123; headers: myHeaders&#125;) 12345var header = new Headers(&#123; "Content-Type": "text/plain"&#125;);console.log(header.has("Content-Type")); //trueconsole.log(header.has("Content-Length")); //false]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈script标签]]></title>
    <url>%2F%E6%B5%85%E8%B0%88script%E6%A0%87%E7%AD%BE.html</url>
    <content type="text"><![CDATA[&lt;script&gt; ? 这不就是直接执行script脚本吗？ 以前的我这有认为，但是今天却知道了他的奥秘。他并没有表面的那么简单。 属性&lt;script&gt;拥有7个属性，没想到吧！ async boolean 异步执行该脚本，但不保证按照指定它们的先后顺序执行 defer boolean 通知浏览器该脚本将在文档完成解析后遇到&lt;/html&gt;，并会按照它们出现的先后顺序执行。但会在触发 DOMContentLoaded 事件前执行。 integrity 包含用户代理可用于验证已提取资源是否已无意外操作的内联元数据 src type text crossorigin 使那些将静态资源放在另外一个域名的站点打印错误信息,就是将跨域报错变为同源报错 在XHTML文档中，要把async属性设置为 async = “async”, defer = “defer” 知道了那几个属性接下来，来看看下面这个图： 第一个光秃秃的&lt;script&gt;说明了，在html解析中，如果有&lt;script&gt;的话，html会在Script下载并且执行的时候，暂停解析。 第二个带async属性的&lt;script&gt;，如图所示，也就是他下载Script的时候是异步的，但是只要Script文件下好了，那么就马上执行。 第三个带defer属性的&lt;script&gt;，其实和上面带async属性一样都是异步执行去下载Script文件的。但是在这个带有defer的则是在html全部解析完毕之后才去执行Script文件。而且它是按照加载顺序执行脚本的，这一点要善加利用。显然 defer 是最接近我们对于应用脚本加载和执行的要求的 使用动态创建的&lt;script&gt;标签元素来下载并执行代码1234var script = document.createElement('script');script.type = "text/javascript";script.src = "file1.js";document.getElementByTagName("head")[0].appendChild(script); 这个技术的重点在于： 无论何时启动下载，文件的下载和执行过程不会阻塞页面其他进程。 参考： 《高性能JavaScript》 使用XHR对象下载JS代码注入页面123456789101112131415161718192021function loadScript(url, callback)&#123; var script = document.createElement("e"); script.type = "text/javascript"; if(script.readyState)&#123; //ie script.onreadystatechange = function()&#123; if(script.readyState == "loaded" || script.readyState == "complete")&#123; script.onreadystatechage = null; callback(); &#125; &#125;; &#125; else &#123; script.onload = function()&#123; callback(); &#125; &#125;&#125;loadScript("the-rest.js", function()&#123; Application.init()&#125;); 这样做实现了动态创建标签元素并下载，其次当第二个脚本文件下载时，应用所需的所有DOM结构已经创建完毕，并做好了交互的准备,从而避免了需要另一个事件来检测页面是否准备好。 参考 MDN SegmentFault]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3外轮廓]]></title>
    <url>%2FCSS%E5%A4%96%E8%BD%AE%E5%BB%93.html</url>
    <content type="text"><![CDATA[Outline看一个Outline的例子：outline 在下面看见一个div也有类似的效果。但是我们打开开发者工具看会发现。下面用outline实现的外边框中border为-。 outline和border对比 border属于盒模型的一部分，会直接影响盒子大小。 outline则是将边框画在盒子上，不会影响该框。所以它不会破坏网页布局。 border创建是可以显示单边的，而outline是不行的。看demo：单边 border只可以外轮廓，而outline可以借助outline-offset设成负值就可以实现内轮廓，而设成正值就是外轮廓。看demo：内轮廓]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie、Session]]></title>
    <url>%2FCookie-Session.html</url>
    <content type="text"><![CDATA[Cookie中文名称为“小型文本文件”或“小甜饼”，总大小要小于4kb，并且尽量保证cookie的个数小于20个。 摘自维基百科 按存在时间所分，可以分为非持久Cookie和持久Cookie。那么非持久Cookie是保存在内存中，即你关闭浏览器就会消失。而非持久Cookie保存在硬盘中，只有你去清理或者Cookie到了过期时间该Cookie才会消失。 为什么要有Cookie？因为HTTP协议是无状态的。也就是说，服务器并不知道你上次做了什么操作。所以我们需要一个帮手去记录我们刚刚都在网页上做了什么操作，所以Cookie就诞生了。也就是说服务器会给客户端发送一段cookie. LocalStorage和SessionStorage都是本地存储，不会被发送到服务器上。同时空间比Cookie大很多，一般支持5-10M。 与Cookie类似，每个域名下会有不同的localStorage和SessionStorage实例，而且localStorage可以在多个标签页中互相访问。 其中LocalStorage没有过期时间，除非手动删除它会一直存在。而SessionStorage在浏览器会话结束时（关闭标签页，不包括刷新和跳转）清空。 Session它其实是一个抽象的概念。它本质上是借助cookie本身和后端存储实现的。 Cookie和Session的关系这里我做了一个图]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3transform/transition]]></title>
    <url>%2FCSS3transform.html</url>
    <content type="text"><![CDATA[CSS3 transform先来了解下单位： 度（deg）。一个圆360度 Transform就指变换。 transform: 矩阵 (matrix) 用六个指定的值来指定一个均匀的二维（2D）变换矩阵 转换（translate） 旋转（rotate） 缩放（scale） 倾斜（skew） 但是还可以这样玩 scaleX, scaleY skewX, skewY translateX, translateY matrix3d matrix(a, b, c, d, tx, ty) 是 matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1) 的简写 transform-origin 以一个点去变形 transform-style 确定元素的子元素是否位于3D空间中，还是在该元素所在的平面内被扁平化。 CSS transitiontransition = &lt;transition-property&gt; | &lt;transition-duration&gt; | &lt;transition-delay&gt; | &lt;transition-timing-function&gt; Transition-property: 指定过渡的属性值。 Transition-duration: 指定这个过渡的持续时间 Transition-delay: 延迟过渡时间 Transition-timing-function: 指定过渡动画运行类型； ease 越来越慢 linear 匀速 ease-in 先慢后快 ease-out 先快后慢 ease-in-out 先慢后快再慢 cubic-bezier() 先来看一个transform和transition结合的demo：字体歪斜变正]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法学习]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[二分查找1234567891011121314151617function binary_search(array, item)&#123; let low = 0; let high = array.length - 1; while(low &lt;= high)&#123; let mid = (low + high) / 2 &gt;&gt; 0; let guess = array[mid]; if(guess == item)&#123; return mid; &#125; if(guess &gt; item)&#123; high = mid - 1; &#125; else &#123; low = mid + 1; &#125; return '没有该数字' &#125;&#125; 排序选择排序12345678910111213function choicesort(arr)&#123; let len = arr.length, min, temp; for(let i = 0; i &lt; len; i++)&#123; min = i; for(let j = i + 1; j &lt; len; j++)&#123; if(arr[j] &lt; arr[min]) min = j; temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; &#125; return arr&#125; 快排12345678910111213141516171819/** * * @param &#123;array&#125; 传入一个需要排序的数组 */function quicksort(arr)&#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let pivotIndex = arr.length / 2 &gt;&gt; 0; let pivot = arr.splice(pivotIndex, 1)[0]; let left = []; let right = []; for(let i = 0; i &lt; arr.length; i++)&#123; if(arr[i]&lt;pivot)&#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quicksort(left).concat([pivot], quicksort(right));&#125; 散列表 模拟映射关系； 防止重复； 缓存/ 记住数据，以免服务器再通过处理来生成它们。 一旦填装因子超过0.7 ，就该调整散列表的长度。 狄克斯特拉算法狄克斯特拉算法包含4个步骤。 找出最便宜的节点，即可在最短时间内前往的节点。 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。 重复这个过程，直到对图中的每个节点都这样做了。 计算最终路径。 ​​]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3选择器]]></title>
    <url>%2FCss3%E9%80%89%E6%8B%A9%E5%99%A8.html</url>
    <content type="text"><![CDATA[Css3选择器在写css最基本的就是如何去选择节点去改变样式了。特地做了个思维导图把现有的选择器都做成了个思维导图，有不足的地方大家来提意见！]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prettier Option]]></title>
    <url>%2FPrettier-Options.html</url>
    <content type="text"><![CDATA[Prettier Option.Prettierrc Cli是在终端使用， Api是在.Prettierrc中设置使用 printWidth打印宽度指定打印将换行的行长。 Default Cli Override Api Override 80 –print-width printWidth: Tab Width指定每个缩进的空格数。 Default Cli Override Api Override 2 –tab-width tabWidth: Tabs用Tab缩进而不是空格 Default Cli Override Api Override false –use-tabs useTabs: Semicolons在语句的末尾打印分号。 有效的选项： true - 在每个语句的末尾添加一个分号。 false - 只在可能引入ASI故障的行的开头添加分号。 Default Cli Override Api Override true –no-semi semi: Quotes使用单引号而不是双引号。 Default Cli Override Api Override false –single-quote singleQuote: Trailing Commas多行时，尽可能打印尾随逗号。 （例如，一个单行数组永远不会得到尾随的逗号。） 有效选项： none - 没有尾随逗号。 es5 - 在ES5中有效的尾随逗号（object，arrays等） all - 尽可能尾随逗号（包括函数参数）。 Default Cli Override Api Override None –trailing-comma &lt;none\ es5\ all&gt; trailingComma: “&lt;none\ es5\ all&gt;” Bracket Spacing在对象文字中的括号之间打印空格。 选项： true - Example { foo: bar } flase - Example {foo: bar} Default Cli Override Api Override true –no-bracket-spacing bracketSpacing: JSX Brackets将多行JSX元素的 &gt; 放在最后一行的末尾，而不是单独放在下一行（不适用于自闭元素）。 Default Cli Override Api Override false –jsx-bracket-same-line jsxBracketSameLine: Arrow Function Parentheses围绕一个唯一的箭头函数参数包括括号。 选项： avoid - 尽可能省略括号 Example： x =&gt; x always - 总是包括括号 Example： (x) =&gt; x Default Cli Override Api Override avoid –arrow-parens &lt;avoid\ always&gt; arrowParens: “&lt;avoid\ always&gt;” Range只格式化文件的一部分。 这两个选项可用于格式化以给定字符偏移（分别包含和排除）开始和结束的代码。范围将延伸: 返回到包含选定语句的第一行的开头。 转到选定语句的末尾。 这些选项不能与cursorOffset一起使用。 Default Cli Override Api Override 0 –range-start rangeStart: Infinity –range-end rangeEnd: Parser指定使用哪个分析器。 Babylon和流解析器都支持相同的JavaScript特性（包括Flow）。Prettier会自动从输入文件路径中推断解析器，所以你不需要改变这个设置。 Built-in parsers: babylon flow typescript Since v1.4.0 postcss Since v1.4.0 json Since v1.5.0 graphql Since v1.5.0 markdown Since v1.8.0 Default Cli Override Api Override babylon –parser –parser ./my-parser parser: ““parser: require(“./my-parser”) FilePath指定输入文件路径。这将被用来做解析器推理。 例如，以下将使用postcss解析器： cat foo | prettier –stdin-filepath foo.css Default Cli Override Api Override None –stdin-filepath filepath: ““ Require pragmaPrettier可以限制自己只能格式化文件顶部包含特殊注释的文件，称为杂注。逐渐将大型，无格式的代码库转换为漂亮的代码库时，这非常有用。 例如，当提供–require-pragma时，将会格式化具有以下第一个注释的文件： 123/** * @prettier */ or 123/** * @format */ Default Cli Override Api Override false –require-pragma requirePragma: Insert PragmaPrettier的可以在文件的顶部插入一个特殊的@format标记，指定文件已被格式化为Prettier。 Default Cli Override Api Override false –insert-pragma insertPragma: Prose Wrap默认情况下，由于某些服务使用了对换行符敏感的呈现器，因此Prettier会按原样包装降价文本。 选项： &quot;always&quot; - 如果超出了打印宽度，请将散的包好。 &quot;never&quot; - 不包散的。 &quot;preserve&quot; - 按原样包散的。 Default Cli Override Api Override “preserve” –prose-wrap &lt;always\ never\ preserve&gt; proseWrap: “&lt;always\ never\ preserve&gt;”]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kaldi语音识别初用]]></title>
    <url>%2Fkaldi%E6%96%87%E6%A1%A3.html</url>
    <content type="text"><![CDATA[Kaldi启用INSTALL 在 tools/ 下跑 extras/check_dependencies.sh 然后跑make 之后在 src/ 下跑 ./configure –shared 在跑这句命令之前一定要先执行第一条 make depend make 细节 修改路径设置n = 4 在kaldi/egs 下跑 vi thchs30/s5/run.sh thchs=/home/xuzihao/kaldi/egs/thchs30/thchs30-openslr 然后修改/thchs30/s5/cmd.sh为本地跑： 12345export train_cms = run.plexport decode_cmd = run.plexport mkgraph_cmd = run.plexport cuda_cmd = run.pl​` 运行： cd到s5目录下去跑 sudo ./run.sh 静候佳音 识别自己的wav之后我们来到tools/下，去安装./install_portaudio.sh。 等安装完毕后我们到src/下，去 make ext去编译扩展程序。 找例子万事具备，然后我们到egs下，打开voxforge文件夹，去把里面online_demo文件夹直接拷到thchs30下，之后我们在online_demo里建2个文件夹,一个为online-data，一个为work。 之后我们在online-data下建两个文件夹分别为audio和models。audio下放你的wav文件，models建一个名为tri1的文件夹，之后我们把s5/exp/tri1下的final.mdl和35.mdl(这是final.mdl的快捷方式)拷到online-data/models/tri1下。 然后把s5/exp/tri/graph_word里面的words.txt和HCLG.fst文件(如果你没有这两文件，说明你还没把模型训练好)拷到online-data/models/tri1下。 运行例子我们在online_demo下vi run.sh。 之后我们把以下注释掉: ​12345678if [ ! -s $&#123;data_file&#125;.tar.bz2 ]; then echo "Downloading test models and data ..." wget -T 10 -t 3 $data_url; if [ ! -s $&#123;data_file&#125;.tar.bz2 ]; then echo "Download of $data_file has failed!" exit 1 fifi 然后在找到下面这句将其路径改成tri1: 1ac_model_type=tri1 然后把下面的也改了注意看online-wav-gmm-decode-faster就行了： 123online-wav-gmm-decode-faster --verbose=1 --rt-min=0.8 --rt-max=0.85\--max-active=4000 --beam=12.0 --acoustic-scale=0.0769 \scp:$decode_dir/input.scp $ac_model/final.mdl 运行然后我们直接在online_demo下./run.sh]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Native踩得坑持续更新]]></title>
    <url>%2FReact-Native%E8%B8%A9%E5%9D%91.html</url>
    <content type="text"><![CDATA[用nativebase遇到的fontFamily的问题 https://github.com/GeekyAnts/NativeBase-KitchenSink/blob/CRNA/App.js#L13 在RN中CSS、display不能为none ​ ​ {display: ‘none’} cause this bug Unrecognized Font Family on React Native react-native link react-native run-ios or react-native run-android]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初入Node]]></title>
    <url>%2F%E5%88%9D%E5%85%A5Node.html</url>
    <content type="text"><![CDATA[初入Node回调地狱Node的异步回调惯例： 12345var fs = require('fs');fs.readFile('/index.html', (err, data) =&gt; &#123; if(err) throw err; getSomething(data.toString(), res);&#125;) 在Node里大多数的内置模块在使用回调时都会带两个参数，第一个一般都用来放可能会发生的错误（err或error）;第二个是放结果。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON看这篇就行了]]></title>
    <url>%2FJSON.html</url>
    <content type="text"><![CDATA[JSON最近大量接触JSON 所以我特意去JSON标准(短短的8页，大家也可以看看)看了下，还参阅了许多资料，总结一下JSON 我们先来看一个JSON的组成： 123&#123; "propertyName": "propertyValue"&#125; property(属性/键值对) propertyName(属性名/键) propertyValue(属性值) JSON可以表示四种基本类型（string(字符串)、number(数字）、booleans(布尔值)、null（空））和两个结构化类型（Object(对象)、Arrarys（数组）） 书写逗号最后一个属性后不能有逗号 双引号在标准中都使用了双引号。因为所有的属性必须在双引号内。但是布尔值或者数字可以不用引号。 结构层次在设计JSON 的时候，我们都能看见可扩展和不可扩展的JSON结构。其中最主要的就2种，一种为扁平化数据，还有结构层次。 先讲讲我在知乎上看见的问题： 正常情况有一个JSON应为： 123456789101112[ &#123; "name": "Javascript权威指南"， "chapters:": 500, &#125;, &#123; "name": "Javascript高级程序设计", "chapters": 500, &#125;, &#123;...&#125;, &#123;...&#125;] 这样看是很完美，但是有些人会这样设计？ 12345678[ &#123; "Javascript权威指南"： 500 &#125;, &#123; "Javascript高级程序设计": 500 &#125;] 那么我们就可以看出2种设计的问题，第二种无法扩展有木有！！而且。。他们为啥要把数据内容带入属性名！！ ok！我们知道了一点，不要把数据内容带入属性名。 接下来扁平化数据： 12345678910&#123; "Image": &#123; "width": 800, "Height": 600, "Title": "View from 15th Floor", "ThumbnailUrl": "http://www.example.com/image/481989943", "ThumbnailHeight": 125, "ThumbnailWidth": 100 &#125;&#125; 结构层次： 123456789101112&#123; "Image": &#123; "Width": 800, "Height": 600, "Title": "View from 15th Floor", "Thumbnail": &#123; "Url": "http://www.example.com/image/481989943", "Height": 125, "Width": "100" &#125;, &#125;&#125; JSON中本应该以数据元素扁平化方式呈现。 但是结构层次对我们开发人员更加的友好有意义。 具体情况看自己的选择。 下面讲点细的属性名规范 属性名应该一看就知道啥用 属性名必须是驼峰，ASCII码字符串 首字符必须是字母，_ （下划线），$(美元符号) 避免使用js中的保留字 数组类型应该是复数，其他属性名都为单数 属性值规范 属性值应该为四种基本类型（string(字符串)、number(数字）、booleans(布尔值)、null（空））和两个结构化类型（Object(对象)、Arrarys（数组）） 其他的具体可以看我下面给出的参考资料链接 方法 JSON.parse() 解析一个JSON将他转换成JavaScript值或对象 JSON.stringify() 把一个对象或者值转换成JSON字符串 参考 JSON风格指南 JSON-MDN]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年自己的前端总结]]></title>
    <url>%2F2017%E5%B9%B4%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[2017年自己的前端总结​ 转眼从2017的1月1日那是即将进入大二下册的我，一直到现在实习的我，靠在沙发上静静的想想自己在暑假的实习以及这一年的进步速度堪称火箭🚀。 ​ 现在是2017年12月28日23：00，在这时刻我翻开了自己脑海中的技术树，对自己这一年中所成长的一点一滴做一个总结还有对即将到来的2018年，我需要去往哪方面发展或者完成一件什么事情？ ​ 整理了一下，看着很多，其实很多只是会用，还没到深入研究其原理！不过我很好奇为什么会这么做，然后会去看看源码。但是功力不够。。还需要继续修炼！ 书读万卷书，行万里路？ 在2017年，当我读书的时候，我觉得这句话可能要改一下： 读万卷书，思万/千万遍，写数次，行万里路。 ps:辣鸡文笔，请勿模仿，欢迎吐槽！ ​ 因为我大多数读的是技术书，文学类也有。不思考？光去看这些书没有任何用处，看了不懂继续看，看了就忘？为何不去把书上的东西都敲下来呢。 ​ 我突然发现这种学习方法虽然麻烦但是很有效果。而且一个个知识点虽然看着零散，但是我每次都在纸上把思维导图画出来，发现他们都是连通的。而且边思考边去把逻辑理清，真的事半功倍。 ps: 虽然。。有用但。。时间花的真的很多！！有些时候看十几页1个小时就过去了 T T！ 第一次写总结，就把我的书单全放上来吧： 这个书单可以到我的Github上面看。只要读完了我都会去更新状态还有最近看的书我都写了读书笔记。 项目​ 在2017年7月，我第一次去实习。在公司里发现了自己在学校或者自学永远看不到的技术。还有身边那么多厉害的人，他们懂的真的特别多。特别是冰哥（公司老大），几乎啥都知道，不懂得只要一伙儿就能信手拈来。 ​ 还记得他说的一句话：没有什么是现在不该学的，学任何东西不要有那么多条条框框的限制住自己，只要你想要知道，那么就该去做去“玩”。 所以我一点都不畏惧前端那么快的变化，而且我深知基础牢固的重要性。 ​ 第一个接触的项目就是公司后台，技术栈为React技术栈 + Mongodb + Graphql + Gulp + docker这些东西整合一起，我整整看了10天。。不过在那2个月内进步神速。学会了如何去谈需求/业务，如何去设计mongodb，如何去处理逻辑，如何去写日志（log），如何去看源码，如何去看文档，如何去用框架等等。。让我从一个无知的少年变成了小小的“全栈“程序员。 ​ 之后就是现在正在采坑的是React-Native + Expo。老大放手让我去采坑。。每天被坑的不要不要的，挣扎在一大堆一大堆的英文文档、还有源码、还有在Github上给Expo团队提Issue！还把语言改成了了TypeScript这个Js超集语言。有了类型真的很棒，和VSCode搭配写代码，食用更佳！😋 ​ 公司的微信小程序项目我没有参加（9月份回学校了！）。。不过。。我希望自己可以去学习小程序。毕竟今天出的小游戏可把我玩坏了！ ​ 哦对了还有自己的毕设。。也是React技术栈 + Mock.js（Easy Mock大搜车开源）做的自己的博客！ 2018展望​ 在2018，我觉得自己该学习的技术： Progressive Web AppsPWA就是Google希望用现代浏览器的技术来提供更像移动应用程序Web的体验！PWA 的基础是一个 manifest.json 文件和对 service workers 的利用。 为啥该学呢！因为。。最近Safari终于支持了Service Worker！ Serverless 架构Serverless是一种架构理念，指的是以服务的形式来提供计算能力而不是以服务器形式，让开发者在构建应用的过程中不用过多考虑基础设施的问题。 也就是说我们前端er可以安安心心的写app、做网页、做游戏？？ Node.js and Python会系统的（各种计算机基础以及数据库之类的）去学习Node.js，我相信这是门很强大的后端语言。 Python会去涉及。 CSS in JS这几天才试了试CSS in JS体验很棒，styled-component像写组件一样写css。很多特性功能还需要去学习。 Graphql在Github宣布v4版本，API都换成Graphql 我感觉会在REST之上占一席之地。因为我用过Graphql。真的是一次请求能获取我们所需要的所有数据！重要的是，数据简洁、明了。 Angular and vueangular发布了v4而后马上发布了v5，让我很想去学习一下这个框架。还有还有Vue！这个感觉国人都会的框架。。而我。。就看过文档，连TODO都没写过。。 3D and 2DCanvas、pixi.js、svg等等这些都是我想去学习的，特别是canvas很神奇，最近就会去着手尝试！ 移动端React-native在采坑，最近在看Swift的语法，会去学习原生app开发吧。但是重心都会在前端。Kotlin也会看吧。还有Weex看见过阿里的有个框架可以用React写转换成Weex。。名字忘了。下次找出来！ 最后最重要的。。。计算机基础，巴拉巴拉巴拉巴拉🤓！！！！ OK，大家共勉。加油！ 有写错的地方欢迎指出！！ 附上自己的地址： Github: github 博客： blog]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《你不知道的JavaScript（上）》读书笔记]]></title>
    <url>%2F%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%EF%BC%89%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[This在JS中This让我们捉摸不透。看了《你不知道的JavaScript（上）》让我对this有了更胜的认识。 总结一下： This实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 那么我们要去判断一个运行中函数的this绑定，我们需要先知道： 函数在哪里被直接调用？ 找到之后，我们需要去通过四条顺序规则去判断this的绑定对象 四条顺序 是否是被new调用的？是的话那就绑定到新的创建对象。 1var bar = new foo() 是否被call或者apply或者bind调用？是的话那就绑定到指定的对象。 1var bar = call(obj, 2); 是否由上下文调用？是的话那就绑定到那个上下文对象。 默认：在默认情况下，如果我们在严格模式下则为undefined，否则我们会绑定到全局对象 对象JavaScript对象可以通过两种形式定义： 声明（文字）形式和构造形式 1234567//声明形式var object = &#123; a:1&#125;;//构造形式var b = new Object();b.key = 1; //给b添加个属性 通过这两种形式我发现一个大问题！ 用构造函数去创建对象我们只能通过.去添加属性，那真是可太麻烦了。。所以我基本上都用声明形式去创建对象。 那么我想要得到b中key的值呢？？ 12console.log(b.key,'.');console.log(b["key"],'[]'); 我们有两种方法可以做到哦！ 用.操作符通常被我们叫做“属性访问”； 用[]操作符通常被我们叫做“键访问”； 但是我发现他们做的是同一件事情。。那我就把他们统称一下叫“属性访问”啦！ 哦对啦！在ES6中还有个好玩的方法！ 123456789var prev = "foo";var myObject = &#123; [prev + "Hello"] : "Hello", [prev + "World"] : "World",&#125;console.log(myObject["prevHello"]); -&gt; Helloconsole.log(myObject["prevWorld"]); -&gt; World 这是不是很神奇！我们可以通过+号实现了可计算的属性名。 多亏了ES6的Symbol,它是一种新的类型，在这我就不多说啦，贴上mdn。 属性描述符 writable：可写的 enumerable: 可枚举的 configurable: 可配置的 那么如果我做以下操作呢？ 123456Object.defineProperty(myObject, "a",&#123; value:2, writable:false, configurable:false, enumerable:false&#125;) 也就是这个myObject对象变成了不可写、不可枚举、不可配置啦。 那么我可以通过这个特性去实现一个不可变（Immutable）的对象了！ 123456var zoo = &#123;&#125;;Object.defineProperty(myObject, "cat",&#123; cat: "cat", writable:false, configurable:false,&#125;) 但是我只想要我的动物园(zoo)里只有猫不想要别的小动物了！我只能用Object.preventExtensions()来禁止别的小动物进入我的动物园，而且还保留了猫。 1234567var zoo = &#123; cat: "cat"&#125;;Object.Object.preventExtensions(zoo);zoo.dog = "dog";zoo.dog; -&gt;//undefined 还有2种方法可以做到不可变(不详细讲解，附上mdn)8： Object.seal() Object.freeze()]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parcel-typescript-react初尝试]]></title>
    <url>%2FParcel.html</url>
    <content type="text"><![CDATA[Parcel是啥？平常打包工具我们会去选择Webpack，但是我们都发现去使用webpack要么就去社区里找配置好的或者自己去看文档去配一大堆插件啊等等，但是我们在开发中还会遇到很多问题。有一句话说得好，配好了的Webpack就别动了。。因为下一步你继续配的话，你也不知道会发生什么。 那么现在有一个真正的0配置打包工具，拿来就用岂不是美滋滋？这是官网的介绍，网址如下：Parcel 进入正题现在很多人用React，并且还用上了Typescript！配置Webpack用tsc可太麻烦了。我们来看看Parcel是怎么做到的。 mkdir parcel-typescript-react-example yarn init mkdir src tsc –init 接着我们需要yarn add 一些玩意儿: yarn add parcel-bundler react react-dom typescript babel-preset-react @types/react @types/react-dom 接下来我们在根目录下创建index.html:1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;parcel-typescript-react-example&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="./src/styles.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script src="./src/index.tsx"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在src文件中我们创建 index.tsc 和 styes.css:12345678910import * as React from 'react';import * as ReactDOM from 'react-dom';class App extends React.Component&#123; render()&#123; return &lt;div&gt;Hello World!&lt;/div&gt;; &#125;&#125;ReactDOM.render(&lt;App/&gt;, document.getElementById("root")); CSS文件123456789* &#123; margin: 0; padding: 0;&#125;h1 &#123; color: red; font-size: 18;&#125; 我们的package.json如下：1234567891011121314151617181920&#123; "name": "parcel-react", "version": "1.0.0", "main": "src/index.tsx", "license": "MIT", "scripts": &#123; "start": "parcel index.html" &#125;, "dependencies": &#123; "@types/react": "^16.0.30", "@types/react-dom": "^16.0.3", "react": "^16.2.0", "react-dom": "^16.2.0" &#125;, "devDependencies": &#123; "babel-preset-react": "^6.24.1", "parcel-bundler": "^1.0.3", "typescript": "^2.6.2" &#125;&#125; 这样我们就可以打开终端-&gt; cd parcel-typescript-react-example -&gt; yarn start 静候佳音，然后locahost://1234就能看见火红的Hello World！啦 大家也可以到我的github-parcel-typescript-react-example 去 clone 代码。 欢迎start、issues~ 也可以看看我github中的其他玩意儿！ 以下是我的博客： github blog]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM]]></title>
    <url>%2FDOM.html</url>
    <content type="text"><![CDATA[文档对象模型一点小差异，IE中所有DOM对象都是以COM对象的形式实现的。 节点属性每个节点的属性 childNodes 它里面有一个对象叫NodeList patentNode previousSibling nextSibling ownerDoucment Node类型 appendChild（） 向childNodes列表的末尾添加一个节点 insertBefour() ​把节点放在childNodes列表的特定位置，它接受两参数要插入的节点，和作为参照的节点。 replaceChild() 把节点替换，这个方法接受两个参数：要插入的节点和要替换的节点 removeChild() 看英文就知道remove,移除。就只接受一个参数：就是你要移除的节点。 cloneNode() 这个方法接受一个布尔值参数，在参数为true进行深复制，反之则执行浅复制。 normalize() 处理文档树中的文本节点。 Document类型nodeType的值是9. document的对象是window对象的一个属性，因此可以将其作为全局对象来访问。 查找元素的方法： getElementById() getElementByTagName() getElementByName() document.anchors 包含文档中所有带name特性的元素 document.applets 包含文档中所有的元素​ document.forms document.images document.links 包含文档中所有带href特性的元素 Element类型nodeType的值是1。 它提供了对元素标签名、子节点及特性的访问。 操作特性的DOM方法： getAttribute() setAttribute() removeAttribute() attributes属性中包含一个NamedNodeMap，与NodeList类似，也是一个“动态”的集合。NamedNodeMap对象有下列方法 getNamedItem(name) 返回nodeName属性等于name的节点 removeNamedItem(name) 从列表移除nodeName属性等于name的节点 setNamedItem(node) 向列表中添加节点，以节点的nodeName属性为索引 item(pos) 返回位于数字pos属性位置处的节点。 Text类型nodeType的值是3 下列方法可以操作节点中的文本： appendData(text) 将text添加到节点的末尾 deleteData(offset, count) 从offset指定的位置开始删除count个字符 insertData(offset, text) 在offset指定的位置插入text replaceData(offset, count, text) 用text替换从offset指定的位置开始到offset + count为止处的文本 splitText(offset) 从offset指定的位置将当前文本节点分成两个文本节点 substringData(offset, count) 提取从offset指定的位置开始到offset + count为止处的字符串 document.createTextNode() 接受一个参数就是，要插入的文本内容 document.createTextNode(“Hello world!”); 文本节点合并normalize() 文本节点分割splitText() Comment类型nodeType的值是8 Comment类型与Text类型继承自相同的基类，所以它拥有除了splitText()之外的所有字符串操作方法。document.createComment()创建注释节点 CDATASection类型nodeType的值是4 CDATA区域只会出现在XML文档中 DocumentType类型nodeType的值是10 DocumentType包含着与文档的doctype有关的所有信息。 DocumentFragment类型nodeType的值是11 DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为DocumentFragment不是真实DOM树的一部分，它的变化不会引起DOM树的重新渲染的操作(reflow) ，且不会导致性能等问题。 该接口继承 Node 的全部方法，并实现了 ParentNode 接口中的方法。 Attr类型nodeType的值是2. Attr对象有三个属性：name、 value、 specified #总结：DOM由各种节点构成： 最基本的节点类型是Node;所有其他类型都继承自Node。 Document类型表示整个文档，是一组分层节点的根节点。在JS中document对象是Document的一个实例。 Element节点表示文档中所有HTML或XML元素，可以用来操作这些元素的内容和特性。 还有一些节点就是文本内容啊、注释、文档类型、CDATA区域和文档片段。 理解DOM的关键，就是理解DOM对性能的影响。DOM操作是Js程序中开销最大的部分，因此访问NodeList导致的问题为最多。所以每次访问NodeList对象，都会运行一次查询。 尽量减少DOM操作！！！ DOM扩展Leval 1两个方法： querySelector() querySelectorAll() Level 2 的一个方法： matchesSelector() 元素遍历Element Traversal API 为DOM元素添加了以下5个属性： childElementCount: 返回子元素的个数 firstElementChild：指向第一个子元素 lastElementChild：指向最后一个子元素 previousElementSibling ：指向前一个同辈元素 nextElementSibling：指向后一个同辈元素 与类相关的扩充1.getElementsByClassName()2.classList classList属性有以下方法： add(value) contains(value) remove(value) toggle(value) 焦点管理document.actoveElement()document.hasFocus() 插入标记 innerHTML outerHTML insertAdjacentHTML()方法 beforebegin: 在当前元素之前插入一个紧邻的同辈元素 afterbegin：在当前元素之下插入一个新的子元素或第一个子元素之前再插入新的子元素 beforeend：在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素 afterend：在当前元素之后插入一个紧邻的同辈元素。 scrollIntoView()]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 初体验]]></title>
    <url>%2FC%2B%2B%E5%88%9D%E4%BD%93%E9%AA%8C.html</url>
    <content type="text"><![CDATA[FirstClion给我建的第一个C++文件如下123456#include &lt;iostream&gt;int main() &#123; std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl; return 0;&#125; 那么我在想这和平常写得js不同啊，那个std::是啥… 经过强大的搜索引擎我知道了！这玩意儿就是一个类（std）啊（输入输出标准），它包括了cin成员和cout成员。 当我加了using namespace std;以后，我才能使用它的成员。我的c++程序可以写成: 12345678910#include &lt;iostream&gt;using namespace std; // main() 是程序开始执行的地方 int main()&#123; cout &lt;&lt; "Hello World"; // 输出 Hello World return 0;&#125; 那我又发现 namespace这个东西。原来它是指标识符的各种可见范围。 C++数据类型讲到数据类型。。我这个写惯了动态语言的人。。。诶西。强制让我写静态有点不行惯，没办法只能去写啊！ C++有七种数据类型： 类型 关键字 布尔型 bool 字符型 Char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 有一些基本类型可以使用一个或多个类型装饰符进行修饰： signed unsigned short long 枚举类型枚举大家可能都听过吧，它其实就是将变量的值一一列举出来，在这提醒下！变量的值只能在列举出来的值的范围内。 123enum animal &#123; dog, cat, pig &#125; c;c = cat;//这段代码意思为 变量c的类型为animal，最后c被赋值给cat。 在默认情况下第一个名称的值为0，第二个名称值为1，第三个名称的值为2. 如果我这有写： 1enum animal &#123; dog, cat=5, pig &#125;; 在这里，cat的值为5，那么pig值为6. 变量类型类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 布尔 char 通常为8位字节，这是一个整数类型 int float 单精度浮点类型，32位 double 双精度浮点类型，64位 void wchar_t 而且C++ 也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类。 我们可以使用 extern 关键字在任何地方声明一个变量 123456789101112#include &lt;iostream&gt;using namespace std;extern int a, b;int main()&#123; int a, b; a = 10; cout &lt;&lt; a ; //=&gt; 10&#125; 作用域在JS中我们的作用域可是太坑了！现在我们来看看C++的作用域吧。 （1）在函数或一个代码块内部声明的变量，称为局部变量。 （2）在函数参数的定义中声明的变量，称为形式参数。 （3）在所有函数外部声明的变量，称为全局变量。 12345678910111213141516171819(1局部变量)#include &lt;iostream&gt;using namespace std; int main ()&#123; // 局部变量声明 int a, b; int c; // 实际初始化 a = 10; b = 20; c = a + b; cout &lt;&lt; c; return 0;&#125; 123456789101112131415161718192021(3全局变量)#include &lt;iostream&gt;using namespace std; // 全局变量声明int g; int main ()&#123; // 局部变量声明 int a, b; // 实际初始化 a = 10; b = 20; g = a + b; cout &lt;&lt; g; return 0;&#125; 当我们遇到全局变量和局部变量的名称相同时，和js一样，在函数体内局部变量的值会覆盖全局变量。 定义常量在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 使用 const 关键字。 123456789101112131415161718#include &lt;iostream&gt;using namespace std; #define DOGFOOT 4 #define CHICKENFOOT 2#define NEWLINE '\n' int main()&#123; int area; allFoot = DOGFOOT * CHICKENFOOT; cout &lt;&lt; allFoot; cout &lt;&lt; NEWLINE; return 0;&#125;//会输出8. 那么const很简单就和es6中一样只可读不可写。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM]]></title>
    <url>%2FBOM.html</url>
    <content type="text"><![CDATA[location对象它既是window对象的属性，也是document对象的属性。 location.hash “#contents” 返回URL中的hash，如果URL中不包含散列，则返回空字符串 location.host “www.wrox.com:80&quot; 返回服务器名称和端口号 location.hostname “www.wrox.com&quot; 返回不带端口号的服务器名称 location.href “http:/www.wrox.com&quot; 返回当前加载页面的完整URL location.pathname “/WileyCDA/“ 返回URL中的目录和（或者）文件名 location.port “8080” 返回URL中指定的端口号 location.protocol “http:” 返回页面使用的协议 location.search “?q=javascript” 返回URL的查询字符串，字符串以问号开头 位置操作 location.assign 可以立即打开新URL，而且还在浏览器的历史记录中生成一条记录 location.replace 导航到的URL，不会在历史记录中生成新纪录，用户不能回到前一个页面。 location.reload 不传递任何参数，页面就会以最有效的方式重新加载 要强制从服务器重新加载，那么就需要给个参数为true navigator对象查看MDN screen对象查看MDN history对象 history.go(-1) 后退一页 history.go(1) 前进一页，以此类推 history.go(“wrox.com”) 跳转到最近的wrox.com 如果历史记录中不包含该字符串的话，那么这个方法什么也不做 还有两个简写方法,方法可以模仿浏览器的“后退” 和 “前进” 按钮。 history.back history.forward history.length 这个length属性保存着历史记录的数量。]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络读书笔记（一）]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[服务原语 原语 含义 LISTEN 阻塞操作，等待入境连接请求 CONNECT 与等待中的对等实体建立连接 ACCEPT 接受来自对等实体的入境连接请求 RECEIVE 阻塞操作，等待入境报文 SEND 给对等实体发送一个报文 DISCONNECT 终止一个连接 服务和协议服务和协议是两个截然不同的概念。 服务： 是指某一层向它上一层提供的一组原语（操作）。服务定义了该层准备代表其用户执行哪些操作，但是它不会去考虑如何实现这些操作。低层是服务提供者，上层是服务用户。 协议： 协议是一组规则，规定了同一层上对等实体之间所交换的数据包或者报文的格式和含义。 服务涉及层与层之间的接口！！！！那么，协议设计不同机器上两个对等实体之间发送的数据包 用编程语言来说的话，服务就好像是面向对象语言中的抽象数据类型或者对象。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解HTTP》读书笔记]]></title>
    <url>%2F%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[图解HTTPTCP/IP协议族 TCP/IP协议族按层次分别分为四层 应用层 传输层 网络层 数据链路层 URI, URL, URN “A Uniform Resource Identifier (URI) 是一个紧凑的字符串用来标示抽象或物理资源。” URL， URN是URI的子集，除了确定一个资源，还提供一种定位该资源的主要访问机制 换句通俗易懂的话说： URN作用就好像一个人的名字，URL就像一个人的地址。再换句话说：URN确定了东西的身份，URL提供了找到他的方式。 状态码的类别 类别 原因短语 1xx Informational(信息状态码) 接受的请求正在处理 2xx Success(成功状态码) 请求正常处理完毕 3xx Redirection(重定向状态码) 需要进行附加操作以完成请求 4xx Client Error(客户端错误状态码) 服务器无法处理请求 5xx Server Error(服务器错误状态代码) 服务器处理请求出错 最具有代表性的14个状态码： 2xx成功 200 OK 表示从客户端发来的请求在服务器端被正常处理了。 204 No Content 代表服务器接受的请求已成功处理，但在返回的响应报文中不含实体的主体部分。 206 Partial Content 表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。 3xx重定向 当301， 302， 303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。 301 Moved Permanently 永久性重定向。 302 Found 临时性重定向。 303 See Other 由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。 304 Not Modified 表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求为满足条件的情况后，直接返回304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）。 307 Temporary Redirect 临时重定向。该状态码与302有相同的含义，但是307不会从POST变成GET。 4xx客户端错误 400 Bad Request 表示请求报文中存在语法错误。 401 Unauthorized 表示发送的请求需要有通过HTTP认证的认证信息。 403 Forbidden 表明对请求资源的访问被服务器拒绝了。 404 Not Found 表明服务器上没有请求的资源。 5xx服务器错误 500 Internal Server Error 表明服务器在执行请求时发生了错误。 503 Service Unavailbale 表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 通信数据转发程序：代理、网关、隧道代理代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。 持有资源实体的服务器称为源服务器，从源服务器返回的响应经过代理服务器后再传给客户端。 使用代理服务器的理由： 利用缓存技术，减少网络带宽的流量。 组织内部针对特定网站的访问控制，以获取访问日志为主要目的。 代理有两种基准分类： 一种是是否使用了缓存，另一种是是否会修改报文。 缓存代理：代理转发响应式，缓存代理会预先将资源的副本保存在代理服务器上。 透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理。反之，如果对报文内容进行加工的代理就叫做非透明代理。 网关网关能使通信线路上的服务器提供非HTTP协议服务。 利用网关能提高通信的安全性。 比如说：网关可以连接数据库。还有在我们淘宝购物用信用卡结账的时候，网关可以和信用卡结算系统联动。 隧道隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。 也就是说，隧道本身是不会去解析HTTP请求的，他只是作为一个很安全的通道去让客户端与服务器相连。 HTTP首部HTTP请求报文在请求中，HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分构成 HTTP响应报文在响应中，HTTP报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段 3部分构成。 HTTP首部字段使用首部字段是为了给浏览器和服务器提供报文主体大小，所使用的语言、认证信息等内容。 HTTP首部字段是由首部字段名和字段值构成： 首部字段名： 字段值 在HTTP首部中，以Content-Type这个字段来表示报文主题的对象类型： Content-Type: text/html 首部字段名： 字段值 而且在字段值对应单个HTTP首部字段可以有多个值。 Keep-Alive: timeout=15, max=100 4种HTTP首部字段类型 通用首部字段 请求报文和响应报文两端都会使用的首部 请求首部字段 从客户端向服务器端发送请求报文时使用的首部。 补充了请求的附加内容、客户端信息、响应内容相关优化级等信息 响应首部字段 从服务器向客户端返回响应报文时使用的首部。 补充了响应的附加内容，也会要求客户端附加额外的内容信息。 实体首部字段 针对请求报文和响应豹纹的实体部分使用的首部 补充了资源内容更新时间等与实体有关的信息。 HTTP的缺点 通信使用的明文（不加密），可能会被窃听。 不验证通信方的身份，因此有可能遭遇伪装。 无法证明报文的完整性，所以有可能已遭篡改。 HTTP使用的认证方式 BASIC认证（基本认证） DIGEST认证（摘要认证） SSL客户端认证 FormBase认证（基于表单认证）]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《编码》读书笔记]]></title>
    <url>%2F%E3%80%8A%E7%BC%96%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[十进制，八进制，四进制，二进制 在十进制中我们计数方式是：0、 1、 2、 3、 4、 5、 6、 7、 8、 9。 在八进制中我们计数方式是：0、 1、 2、 3、 4、 5、 6、 7。 在四进制中我们计数方式是：0、 1、 2、 3。 在二进制中我们计数方式是：0、 1。 下面提供一个模板，这个模板可以将一个数转换最大长度为8的二进制数： 这就是使用方法。如果要十进制转化成二进制的话，也可以用这个模板，只不过是把乘改成除就行啦。 二进制数 十进制数 0000 0 0001 1 0010 2 0011 3 0100 4 0101 5 0110 6 0111 7 1000 8 1001 9 1010 10 1011 11 1100 12 1101 13 1110 14 1111 15 在最右边一直是 0 和 1 之间交替 右边第二列是 每2个0 和 每2个1 之间相互交替 第三列是 每4个0 和 每4个1 之间相互交替 第四列是 每8个0 和 每8个1 之间相互交替 所以只要再重复这16个数字并且在每个数字前面加一个1就可以很容易的写出后面的16个数字。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语单词]]></title>
    <url>%2F%E5%8D%95%E8%AF%8D.html</url>
    <content type="text"><![CDATA[delicate| 易碎的 idleness| 懒惰 tell the truth | 说实话 tell a lie / tell lies| 说谎话 hold the view 持某种看法;认为. in view of | 鉴于，考虑到 working on | 从事于；致力于 set free | 释放 run into | 偶然 allow | 允许，给予(人) for fear of | 生怕，以免]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语例句]]></title>
    <url>%2F%E4%BE%8B%E5%8F%A5.html</url>
    <content type="text"><![CDATA[No sooner ····· then 一。。。就。 not so much …as 与其。。不如 no more…than 不过，仅仅；至多，同。。。一样不 as…as 像。。。一样 imagined + sth. + to be + adj. 为复合宾语解构 put forward to do sth. 提出要求做某事 get sth. done 把某事做了 would rather 引导从句的虚拟结构中，如果表示对现在或将来情况的愿望，从句用过去时。 如果是对过去情况的虚拟，从句用过去完成时。 never, hardly, seldom, little, not until, not, not only, no sooner, no longer, nowhere, by no means 以上位于句首需要部分倒装 keep diary 记日记 can’t help doing sth. 忍不住做。。。 be worth doing 某（事或物）值得做 be worthy to be done 或 sth. is worthy of being done 以及 sb. be worhty of doing sth. 或者 sb. be worthy to do sth. 和 worth 的意思一样 It is/was /will be the first time that …句式 主句谓语是is，从句用现在完成时 主句谓语是was，从句谓语用过去完成时 主句谓语是will be，从句谓语用一般现在时 be appropriate for sb. 或 be appropriate to do sth. 固定搭配 appreciate + doing sth. 感激做某事 but to do,但是but之前出现了 do/does/did/done就要 but do no mood | in the mood 没有心情 | 有好心情 the impression of + doing sth. 做过某事的印象 have a(the) right to sth. 享有。。的权利 do nothing but 此结构后要求动词原形 need doing / need to done 需要被 sb. spend some time doing sth. 花时间做某事 a large amount of, a great deal of 固定搭配 将来时除了有be going to, will + do, 还有be to do, be about to do. play a part in 在。。。起作用。 must have + 过去分词 过去一定做了某事，表示对过去的肯定推测。 could have + 过去分词 本来能够做…. another + 基数词 + 名词复数 另外/在多少个 I want another three apples. 我还需要三个苹果。 mind doing sth. 介意做某事 to help you to out 表示目的 be going to + 一般现在时（leaves）]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语时态]]></title>
    <url>%2F%E6%97%B6%E6%80%81.html</url>
    <content type="text"><![CDATA[英语语法——时态时间概念包含四种，过去、现在、将来和过去将来。 动作方面包含四种，一般、进行、完成和完成进行。 将时间概念和动作方面结合一起，就能构成16种时态。 一般现在时 现在进行时 现在完成时 现在完成进行时 一般过去时 过去进行时 过去完成时 过去完成进行时 一般将来时 将来进行时 将来完成时 将来完成进行时 一般过去将来时 一般过去将来进行时 一般过去将来完成时 一般过去将来完成进行 以下图片和部分文字参考自知乎赛门喵 谓语动词有「时间」和「状态」两个属性。结构上也由「时间+时间状态」构成 将上图总结成一个表： 表格中的「助动词」突出「时间」，「主动词」突出动作「状态」。 动词原形通过两次变形，第一次具有了「动作状态」属性。第二次具有了「时间」属性，完成到了谓语动词的转换。 「时间」+「动作状态」的方式，一方面帮助了我们了解时态的的本质，更让我们可以毫不费力的记住16种时态。 接下来细致的说明这16种时态 一般 概念：仅仅陈诉一个事实（fact） 形式：动词原形，我们用play。 1234I played baskerball. 我过去（以前）打篮球。I play baskerball. 我现在打篮球。I will play baskerball. 我将要打篮球。I didn&apos;t know if he would come. 我不知道她是否回来。 did + play = played = 过去 + 一般体 = 一般过去时 do/does + play = play/plays = 现在 + 一般体 = 一般现在时 will + play = will play = 将来 + 一般体 = 一般将来时 would + come = would come = 过去将来 + 一般体 = 一般过去将来时 进行 概念：表示动作正在发生 形式：ing 过去进行时(was/ were)We were discussing the decoration problem 10 minutes ago.10分钟前，我们正讨论装修的问题。 ​I was cooking when you knocked at the door. 你敲门时我正在做饭。 现在进行时(am/ is/ are)I’m felling better now. //表示正在进行的动作 我现在感觉好多了。 We are leaving tomorrow. //有些瞬间动词用进行时表将来 我们明天离开。 ​ He is always asking such foolish questions. //表示某动作反复发生 ​ 他总是问如此愚蠢的问题。 ​ You are being modest. ​ //“an, are, is+bing” 强调被描述情况或状态的暂时性。 ​ 你这会儿倒是挺谦虚的。 he is buying a new bike soon. //在时间和条件状语从句中，现在进行时表示将来的动作。 她不久将买一辆新自行车。 将来进行时(will be)The train will be leaving in a second. 火车就要开了。 What will you be doing this time tomorrow？ 明天这个时候你将做什么？ 过去将来进行时(should be/ would be)I never realized that someday I would be living in Africa. 我以前从没想过将来有一天我会生活在非洲。 完成 概念：表示动作完成了 形式：过去分词，drunk 过去完成时(had) + doneUp to the end of last year, the aim had been achieved to cut energy use by 80%. //过去的过去的动作或状态，“up to/ before/ by + 过去时间”作时间状语。 到去年年底，已经实现节能80%的目标。 There had been someone in our room just now, because i noticed a burning cigarette end on the floor when we opened the front door. //过去的过去。这种逻辑关系通过上下文体现 刚才有人在我们的房间里，因为我们打开前门进来时，我注意到地板上有一个仍在燃烧的烟头 现在完成时(hava/ has) + doneShe has won prizes for her records. //表示从过去某时刻开始，持续到现在的动作或情况，并且有可能会继续延续下去。 她的唱片曾获奖过几次奖。 For years i have been interested in engineering. //时间状语常用since加一个过去的时间点，或for加一段时间 多年来，我一直对工程学感兴趣。 I have been here since last June. 从去年6月起，我一直在这里。 A moment please, I have almost finished the report. //表示发生在过去， 但对现在仍有影响的动作或情况，通常用瞬间动词“arrive begin, find, give, finish, lose” 稍等，我的报告就快完成了。 将来完成时(will have) + doneIf you come at 6 p.m, I shall not yet have finished dinner. //表示将来某一时间之前完成的动作，并往往对将来某一时间产生影响。 你若下午6点来，我还没吃完晚饭呢。 You must take a taxi, otherwise the train will have left by the time you get to the station. //常用 “before + 将来时间点”或“by + 将来时间点”作时间状语 你必须坐出租，否则等你到了车站火车都开走了。 Before long, he will have forgotten all about the matter. 过不久，他就将把这事儿忘记了。 过去将来完成时(would have) + doneHe said that he would have done with my camera by the end of next week. //表示在过去将来某一时间以前发生的动作，并往往会对过去将来某一时间产生影响 他说到下周末就不用我的照相机了。 完成进行 概念： 表明动作(暂时)完成了，并且还要继续 形式： been + (base form) ing 过去完成进行时(had) + been doingHe was tired. He had been working all day. //和过去完成时一样，过去完成进行时也必须以一个过去的事就为前提。 他累了，他工作了一整天。 It had been raining heavily for two days and the ground was very wet. 连着下了两天大雨，地上很湿。 现在完成进行时(have/ has) + been doingWe have been working on this project for over a month now. //表示某一动作开始于过去某一时间，延续或重复的出现至今，或将继续延续至将来。 到目前为止，我们一直在处理那个项目，已经花了一个多月时间了。 //与现在完成时相比，现在完成时进行时更强调在从过去到现在的时间里，动作或状态一直持续或一直反复出现。 将来完成进行时(will have) + been doingIf we don’t hurry up the store will have been closing before we get there. //表示动作从某一时间开始一直延续到将来某一时间。 如果我们不快一点儿， 等到了那儿，商店早关门了。 By then, we will have been cooperating for half a year. 到那时为止，我们就将会合作半年了。 过去将来完成进行时(would have) + been doingHe said that by the end of July he would have been studing German for six months. //表示动作从过去某一时间开始一直延续到过去将来某一时间 他说到7月底，他学德语就有半年了。 以下未满18岁请自动屏蔽LoVe 这段我无意间看见 一般现在时:I make love with her everyday.一般过去时:I made love with her yesterday.一般将来时:I will make love with her tomorrow. 现在进行时:I am making love with her.过去进行时:I was making love with her at this time yesterday.将来进行时:I will be making love with her at this time tomorrow. 现在完成时:I have made love with her by now.过去完成时:I had made love with her before yesterday.将来完成时:I will have made love with her by tomorrow. 现在完成进行时:I have been making love with her for two hours.过去完成进行时:I had been making love with her for two hours when her husband came in.将来完成进行时:I will have been making love with her for two hours when her husband wakes up tomorrow morning.]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React生命周期]]></title>
    <url>%2FReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html</url>
    <content type="text"><![CDATA[React生命周期生命周期可能经历如下三个经历： 装载过程(Mount): 把组件第一次在DOM树中渲染的过程； 更新过程(Update): 组件被重新渲染的过程; 卸载过程(Unmount): 组件从DOM中删除的过程; 接下来，一个一个解释： 装载过程 constructor getInitialState getDefaultProps componentWillMount render componentDidMount 1 一个React组件需要constructor，往往是为了达到下面的目的 初始化state，因为组件生命周期中任何函数都可能要访问state 绑定成员函数的this环境 举个例子： this.onClickIncrementButton = this.onClickIncrementButton.bind(this); 这条语句的作用，就是通过bind方法让当前实例中onClickIncrementButton函数被调用时，this始终是指向当前组件实例。 2 getInitialState和getDefaultProps是在React.createClass方法创造的组件类才会用到。 12345678const Sample = React.createClass (&#123; getInitialState: function()&#123; return &#123;foo: 'bar'&#125;; &#125;, getDefaultProps: function()&#123; return &#123;sampleProp: 0&#125;; &#125;&#125;); 在ES6的话 12345678910class Sample extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; foo: 'bar' &#125;; &#125;Sample.defaultProps = &#123; sampleProp: 0&#125;; 3 render函数是一个纯函数。完全根据this.state 和 this.props来决定返回的结果，而且不要产生任何副作用。 在render函数中去调用this.setState毫无疑问是错误的。因为一个纯函数不应该引起状态的改变。 4 在装载过程中，componentWillMount会在调用render函数之前调用。 componentDidMount会在调用render函数之后调用。 这两个函数是render函数的前哨和后卫。 但是一般我们都不用定义componentWillMount,因为这个函数发生在”将要装载”的时候，这个时候没有任何渲染出来的结果。即使我们去调用this.setState修改状态也不会引发重新绘制。 也就是说所有可以在componentWillMount中做的事情，我们都可以提前到constructor中去做。 我们来说说componentDidMount这个函数，它仅在浏览器端执行。 更新过程 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 1 componentWillReceiveProps 只要是父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程。不管父组件传给子组件的props有没有改变，都会触发子组件的componentWillReceiveProps函数。 还有，通过this.setState方法触发的更新过程不会调用这个函数。 因为这个函数适合根据新的props值来计算出是不是要更新内部状态state。更新组件内部状态的方法就是this.setState。 2 shouldComponentUpdate(nextProps, nextState) 这个函数重要因为，它决定了一个组件什么时候不需要渲染。 这个函数返回一个布尔值，告诉React库这个组件在这次更新过程中是否要继续。 在更新过程中，React库首先会调用shouldComponentUpdate函数 如果这个函数返回一个true，那就会继续更新过程，接下来调用render函数。 反之如果得到一个false，那就立刻停止更新过程，也就不会引发后续的渲染了。 说这个函数重要，是因为我们使用恰当的话，能够大大挺高React组件的性能。 卸载过程 componentWillUnmount 1 当React组件要从DOM树上删除掉之前，对应的componentWillUnmount函数会被调用。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习CSS(二)]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0CSS(%E4%BA%8C).html</url>
    <content type="text"><![CDATA[盒模型页面上的每个元素被看做一个矩形框，这个框由元素的内容、内边距（padding）、边框（border）、和外边距（margin）组成。 外边距叠加 本小节参考W3school。 当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。 当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并。 尽管看上去有些奇怪，但是外边距甚至可以与自身发生合并。 假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并： 如果这个外边距遇到另一个元素的外边距，它还会发生合并： 外边距合并初看上去可能有点奇怪，但是实际上，它是有意义的。以由几个段落组成的典型文本页面为例。第一个段落上面的空间等于段落的上外边距。如果没有外边距合并，后续所有段落之间的外边距都将是相邻上外边距和下外边距的和。这意味着段落之间的空间是页面顶部的两倍。如果发生外边距合并，段落之间的上外边距和下外边距就合并在一起，这样各处的距离就一致了。 定位概述可视化格式模型和定位模型。 可视化格式模型h1,p,div等元素常常称为块级元素。 strong,span等元素称为行内元素。 当行内元素你把它们的display属性设置成block，此元素会被显示为块级元素。 块级框从上到下一个接一个地垂直排列。 相对定位如果对一个元素进行相对定位，其实就是让这个元素“相对于”它的起点移动。 1234567891011121314151617181920212223#myBox &#123;width: 200px;height: 200px;background: red;&#125;#myBox1 &#123;position: relative;width: 200px;height: 200px;background: blue;&#125;#myBox2 &#123;position: relative;left: 20px;top: 20px;width: 200px;height: 200px;background: gray;&#125;&lt;div id="myBox"&gt;&lt;/div&gt;&lt;div id="myBox1"&gt;&lt;/div&gt;&lt;div id="myBox2"&gt;&lt;/div&gt; 绝对定位绝对定位使元素的位置与文档流无关。 绝对定位的元素的位置是相对于距离它最近的那个已定位的祖先元素确定的。如果元素没有已定位的祖先元素，那么它的位置是相对于初始包含块的。 接下来我们让一个文本段落对准一个大框的右下角： 1234567891011121314151617#branding &#123;width: 20em;height: 10em;position: relative;background: black;&#125;#branding .tel &#123;position: absolute;right: 1em;bottom: 1em;text-align: right;color: white;&#125;&lt;div id="branding"&gt; &lt;p class="tel"&gt;Tel: 0845 838 6163&lt;/p&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习CSS(一)]]></title>
    <url>%2F%E5%AD%A6CSS%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
    <content type="text"><![CDATA[给自己的要求 class应该用在概念上相似的元素，这些元素可以出现在同一页面上的多个位置。 ID应该用于不同的唯一的元素。 DTD（文档类型定义）DOCTYPE声明是指HTML文档开头处的一行或两行代码。它描述使用哪个DTD。 但是在HTML5中就不需要URL，浏览器一般不读取这些文件。而是只识别常见的DOCTYPE声明。 选择器选择器最常用的两种： 类型选择器 和 后代选择器 。 123/*类型选择器*/p &#123; color: black; &#125;h1 &#123; font-weight: bold; &#125; 12/*后代选择器*/blockquote p &#123; padding: 15px; &#125; 还有两种就是： ID选择器 和 类选择器 。 12#intro &#123; font-weight: bold; &#125; /*ID选择器*/.date-posted &#123; color: #ccc; &#125; /*类选择器*/ 但是类选择器和ID选择器用太多也不是很好。下面有一种方法可以以一种方式对主体和副的地方操作css 1234567891011#main-content h2 &#123; font-weight: 1.8em; &#125;#secondary-content h2 &#123; font-weight: 1.2em; &#125;&lt;div id="main-content"&gt; &lt;h2&gt;Hello&lt;/h2&gt; .....&lt;/div&gt;&lt;div id="secondary-content"&gt; &lt;h2&gt;Hi&lt;/h2&gt; ....&lt;/div&gt; 伪类1234567891011a:link &#123; color : blue; &#125; /*链接伪类*/a:visited &#123; color : green; &#125; /*链接伪类*//*链接伪类只能用于锚元素*/动态伪类a:hover, a:focus, a:active &#123; color: red; &#125; tr:hover &#123; background-color: red; &#125;input:focus &#123; background-color: yellow; &#125;伪类链接a:visited:hover &#123; color: olive; &#125; 通用选择器12345* &#123; padding: 0; margin: 0;&#125;/*删除每个元素上默认的浏览器内边距和外边距*/ 高级选择器之—-子选择器后代选择器选择一个元素的所有后代，那么子选择器就只选择元素的直接后代啦！ 1234567891011121314#nav&gt;li &#123; font-size: 30px;&#125;&lt;ul id="nav"&gt; &lt;li&gt;&lt;a href="/home/"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/Services/"&gt;Services&lt;/a&gt;&lt;/li&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="/Services/design"&gt;Design&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/Services/development"&gt;Development&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/Services/consultancy"&gt;Consultancy&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;li&gt;&lt;a href="/contact"&gt;Contact Us&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 子选择器指定列表子元素的样式，但是不影响他的孙元素。 还有根据一个元素与另一个元素的相邻关系对它应用样式。 123456789h2 + p &#123; font-size: 1.4em; font-weight: blod; color: #777;&#125;&lt;h2&gt;Hello World&lt;/h2&gt; &lt;p&gt;I'm here&lt;/p&gt; &lt;p&gt;wow,me too&lt;/p&gt; 更新于2017-09-05 21：30 属性选择器12345678910[title=hi]&#123;border:5px solid blue;&#125;&lt;h1&gt;可以应用样式：&lt;/h1&gt;&lt;img title="hi" src="/nihao.gif" /&gt;&lt;br /&gt;&lt;a title="hi" href="/"&gt;W3School&lt;/a&gt;&lt;hr /&gt; 层叠和特殊性层叠性有 !important 标志的规则，它优先于任何规则。 特殊性 选择器 特殊性 以10为基数的特殊性 Style=“ ” 1,0,0,0 1000 #wrapper #content {} 0,2,0,0 200 #content .datePosted {} 0,1,1,0 110 div#content {} 0,1,0,1 101 #content {} 0,1,0,0 100 p.comment .dateposted {} 0,0,2,1 21 p.comment {} 0,0,1,1 11 div p {} 0,0,0,2 2 p {} 0,0,0,1 1 1234567891011121314151617181920212223242526272829#content div#main-content h2&#123;color: gray;&#125;#content #main-content&gt;h2 &#123;color: blue;&#125;body #content div[div="main-content"] h2 &#123;color: green;&#125;#main-content div.news-story h2 &#123;color: orange;&#125;#main-content [class="news-story"] h2 &#123;color: yellow;&#125;div#main-content div.news-story h2.first &#123;color: red;&#125;&lt;div id="content"&gt; &lt;div id="main-content"&gt; &lt;h2&gt;Hello&lt;/h2&gt; &lt;p&gt;哇&lt;/p&gt; &lt;div class="news-story"&gt; &lt;h2 class="first"&gt;BigBong&lt;/h2&gt; &lt;p&gt;嘻嘻&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用阿里云oss踩得坑]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91oss%E8%B8%A9%E5%BE%97%E5%9D%91.html</url>
    <content type="text"><![CDATA[Provisional headers are shown首先我现在console里看见以下报错： 接着我去了network里看： 最后找到了根本问题所在： 因为我在https的网页中，是不允许我去发http的请求，所以我需要去自己发起请求的client代码中加入secure：true。 ErrorCode: AccessForbidden 如果遇到以上问题，那肯定是你的 CORS没有配置或者配置不对。 我们需要到阿里云的的OSS控制台中做以下设置： 以下也是上述没设置好的错，错误为：出错请求的HTTP状态码]]></content>
      <categories>
        <category>阿里云服务的使用</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付宝小程序踩坑（一）]]></title>
    <url>%2F%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F.html</url>
    <content type="text"><![CDATA[这是支付宝小程序编译器的主界面 这是 hello，world的文件树。是基于js语言。小程序开发者工具默认支持 ES5/ES6/ES7，推荐使用 ES6 以上语法。而且还内置了 ESLint 支持]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CO函数，异步]]></title>
    <url>%2FCO%E5%87%BD%E6%95%B0%EF%BC%8C%E5%BC%82%E6%AD%A5.html</url>
    <content type="text"><![CDATA[CO函数库co 函数库是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 Generator 函数的自动执行。 有一个 Generator 函数，用于依次读取两个文件。 123456var gen = function* ()&#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; co 函数库可以让你不用编写 Generator 函数的执行器。 12var co = require('co');co(gen); 上面代码中，Generator 函数只要传入 co 函数，就会自动执行。 co 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。 123co(gen).then(function ()&#123; console.log('Generator 函数执行完成');&#125;) co 函数库的源码co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。 首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。 123456function co(gen) &#123; var ctx = this; return new Promise(function(resolve, reject) &#123; &#125;);&#125; 在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为 resolved 。 12345678function co(gen) &#123; var ctx = this; return new Promise(function(resolve, reject) &#123; if (typeof gen === 'function') gen = gen.call(ctx); if (!gen || typeof gen.next !== 'function') return resolve(gen); &#125;);&#125; 接着，co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulefilled 函数。这主要是为了能够捕捉抛出的错误。 12345678910111213141516171819function co(gen) &#123; var ctx = this; return new Promise(function(resolve, reject) &#123; if (typeof gen === 'function') gen = gen.call(ctx); if (!gen || typeof gen.next !== 'function') return resolve(gen); onFulfilled(); function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; &#125;);&#125; 最后，就是关键的 next 函数，它会反复调用自身。 12345678function next(ret) &#123; if (ret.done) return resolve(ret.value); var value = toPromise.call(ctx, ret.value); if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: "' + String(ret.value) + '"')); &#125;&#125;); 上面代码中，next 函数的内部代码，一共只有四行命令。 第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。 第二行，确保每一步的返回值，是 Promise 对象。 第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。 第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。 并发的异步操作co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。 这时，要把并发的操作都放在数组或对象里面。 1234567co(function* ()&#123; var values = [n1,n2,n3]; yield values.map(somethingAsync);&#125;);function* somethingAsync(x)&#123; return y&#125;; #]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript函数]]></title>
    <url>%2FJavaScript%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[在JavaScript中，函数是一等公民。函数是第一型对象。 所以说，我们可以将其视为其他任意类型的JavaScript对象。 在JavaScript中函数可以： 可以赋值给变量，数组，或其他对象的属性 可以通过字面量进行创建 将其作为参数进行传递 可以作为函数的返回值进行返回 可以拥有动态创建并赋值的属性 最重要是的，它们还可以被调用。这些调用通常是以异步方式进行调用。 回调回调函数的术语源于：我们定义一个函数，以便其他一些代码在适当的时机回头再调用他。 123function useless(callback)&#123; return callback();&#125; 123456789101112var text = 'Demo arigato';assert(useless(function()&#123; return text;&#125;) ===text, "This useless function works!" + text);//assert是测试函数function assert(value, desc)&#123; var li = document.createElement("li"); li.className = value ? "pase" : "fail"; li.appendChild(document.createTextNode(desc)); document.getElementById("results").appendChild(li);&#125;; 函数字面量函数字面量由4个部分组成 function关键字 可选名称。 括号内部，一个以逗号分隔的参数列表。 包含在大括号内的一系列JavaScript语句叫 函数体。 注意： 所有的函数都有name属性，该属性保存的是他们的名称的字符串。 当然没有名称的函数也有name属性，只是为空字符串。 123var canFly = function() &#123; return true;&#125;; 这个函数我们可以通过它的引用 canFly 进行调用。它与canFly函数几乎一模一样，但是不一样的地方在于它的字符串值为” ”，而不是“canFly”。 123window.isDeadly = function() &#123; return true;&#125;; 我们可以（ window.isDeadly() || isDeadly() ）去调用这个函数，其实这就跟命名函数几乎一模一样了。 函数调用4个不同的方式可以进行函数调用。 作为一个函数进行调用 作为一个方法进行调用，在对象是进行调用，支持面向对象编程 作为构造器进行调用，创建一个新对象 通过apply()或call()方法进行调用。 函数传递两个隐式参数arguments和this 隐式（limplicit），意味着这些参数不会显示列在函数签名里。但是他们都会默默的传递给函数并存在于函数作用于内。 arguments它是传递给函数的所有参数的一个集合，它有一个length属性。比如： arguments[2]表示获取第三个参数。 虽然它可以使用数组进行获取，甚至可以用for循环对它进行遍历。但是它确实不是JS数组。 我们只要将它看成一个类数组结构，并且 只拥有数组 的某些特性，仅此而已。 thisthis参数引用了与该函数调用进行隐式关联的一个对象，被称为函数上下文。 作为函数进行调用很简单，比如说： 123456789function hi()&#123; return hello;&#125;hi();var xzh = function()&#123; return xuzihao;&#125;xzh(); 这就是作为函数调用。这种方法调用函数的上下文就是——-window对象。 作为方法进行调用123var o = &#123;&#125;;o.whatever = function ()&#123;&#125;;o.whatever(); 那么o.whatever的函数上下文为o。 作为构造器进行调用1234function creep() &#123; return this;&#125;new creep(); 构造器的超能力构造器调用时，下面的特殊行为会发生： 创建一个新的空对象 传递给构造器的对象是this参数，从而成为构造器的函数上下文。 如果没有显式的返回值，新创建的对象则作为构造器的返回值进行返回。 使用apply()和call()方法进行调用可以显式指定任何一个对象作为其函数上下文。 JavaScript的每个函数都有apply() 和 call()方法。使用其中一个我们都可以实现这种功能。 12345678910111213141516171819function juggle()&#123; var result = 0; for(var n = 0; n &lt; arguments.length; n++)&#123; result += arguments[n]; &#125; this.result = result;&#125;var ninja1 = &#123;&#125;;var ninja2 = &#123;&#125;;//apply() 传入2个参数： 一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。juggle.apply(ninja1, [1,2,3,4]);//call() 传入两个参数： 一个是作为函数上下文的对象，另外一个是一个参数列表。juggle.call(ninja2, 5,6,7,8);//assert是断言测试用的assert(ninja1.result === 10, "juggled via apply");assert(ninja2.result === 26, "juggled via call"); 五种this的工作原理全局 this; this指向全局对象，浏览器：window，js:global 函数调用 foo(); this也指向全局对象 方法调用 bar.foo(); this指向被调用的对象。 调用构造函数 new foo(); this指向新创建的对像。 显式的设置this apply, call 当使用 Function.prototype 上的 call 或者 apply 方法时，函数内的 this 将会被 显式设置为函数调用的第一个参数。 总结 作为函数进行调用：该上下文是方法的拥有者。 作为全局函数进行调用：该上下文永远是windos。 作为构造器函数进行调用：该上下文对象则是新创建的对象实例。 通过函数的apply（）或call（）方法进行调用时，上下文可以设置成任意值。]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native iOS/android环境配置]]></title>
    <url>%2FReact%20Native%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[React Native环境配置Ios开发环境因为我是在mac下搭建环境的。所以比较方便。 Xcode时必须的！ brew install node //电脑需要有node brew install watchman //这是用来监视文件系统中的更改的工具 npm install -g react-native-cli 然后我们打开 Xcode 接下来我们需要执行命令 react-native init AwesomeProject Then：我们需要在Xcode里打开 1234接着在终端里cd AwesomeProjectthen：react-native run-ios 接下来我们等就好了 这就是成功界面 恭喜🎉！ Android环境第一步与ios一样 brew install node brew install watchman 我们就不做了。 接下来 我们需要安装Java的环境。Download and install JDK 8 or newer 安装Android环境 安装 Android studio 勾选Performance和Android Virtual Device 安装完成后，在Android Studio的启动欢迎界面中选择Configure | SDK Manager。 在SDK Platforms窗口中，选择Show Package Details 然后tools里 ANDROID_HOME环境变量确保ANDROID_HOME环境变量正确地指向了你安装的Android SDK的路径。具体的做法是把下面的命令加入到~/.bash_profile文件中：(译注：~表示用户目录，即/Users/你的用户名/，而小数点开头的文件在Finder中是隐藏的，并且这个文件有可能并不存在。请在终端下使用vi ~/.bash_profile命令创建或编辑。如不熟悉vi操作，请点击这里学习） 12# 如果你不是通过Android Studio安装的sdk，则其路径可能不同，请自行确定清楚。export ANDROID_HOME=~/Library/Android/sdk 然后使用下列命令使其立即生效（否则重启后才生效）： 1source ~/.bash_profile 可以使用echo $ANDROID_HOME检查此变量是否已正确设置。 最后同样我们需要在Android studio中打开创建的文件夹下Android文件 然后去build 圆圈是选手机机型。 我们在正方形框框中先点击锤子然后点击绿色箭头之后在终端里输入以下： 123react-native init AwesomeProjectcd AwesomeProjectreact-native run-android 下面就是成功画面！恭喜🎉！ 在搭建环境下踩得坑Android下 这是我运行安卓的时候遇到的问题。我们需要在 Android studio先启动一个手机模拟器再去终端里输入指令：react-native run-android 就可以了 这个问题是说Build Tools 23.0.0.1太低至少需要25.0.0 但是我升级过后还不行。发现是配置文件里的问题。 这样就行啦！ Ios下具体出错问题描述找不到了，但是情况还是记得的。 就是说我ios的虚拟机打开了但是我在上面看不见自己的项目。 这时候google到答案。。 需要开一个终端，然后去在你的项目下npm install 就是这样。。具体情况我也不知道发生了什么哈哈哈]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript对象]]></title>
    <url>%2FJavascript%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[Javascript对象JavaScript对象可以通过两种形式定义： 声明（文字）形式和构造形式 1234567//声明形式var object = &#123; a:1&#125;;//构造形式var b = new Object();b.key = 1; //给b添加个属性 通过这两种形式我发现一个大问题！ 用构造函数去创建对象我们只能通过.去添加属性，那真是可太麻烦了。。所以我基本上都用声明形式去创建对象。 那么我想要得到b中key的值呢？？ 12console.log(b.key,'.');console.log(b["key"],'[]'); 我们有两种方法可以做到哦！ 用.操作符通常被我们叫做“属性访问”； 用[]操作符通常被我们叫做“键访问”； 但是我发现他们做的是同一件事情。。那我就把他们统称一下叫“属性访问”啦！ 哦对啦！在ES6中还有个好玩的方法！ 123456789var prev = "foo";var myObject = &#123; [prev + "Hello"] : "Hello", [prev + "World"] : "World",&#125;console.log(myObject["prevHello"]); -&gt; Helloconsole.log(myObject["prevWorld"]); -&gt; World 这是不是很神奇！我们可以通过+号实现了可计算的属性名。 多亏了ES6的Symbol,它是一种新的类型，在这我就不多说啦，贴上mdn。 属性描述符 writable：可写的 enumerable: 可枚举的 configurable: 可配置的 那么如果我做以下操作呢？ 123456Object.defineProperty(myObject, "a",&#123; value:2, writable:false, configurable:false, enumerable:false&#125;) 也就是这个myObject对象变成了不可写、不可枚举、不可配置啦。 那么我可以通过这个特性去实现一个不可变（Immutable）的对象了！ 123456var zoo = &#123;&#125;;Object.defineProperty(myObject, "cat",&#123; cat: "cat", writable:false, configurable:false,&#125;) 但是我只想要我的动物园(zoo)里只有猫不想要别的小动物了！我只能用Object.preventExtensions()来禁止别的小动物进入我的动物园，而且还保留了猫。 1234567var zoo = &#123; cat: "cat"&#125;;Object.Object.preventExtensions(zoo);zoo.dog = "dog";zoo.dog; -&gt;//undefined 还有2种方法可以做到不可变(不详细讲解，附上mdn)8： Object.seal() Object.freeze() 在JavaScript中，数组是对象，函数是对象，正则表达式是对象。那么对象自然也是对象。 JavaScript中的对象是无类型的。 对象是属性的容器，其中每个属性都拥有名字和值。 JavaScript包含一种原型链的特性，允许对象继承另一个对象的属性。 一张简略图 对象最常见的用法 创建（create） 设置（set） 查找（query） 删除（delete） 检测（test） 枚举（enumerate） 每个属性还有一些与之相关的值，称为属性特性 可写 可枚举 可配置 除了包含属性之外，每个对象还拥有三个相关的对象特性 对象的原型(prototype) 对象的类(class) 对象的扩展标记 内置对象，如数组，函数，日期，和正则表达式都是内置对象 宿主对象，简单的理解就是BOM、DOM和自己定义的对象 自定义对象，就是我们自己创建的对象 自有属性，直接在对象中定义的属性 继承属性，在对象原型对象中定义的属性。 new创建对象new 运算符创建并初始化一个新对象。关键字new后跟随一个函数调用。这个函数称做构造函数。 对象字面量12345var empty_project = &#123;&#125;;var stooge = &#123; //对象字面量 "first-name": "Jerome", "last-name": "Howard"&#125;; 一个对象字面量就是包围在一对花括号中的零或多个“名/值”对。 1234567891011121314var flight = &#123; airline: "Oceanic", number: 815, departure: &#123; IATA: "SYD", time: "2014-09-22 14:55", city: "Sydney" &#125;, arrival:&#123; IATA: "LAX", time: "2004-09-23 10:42", city: "Los Angeles" &#125;&#125;; 属性的值可以从包括另一个对象字面量在内的任意表达式中获得。对象是可以嵌套的。 属性的查询12stooge["first-name"] //Jeromeflight.departure.IATA //SYD 需要检索对象里包含的值，可以采用[ ]后缀中括住一个字符串表达式的方式。 但是最好用.表示法。因为它可读性好。 我们去检索不存在的： 12stooge["middle-name"] //undefinedflight.status //undefined ||运算符可以用来填充默认值： 12var middle = stooge["middle-name"] || "(none)";var status = flight.status || "unkown"; 如果我们从undefined的成员属性中取值会导致TypeError异常。这时候我们可以通过 &amp;&amp; 运算符来避免错误。 123flight.equipment //undefinedflight.equipment.model //throw "TypeError"flight.equipment &amp;&amp; flight.equipment.model //undefined 属性的设置对象里的值可以通过赋值语句来更新。如果属性吗已经存在于对象里，那么这个属性的值会被替换。 1stooge['first-name'] = 'Jerome'; 123456stooge['middle-name'] = 'Lester';stooge.nickname = 'Curly';flight.equipment = &#123; model: 'Boeing 777'&#125;;flight.status = 'overdue'; 那么这些属性全部会扩充到对象中。 关联数组的对象object[&quot;property&quot;]，这个看起来更像数组，但是这个数组元素是通过字符串索引。这种数组就是关联数组，别名“散列”，“映射”，“字典”。JavaScript对象都是关联数组。 引用对象通过引用来传递，他们永远不会被复制 12345678910var x = hi;x.hello = 'what';var how = hi.hello; // how为what。//因为x和hi是指向同一个对象的引用。var a = &#123;&#125;,b = &#123;&#125;,c = &#123;&#125;;//a,b,c每个都引用一个不同的对象a = b = c = &#123;&#125;;//a,b,c都是引用同一个空对象 原型每个对象都连接着另一个对象相关联，这个对象就是原型。而且每一个对象都可以从原型继承属性。 所有通过对象字面量创建的对象都连接到Object.prototype，它是JavaScript中的标配对象。 那么由new Date()创建的Date对象的属性同时继承自Date.prototype和Object.prototype。这一系列链接在一起的原型对象，就是我们所说的原型链。 12345678if (typeof Object.beget !== 'function')&#123; Object.create = function (o)&#123; var F = function ()&#123;&#125;; F.prototype = o; return new F(); &#125;;&#125;var another_stooge = Object.create(stooge); Object增加一个create方法，这个方法创建一个使用原对象作为其原型的新对象。 原型连接在更新时是不起作用的123another_stooge['first-name'] = 'Harry';another_stooge['middle-name'] = 'Moses';another_stooge.nickname = 'Moe'; 原型连接只有在检索值得时候才被用到。 如果我们尝试去获取对象的某个属性值，但对象没有此属性名。 JavaScript会从原型对象中获取属性值 ——&gt; 原型对象中没，就回去它原型中寻找 ——&gt;直到最后到达终点Object.prototype。 假如想要的属性不存在于原型链，那么结果就只能是undefined。 以上的过程为委托。 原型关系我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见。 12stooge.profession = 'actor';another_stooge.profession //'actor 反射typeof操作符对确定属性的类型很有帮助。 1234typeof flight.number //numbertypeof flight.status //stringtypeof flight.arrival //objecttypeof flight.manifest //undefined 原型链中的任何值都会产生值 12typeof flight.toString //functiontypeof flight.constructor //function 有两种方法去处理掉这些不需要的属性。 第一个是让你的程序做检查并丢弃为函数的属性。 另一个方法是hasOwnProperty 方法，如果对象拥有独有的属性，它将返回true。不会检查原型链 12flight.hasOwnProperty('number') //trueflight.hasOwnProperty('constructor') //true ##属性的特性 数据属性的4个特性： 它的值 可写性 可枚举性 可配置性 存取器属性的4个特性： 读取 写入 可枚举性 可配置性 为了实现属性特性的查询和设置，我们就有了一个名为 ”属性描述符（property descriptor）”。这个对象代表了那4个特性。 数据属性的描述符对象的属性有value（它的值）, writable（可写性）, enumerable（可枚举性）, configurable（可配置性）。 存取器属性的描述符对象的属性有get属性, set属性代替 value（它的值）, writable（可写性）, enumerable（可枚举性）, configurable（可配置性）。 而且[writable（可写性），enumerable（可枚举性）,configurable（可配置性）这仨都是布尔值]。 而且get属性和set属性是函数值。 我们通过调用Object.getOwnPropertyDescriptor()可以获得某个对象特定属性的属性描述符。 12Object.getOwnPropertyDescriptor(&#123;x:1&#125;,"x");//返回&#123; value: 1, writable: true, enumerable: true, configurable: ture &#125; 要想获得继承属性的特性，需要遍历原型链，Object.getProtorypeOf() 要想设置属性的特性，需要调用Object.definePeoperty()： 123456789101112131415161718192021222324var o = &#123;&#125;;//添加一个不可枚举的数据熟悉Object.definePeoperty(o, "x", &#123; value:1, writable:true, enumerable:false, configurable:true,&#125;);//属性是存在的，但是不可枚举o.x; // =&gt; 1Object.keys(o); // =&gt; []//对属性x做修改，让它变为只读Object.defineProperty(o, "x",&#123;writable: flase&#125;);//试图去改o.x = 2; //操作失败，但是不报错，在严格模式下会抛出类型错误异常o.x; // =&gt; 1Object.definePropetry(o, "x", &#123;value:2&#125;);o.x; // =&gt; 2Object.definePropetry(o, "x", &#123;get: function()&#123;return 0;&#125;&#125;);o.x; // =&gt; 0 类属性对象的类属性是一个字符串。 ##序列化对象 对象序列化是指将对象的状态转换为字符串，也可将字符串还原为对象。 JSON.stringify(),JSON.parse()用来序列化和还原JavaScript对象。 对象方法toString()123var s = &#123;x:1, y:1&#125;.toString();// =&gt; [object, Object] toLocaleString()这个方法返回一个表示这个对象的本地化字符串. toJSON()Object.prototype实际上是没有定义toJSON()方法的，JSON.stringify()方法会调用toJSON()方法。 valueOf()这个方法和toString()非常类似。 当JavaScript需要将对象转换为某种原始值而非字符串的时候才会调用它，尤其是转换为数字的时候。 减少全局变量污染最小化使用全局变量的方法之一是为你的应用只创建一个唯一的全局变量！！ 1234567891011121314151617181920var MYAPP = &#123;&#125;; //该变量此时变成你的应用的容器MYAPP.stooge = &#123; "first-name": "Joe", "last-name": "Howard"&#125;;MYAPP.flight = &#123; airline: "Oceanic", number: 815, departure: &#123; IATA: "SYD", time: "2004-09-22 14:55", city: "Sydney" &#125;, arrival: &#123; IATA: "LAX", time: "2004-09-23 21:59", city: "Los Angeles" &#125;&#125;; 只要把全局性的资源都纳入一个名称空间之下，你的程序与其他应用程序、组件、类库直接发送冲突的可能性就会显著降低。 因为MYAPP.stooge指向的是顶层结构。]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise && Generator && Async]]></title>
    <url>%2F%E5%BC%82%E6%AD%A5.html</url>
    <content type="text"><![CDATA[异步操作回调函数JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字 callback，直译过来就是”重新调用“。 读取文件进行处理，是这样写的: 1234fs.readFile('/etc/passwd', function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码中，readFile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了 /etc/passwd 这个文件以后，回调函数才会执行。 为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象err？ 设计一个回调函数的时候，第一个参数是err，用于优先解决错误，后面再传递参数。 123456fs.readFile(filePath, function(err, data) &#123; if (err) &#123; //handle the error &#125; // use the data object&#125;); 原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。 那么我们可以用Promise来解决回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。 12345fs.readFile(fileA, function (err, data) &#123; fs.readFile(fileB, function (err, data) &#123; // ... &#125;);&#125;); 如果依次读取多个文件，就会出现多重嵌套。代码就横向发展 Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。写法如下。 123456789101112131415var readFile = require('fs-readfile-promise');readFile(fileA).then(function(data)&#123; console.log(data.toString());&#125;).then(function()&#123; return readFile(fileB);&#125;).then(function(data)&#123; console.log(data.toString());&#125;).catch(function(err) &#123; console.log(err);&#125;); 我们会发现一眼看去都是一堆 then，原来的语义变得很不清楚。 那么我们就要用到Generator函数我们可以这样去理解协程: 123456dota2游戏开始了,你开始操刀祈求者--卡尔.这时你妈妈打电话让你赶紧把楼顶的被子和衣服收一下,这时候你很着急.你游戏才玩到一半,但是又不得不去执行你老妈的指令.没办法,你只好敲击F12选择了暂停游戏.紧接着你把被子和衣服收好了,再次敲击F12游戏继续开始.你开始了自己的3杀/4杀/5杀之旅,很舒服. 协程A(游戏开始)开始执行 协程A执行到一半,暂停(敲击F12游戏暂停),执行权交给了协程B(收被子,衣服) (收好后)协程B交还执行权 协程A(敲击F12游戏继续)恢复执行 用代码来说: 12345function play()&#123; //... var f = yield dota2; //...&#125; 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 Generator函数概念Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 1234function* gen(x)&#123; var y = yield x + 2; return y;&#125; 其他的概念可以看我上篇Generator函数概念 Thunk 函数编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。 123456789101112131415function f(m)&#123; return m * 2; &#125;f(x + 5);// 等同于var thunk = function () &#123; return x + 5;&#125;;function f(thunk)&#123; return thunk() * 2;&#125; 上面代码中，函数 f 的参数 被thunk函数替换了. 这就是 Thunk 函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。 终极武器—-Async函数异步编程的最高境界，就是根本不用关心它是不是异步。 async 函数就是隧道尽头的亮光，很多人认为它是异步操作的终极解决方案。 所谓async函数，其实是Generator函数的语法糖。 前文有一个 Generator 函数，依次读取两个文件。 1234567891011121314151617var fs = require('fs');var readFile = function (fileName)&#123; return new Promise(function (resolve, reject)&#123; fs.readFile(fileName, function(error, data)&#123; if (error) reject(error); resolve(data); &#125;); &#125;);&#125;;var gen = function* ()&#123; var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 写成 async 函数，就是下面这样。 123456var asyncReadFile = async function ()&#123; var f1 = await readFile('/etc/fstab'); var f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; 一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。 async 函数的优点async 函数对 Generator 函数的改进，体现在以下三点。 （1）内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。 1var result = asyncReadFile(); (2) 上面的代码调用了asyncReadFile函数,然后他就会自动执行,输出最后的结果.完全不像Generator函数,需要调用next方法,或者co模块,才能得到真正的执行,从而得到最终结果. （3）更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 （4）更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 (5）返回值是Promise，这比Generator函数返回的是Iterator对象方便多了。你可以用then()指定下一步操作。 实现原理async函数的实现就是将Generator函数和自动执行器包装在一个函数中。如下代码： 1234567891011121314151617181920212223242526272829303132async function fn(args) &#123; // ...&#125;// 等同于 function fn(args) &#123; return spawn(function*() &#123; // ... &#125;)&#125;// 自动执行器function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; var gen = genF(); function step(nextF) &#123; try &#123; var next = nextF() &#125; catch(e) &#123; return reject(e) &#125; if (next.done) &#123; return resolve(next.value) &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v) &#125;) &#125;,function(e) &#123; step(function() &#123; return gen.throw(e) &#125;) &#125;) &#125; step(function() &#123; return gen.next(undefined) &#125;) &#125;)&#125; async函数用法（1）async函数返回一个Promise对象，可以是then()方法添加回调函数。（2）当函数执行时，一旦遇到await()就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。 下面是一个延迟输出结果的例子： 12345678910111213function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms) &#125;)&#125;async function asyncPrint(value, ms) &#123; await timeout(ms) console.log(value)&#125;// 延迟500ms后输出 "Hello World!"asyncPrint('Hello World!', 500) Async 后面是一个promise，await 后面也要跟一个promise注意事项（1）await命令后面的Promise对象，运行结果可能是reject，所以最好把await命令放在try...catch代码块中。 （2）await命令只能用在async函数中，用在普通函数中会报错。 （3）ES6将await增加为保留字。如果使用这个词作为标识符，在ES5中是合法的，但是ES6会抛出 SyntaxError（语法错误）。 参考阮一峰 《ES6标准入门》]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Redux和Redux]]></title>
    <url>%2Fredux.html</url>
    <content type="text"><![CDATA[react无法让两个组件互相交流，使用对方数据。 Redux 需要回调通知state（等同于回调参数）-&gt;action 需要根据回调处理（等同于父级方法） -&gt;reducer 需要state(等同于总状态) -&gt;store 现在您只需要记住 reducer 是一个函数，负责更新并返回一个新的state 而 initialState 主要用于前后端同构的数据同步 Action 是把数据从应用传到store的有效载荷。 是store数据的唯一来源 描述发生了什么的普通对象 也可以理解成新闻的摘要-“任务列表里添加了学习Redux文档”。 Store Redux应用中只有一个单一的store 维持应用的state 提供 getState() 获取state 提供dispatch() 更新state 通过subscribe(listener) 注册监听器 通过subscribe(listener) 返回的函数注销监听器. 会把2个参数传入reducer：当前的state树和action。 ReducerReducerreducer就是实现(state,action) -&gt; newState的纯函数. 也就是真正处理state的地方. Redux不希望我们修改老的state ,而且通过直接返回新的state的方式去修改. 永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。 指明根据action更新state。 通俗点讲，就是 reducer 返回啥，state 就被替换成啥 view(React) store(state) action reducer view(React) = 家具的摆放在视觉的效果上 store(state) = 每个家具在空间内的坐标(如：电视的位置是x:10, y: 400) action = 小明分配任务(谁应该干什么) reducer = 具体任务都干些什么(把电视搬到沙发正对面然后靠墙的地方) 所以这个过程应该是这样的： view —&gt; action —&gt; reducer —&gt; store(state) —&gt; view React-Redux Provider是一个普通组件，可以作为顶层app的分发点，它只需要store属性就可以。他会将state分发给所有被connect的组件，不管它在哪里，被嵌套多少层。 connect是真正的重点，它是一个科里化函数，意思是先接受两个参数（数据绑定mapStateToProps和事件绑定mapDispatchToProps），再接受一个参数（将要绑定的组件本身）：mapStateToProps：构建好Redux系统的时候，它会被自动初始化，但是你的React组件并不知道它的存在，因此你需要分拣出你需要的Redux状态，所以你需要绑定一个函数，它的参数是state，简单返回你关心的几个值。 mapDispatchToProps：声明好的action作为回调，也可以被注入到组件里，就是通过这个函数，它的参数是dispatch，通过redux的辅助方法bindActionCreator绑定所有action以及参数的dispatch，就可以作为属性在组件里面作为函数简单使用了，不需要手动dispatch。这个mapDispatchToProps是可选的，如果不传这个参数redux会简单把dispatch作为属性注入给组件，可以手动当做store.dispatch使用。这也是为什么要科里化的原因。 做好以上流程Redux和React就可以工作了。简单地说就是： ​ 1.顶层分发状态，让React组件被动地渲染。 ​ 2.监听事件，事件有权利回到所有状态顶层影响状态。 Redux 与传统后端 MVC 的对照 Redux 传统后端 MVC store 数据库实例 state 数据库中存储的数据 dispatch(action) 用户发起请求 action: { type, payload } type 表示请求的 URL，payload 表示请求的数据 reducer 路由 + 控制器（handler） reducer 中的 switch-case 分支 路由，根据 action.type 路由到对应的控制器 reducer 内部对 state 的处理 控制器对数据库进行增删改操作 reducer 返回 nextState 将修改后的记录写回数据库 总结redux 三个基本原则 整个应用只有唯一一个 Store 实例 State 只能通过触发 Action 来更改 State 的更改 必须写成纯函数(Reducer)，(oldState, action) =&gt; newState，也就是每次更改总是返回一个新的 State redux 两个显著的特点 可预测性（Reducer 是纯函数）。 扩展性强（middleware）。 reducer 可以根据场景分为以下几种: root reducer :根reducer ,作为createStore的第一个参数 slice reducer : 分片reducer,相对根reducer 来说的.用来操作state的一部分数据.多个分片reducer可以合并成一个根reducer. higher-order reducer : 高阶reducer 接受reducer作为函数/返回reducer作为返回的函数. case function: 功能函数,接受指定action后的更新逻辑,可以是简单的reducer函数,也可以接受其他参数. reducer 的最佳实践主要分为以下几个部分 抽离工具函数,以便复用. 抽离功能函数(case function),精简reducer声明部分的代码 根据数据类别拆分,维护多个独立的slice reducer. 合并slice reducer. 通过crossReducer在多个slice reducer中共享数据. 减少reducer的模板代码.]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初入Express]]></title>
    <url>%2FExpress.html</url>
    <content type="text"><![CDATA[expressjs里的请求参数，4.x里只有3种(都引用官方例子) req.params req.body req.query req.params123app.get('/user/:id',function(req,res)&#123; res.send('user' + req.parms.id);&#125;); 就是取带冒号的参数. req.body123456789101112var app = require('express')();var bodyParser = require('body-parser');var multer = require('multer'); app.use(bodyParser.json()); // 用于解析application / jsonapp.use(bodyParser.urlencoded(&#123; extended: true &#125;)); // 用于解析 application/x-www-form-urlencodedapp.use(multer()); // 用于解析多部分/表单数据app.post('/', function (req, res) &#123; console.log(req.body); res.json(req.body);&#125;) req.body一定是post请求.但是在express里面依赖中间件bodyparser,不然req.body都没有. req.query12345678910111213// GET /search?q=tobi+ferretreq.query.q// =&gt; "tobi ferret"// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=conversereq.query.order// =&gt; "desc"req.query.shoe.color// =&gt; "blue"req.query.shoe.type// =&gt; "converse"]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator函数]]></title>
    <url>%2FGenerator.html</url>
    <content type="text"><![CDATA[Generator最大的特点就是定义的函数可以被暂停执行. 作用迭代器 iterator, infinite range, 可以暂停函数, lazy evaluation, 用来实现 async/await 啊, 棒棒哒. async generator/iterator 摘自MDN 生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。 摘自ES6标准入门 可以把它理解成一个状态机,封装了多个内部状态.还是一个遍历器对象生成函数. 123456789function* hi()&#123;yield 'nihao';yield 'hello';return 'ending';&#125;var hw = hi();hw.next();hw.next();hw.next(); 通过gen.next()取得的输出是一个对象，包含value和done两个属性，其中value是真正返回的值，而done则用来标识Generator是否已经执行完毕。因为自然数生成器是一个无限循环，所以不存在done: true的情况。 在Generator函数返回的遍历器对象只有调用next方法才会遍历下一个内部状态,所以yield语句就是暂停标志. yield语句后面的表达式,只有当调用到next方法,内部指针指向该语句时才会执行. 1234function* add()&#123; yield 123+123;&#125;//在上面代码里123+123不去求值.当有next();时,才去求值 每个yield将代码分割成两个部分，需要执行两次next才能执行完。 yield其实由两个动作组成，输入 + 输出（输入在输出前面），每次执行next，代码会暂停在yield 输出执行后，其它的语句不再执行（很重要）。 for…of循环可以自动遍历generator函数,不用去调用next方法. 123456789101112function* foo()&#123; yiled 1; yiled 2; yiled 3; yiled 4; yiled 5; return 6;&#125;for(let v of foo())&#123; console.log(v);&#125;//1 2 3 4 5 Generator函数的数据交换和错误处理next()方法返回值的value属性，是Generator函数向外输出的数据；next()方法还可以接受参数，向Generator函数体内输入数据。 12345678function* gen(x) &#123; var y = yield x + 2; return y;&#125; var g = gen(1);g.next() // &#123; value: 3, done: false &#125;g.next(2) // &#123; value: 2, done: true &#125; Generator函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 123456789101112function* gen(x) &#123; try &#123; var y = yield x + 2 &#125; catch(e) &#123; console.log(e) &#125; return y&#125;var g = gen(1);g.next();g.throw(&apos;出错了&apos;); 上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try...catch 代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2FPromise.html</url>
    <content type="text"><![CDATA[Promise1234new Promise(/* executor */ function(resolve,reject)&#123;...&#125;) executor 函数在Promise构造函数执行时同步执行，被传递resolve和reject函数（executor 函数在Promise构造函数返回新建对象前被调用）。 一个 Promise有以下几种状态: pending: 初始状态，不是成功或失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 Promise对象 Promise是一个构造函数 对象的状态不受外界影响 一旦状态改变就不会再变,任何时候都可以得到这个结果. 状态改变只有两种可能:从Pending 变为Resolved(‘’未完成’’变为’’成功’’将异步操作成功的结果作为参数传递出去) 从Pending变为Rejected(“未完成”变为”失败”将异步操作报出错误的结果作为参数传递出去). Promise原型then()方法MDN的例子1234567891011let p1 = new Promise(function(resolve, reject) &#123; resolve("Success!"); // or // reject ("Error!");&#125;);p1.then(function(value) &#123; console.log(value); // Success!&#125;, function(reason) &#123; console.log(reason); // Error!&#125;); 当我把reject去掉注释 说明p1已经被声明过了,而且状态改变过了就不会在改变了. 我只能把p1 改成别的才能得到Error. 链式例子来自&lt;ES6标准入门&gt; 1234567getJSON("/post/1.json").then(function(post)&#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments)&#123; consloe.log("Resolved:",comments);&#125;,function funcB(err)&#123; consloe.log("Rejected:",err);&#125;); 第一个then方法指定的回调函数返回的是另一个Promise对象.第二个then方法指定的回调函数会等待这个新的Promise对象状态发送变化再进行调用下面的funcA或者funcB函数. catch()方法例子来自&lt;ES6标准入门&gt; catch() 方法返回一个Promise，只处理拒绝的情况。它的行为与调用then()相同。 其实是 .then(null,rejection) 的别名. 1234567p.then((val) =&gt; console.log("fulfilled:", val)) .catch((err) =&gt; console.log("rejected:", err));//等同于p.then((val) =&gt; console.log("fulfilled", val)) .then(null,(err) =&gt; console.log("rejected:", val)); Promise对象的错误具有”冒泡”性质,会一直向后传递,直到被捕获为止.也就是说,错误总是会被下一个catch语句捕获. Promise方法Promise.all()Promise.all(iterable) 方法指当所有在可迭代参数中的 promises 已完成，或者第一个传递的 promise（指 reject）失败时，返回 promise。 1Promise.all(iterable); iterable 一个可迭代对象，例如 Array。参见 iterable. 来自MDN的例子 123456789var p1 = Promise.resolve(3);var p2 = 1337;var p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, "foo");&#125;); Promise.all([p1, p2, p3]).then(values =&gt; &#123; console.log(values); // [3, 1337, "foo"] &#125;); Promise.resolve(value)Promise.reject(reason)Promise.race(iterable)回调函数一个回调函数，也被称为高阶函数，是一个被作为参数传递给另一个函数. 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。 作者：常溪玲链接：https://www.zhihu.com/question/19801131/answer/13005983来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongodb之旅(一)]]></title>
    <url>%2Fmongodb.html</url>
    <content type="text"><![CDATA[Mongodb之旅(一)插入,insertOne/ManyinsertOne( )123db.inventory.insertOne( &#123; item: &quot;canvas&quot;, qty: 100, tags: [&quot;cotton&quot;], size: &#123; h: 28, w: 35.5, uom: &quot;cm&quot; &#125; &#125;) insertMany([ ])12345db.inventory.insertMany([ &#123; item: &quot;journal&quot;, qty: 25, tags: [&quot;blank&quot;, &quot;red&quot;], size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125; &#125;, &#123; item: &quot;mat&quot;, qty: 85, tags: [&quot;gray&quot;], size: &#123; h: 27.9, w: 35.5, uom: &quot;cm&quot; &#125; &#125;, &#123; item: &quot;mousepad&quot;, qty: 25, tags: [&quot;gel&quot;, &quot;blue&quot;], size: &#123; h: 19, w: 22.85, uom: &quot;cm&quot; &#125; &#125;]) 查找,findfind( )1db.inventory.find( &#123;&#125; ) 更新,updateOne/Many$set123456789db.memberplan.update(&#123;_id:&quot;xxx&quot;&#125;,&#123;$set:&#123;tags:[&quot;coats&quot;,&quot;outerwear&quot;]&#125;&#125;) $currentDate,当前时间1234567db.inventory.updateOne( &#123; item: &quot;paper&quot; &#125;, &#123; $set: &#123; &quot;size.uom&quot;: &quot;cm&quot;, status: &quot;P&quot; &#125;, $currentDate: &#123; lastModified: true &#125; &#125;) updateMany1234567db.inventory.updateMany( &#123; &quot;qty&quot;: &#123; $lt: 50 &#125; &#125;, &#123; $set: &#123; &quot;size.uom&quot;: &quot;in&quot;, status: &quot;P&quot; &#125;, $currentDate: &#123; lastModified: true &#125; &#125;)]]></content>
      <categories>
        <category>数据库</category>
        <category>Mongodb</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学Node日志(一)]]></title>
    <url>%2FNode.html</url>
    <content type="text"><![CDATA[学Node日志(一)node实例1234567891011121314const http = require('http');const hostname = '127.0.0.1';const port = 9000;const server = http.createServer((req,res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type','text/plain'); res.end('Hello World\n');&#125;);server.listen(port,hostname, () =&gt; &#123; console.log('服务器运行在 http://$&#123;hostname&#125;:$&#123;port&#125;/');&#125;); response.statusCode()控制响应头刷新时将被发送到客户端的状态码 res.statusCode = 200 状态码 11xx的代码代表请求已被接受，需要继续处理。2xx这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。3xx 重定向。4xx 请求错误。5xx表示服务器错误。 ​ response.setHeader() 响应头如果存在,则值会被覆盖 如果要发送多个名称相同的响应头,则使用字符串数组 res.setHeader(&#39;Content-Type&#39;,&#39;text/plain&#39;) Content-Type表明信息类型,缺省值为” text/plain”.它包含了主要类型（primary type）和次要类型（subtype）两个部分，两者之间用”/“分割. 12345678text/plain：纯文本，文件扩展名.txttext/html：HTML文本，文件扩展名.htm和.htmlimage/jpeg：jpeg格式的图片，文件扩展名.jpgimage/gif：GIF格式的图片，文件扩展名.gifaudio/x-wave：WAVE格式的音频，文件扩展名.wavaudio/mpeg：MP3格式的音频，文件扩展名.mp3video/mpeg：MPEG格式的视频，文件扩展名.mpgapplication/zip：PK-ZIP格式的压缩文件，文件扩展名.zip ​ response.end() 每次响应都必须调用 response.end() 方法. 该方法会通知服务器,所有响应头和响应主体都已被发送,即服务器就将他看成已完成 res.end(&#39;Hello World\n&#39;) Hello World已经被发送. server.listen(port,hostname)开始在指定的 port 和 hostname 上接受连接 端口 端口号是一个 16位的 uint, 所以其范围为 1 to 65535 URL 定义的url格式笼统版本&lt;scheme&gt;:&lt;scheme-specific-part&gt; scheme有我们很熟悉的http、https、ftp，以及著名的ed2k，thunder 通常我们熟悉的url定义成这个样子 1&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt; 用过ftp的估计能体会这么长的，网页上很少带auth信息，所以就精简成这样: 1&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt; 在上面的例子中, scheme=http, host=localhost, port=3000, url-path=/. ​]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基本操作]]></title>
    <url>%2Fgit.html</url>
    <content type="text"><![CDATA[Git addgit add -A 和 git add . 和 git add -u git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。 git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add –update的缩写) git add -A ：是上面两个功能的合集（git add –all的缩写） 自我理解: git add -A 提交所有变化 git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 commit过程 git status 检查工作区是否干净 git add 命令主要用于把我们要提交的文件的信息添加到索引库中。当我们使用git commit时，git将依据索引库中的内容来进行文件的提交。 git commit -am “xxxxxxx” git branch git push origin xxxx 删除分支 git branch -D xx 删除本地分支 git push origin :br (origin 后面有空格) 删除远程分支 解决冲突 git fetch origin cms:new 创建新本地分支new git branch git merge new 合并 git branch -D new 删除本地分支 diff查看自上次提交以来，本地代码改动的具体情况 Git log在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 Git log 命令查看 Git showgit show 查看某次commit的修改内容 Git reset –hard 现在让我们来重置回那次提交的状态： Git rebase对于git rebase, 你亦可以选择进行交互式的rebase。这种方法通常用于在向别处推送提交之前对它们进行重写。交互式rebase提供了一个简单易用的途径让你在和别人 分享提交之前对你的提交进行分割、合并或者重排序。在把从其他开发者处拉取的提交应用到本地时，你也可以使用交互式rebase对它们进行清理。 如果你想在rebase的过程中对一部分提交进行修改，你可以在’git rebase’命令中加入’-i’或’–interactive’参数去调用交互模式。 $ git rebase -i origin/master 这个命令会执行交互式rebase操作，操作对象是那些自最后一次从origin仓库拉取或者向origin推送之后的所有提交。 若想查看一下将被rebase的提交，可以用如下的log命令： $ git log github/master.. git branch -a查看远程分支 masterremotes/origin/HEAD -&gt; origin/masterremotes/origin/Releaseremotes/origin/master git checkout -b myRelease origin/Release切换到 origin/Release分支，并在本地新建分支 myRelease]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习谈业务时所学]]></title>
    <url>%2Fyewu.html</url>
    <content type="text"><![CDATA[一些。。。1.业务员可能都没有理清业务或者需求，需要自己去帮他们理清，好让自己设计开发的产品更健壮和在未来更有扩展性。]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多说挂了好久。现在换成来必力]]></title>
    <url>%2F%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%E8%BF%81%E7%A7%BB.html</url>
    <content type="text"><![CDATA[多说已挂，将评论迁移到来必力有很多可替代的方案 网易云跟帖 畅言 友言 Disqus 来必力 还有许多评论功能就不一一举例了. 具体说下该如何迁移因为我是hexo搭建的博客，然后我用的主题是next。 打开来必力官网，注册完毕。 登陆后我们来到管理页面。 之后再点击代码管理，我们将会看见一堆代码。 我们在代码中找到data-uid：“xxxxxxxxxx”。 这段将是我们要用的uid。 打开主题文件下的_config.yml我们 livere_uid: #your livere_uid 之后hexo clean &amp;&amp; hexo g -d即可]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库E-R图]]></title>
    <url>%2FE-R%E5%9B%BE.html</url>
    <content type="text"><![CDATA[E-R图E-R图是指实体-关系-属性三个基本概括数据的基本结构. 强调ER模型设计的两大内容：一是将需求通过ER表达，另一个是将ER转换为关系模型。ER图是从实践归纳出来的理论方法，可以重新指导实践行为，既可以作为理解和表达用户数据需求的手段，同时也构成如何生成关系模型的依据。 ER图的实体（entity）即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示，每个实体都有自己的实体成员（entity member）或者说实体对象（entity instance），例如学生实体里包括张三、李四等，实体成员（entity member）/实体实例（entity instance） 不需要出现在ER图中。 ER图的属性（attribute）即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性，用椭圆形表示，属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。 ER图的关系（relationship）用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系，关系用菱形来表示。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Router v3]]></title>
    <url>%2FReact-Router.html</url>
    <content type="text"><![CDATA[React-Router3路径语法路由路径是匹配一个（或一部分）URL 的 一个字符串模式。大部分的路由路径都可以直接按照字面量理解，除了以下几个特殊的符号： :paramName – 匹配一段位于 /、? 或 # 之后的 URL。 命中的部分将被作为一个参数 () – 在它内部的内容被认为是可选的 * – 匹配任意字符（非贪婪的）直到命中下一个字符或者整个 URL 的末尾，并创建一个 splat 参数 12345678910//匹配 /hello/michael 和 /hello/ryan&lt;Route path=&quot;/hello/:name&quot;&gt; //匹配 /hello, /hello/02 和 /hello/01&lt;Route path=&quot;/hello(/:id)&quot;&gt; //匹配 /files/hello.jpg和/files/path/to/hello.jpg&lt;Route path=&quot;/files/*.*&quot;&gt; Histories常用的 history 有三种形式， 但是你也可以使用 React Router 实现自定义的 history。 browserHistory (推荐) hashHistory createMemoryHistory 1&lt;Router history=&#123;browserHistory&#125;&gt; browserHistoryBrowser history 是使用 React Router 的应用推荐的 history。它使用浏览器中的 History API 用于处理 URL，创建一个像example.com/some/path这样真实的 URL 。 在组件外部使用导航虽然在组件内部可以使用 this.context.router 来实现导航，但许多应用想要在组件外部使用导航。使用Router组件上被赋予的history可以在组件外部实现导航。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GraphQL基本操作]]></title>
    <url>%2FGraphQL.html</url>
    <content type="text"><![CDATA[GraphQL()强类型 也就是说，你可以查询值类型：Int, Float, String, Boolean和ID GraphQL不是像MySQL或Redis这样直接面向数据的接口，而是面向你已经存在的应用代码的接口。 你可以把GraphQL看作是为了调用应用服务器上的方法的一些内嵌的RPC。 操作(operation)操作（Operations） GraphQL 规范支持两种操作： query：仅获取数据（fetch）的只读请求 mutation：获取数据后还有写操作的请求 123456query&#123; clent(id:1)&#123; id name &#125;&#125; client 是查询的operation (id:1)包含了传入给Query的参数 查询包含id和name字段,这些字段也是我们希望查询可以返回的. server会给这个查询返回什么： 12345678&#123; "data": &#123; "client": &#123; "id": "1", "name": "Uncle Charlie" &#125; &#125;&#125; server会返回一个JSON串。这个JSON的schema和查询的基本一致。 变量(Variable)1234567891011121314151617181920212223query($clientId: Int) &#123; client(id: $clientId) &#123; name dob &#125; purchases(client_id: $clientId) &#123; date quantity total product &#123; name price product_category &#123; name &#125; &#125; client &#123; name dob &#125; &#125;&#125; 123&#123; "clientId": 1&#125; Graphql的schema下1234567schema&#123; query: Query, mutation: Mutation,&#125; Mutation（修改）增、删、改一类的operation在GraphQL里统称为变异（mutation，即修改数据） GraphQL中将对数据的修改操作称为 mutation。在 GraphQL Schema 中按照如下形式来定义一个 mutation： mutation 查询和普通查询请求（query）的重要区别在于 mutation 操作是序列化执行的。例如 GraphQL 规范中给出的示例，服务器一定会序列化处理下面的 mutation 请求： 请求结束时 theNumber 的值会是 2。 create_client增加 12345678910mutation &#123; create_client ( name: "查理大叔" dob: "2017/01/28" ) &#123; id name dob &#125;&#125; update_client更新 12345678910mutation &#123; update_client ( id: 5 dob: "1990/01/01" ) &#123; id name dob &#125;&#125; destroy_client删除 123456mutation &#123; destroy_client(id: 5) &#123; name dob &#125;&#125; 修改数据就像Rest以PUT／POST约定为修改服务器端数据一样，Mutations操作在GraphQL的意义就是修改数据库。就像官网中的例子： 12345678910111213mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123; //!表示必须填写的查询条件 createReview(episode: $ep, review: $review) &#123; stars commentary &#125;&#125;&#123; &quot;ep&quot;: &quot;JEDI&quot;, &quot;review&quot;: &#123; &quot;stars&quot;: 5, &quot;commentary&quot;: &quot;This is a great movie!&quot; &#125;&#125; 需要注意的是，为了保证mutation操作不冲突，mutation只能序列执行。而query可以并行。 强类型由于 GraphQL 是一个强类型语言，所以它可以在执行查询之前检查每个查询语句是否满足事先设定的 schema，符合则合法，如果查询语句不合法则不进行查询。 Fragments(组合)GraphQL 可以组合使用查询。比如可以定义一种叫 fragment 的东西，就是查询片断，然后我们可以在不同的地方重复的去使用查询。比如下面的这个例子： 1234567891011&#123; me &#123; name friends &#123; name events &#123; name &#125; &#125; &#125;&#125; 可以转换成这样： 123456789101112131415&#123; me &#123; name friends &#123; ...firendFragment &#125; &#125;&#125;fragment friendFragment on User &#123; name events &#123; name &#125;&#125; 上面定义了一个叫 friendFragment 的查询片断，它返回用户朋友的名字，还有参加的活动的名字，然后我们可以在其它的查询里面使用这个查询片断。 简单的说，GraphQL 是一种描述请求数据方法的语法，通常用于客户端从服务端加载数据。GraphQL 有以下三个主要特征： 它允许客户端指定具体所需的数据。 它让从多个数据源汇总取数据变得更简单。 它使用了类型系统来描述数据。 一个 GraphQL API 主要由三个部分组成：schema（类型），queries（查询） 以及 resolvers（解析器）。 Arguments(参数)123456&#123; human(id: "1000") &#123; name height &#125;&#125; 12345678&#123; "data": &#123; "human": &#123; "name": "Luke Skywalker", "height": 1.72 &#125; &#125;&#125; 当然在字段里我们也可以传参数. 123456&#123; human(id: "1000") &#123; name height(unit: FOOT//or METER) &#125;&#125; 12345678&#123; "data": &#123; "human": &#123; "name": "Luke Skywalker", "height": 5.6430448 // or 1.72 &#125; &#125;&#125; Aliases(别名)12345678&#123; empireHero: hero(episode: EMPIRE) &#123; name &#125; jediHero: hero(episode: JEDI) &#123; name &#125;&#125; 12345678910&#123; "data": &#123; "empireHero": &#123; "name": "Luke Skywalker" &#125;, "jediHero": &#123; "name": "R2-D2" &#125; &#125;&#125; Variables(变量)当我们开始使用变量的时候,我们需要做三件事情 Replace the static value in the query with $variableName Declare $variableName as one of the variables accepted by the query Pass variableName: value in the separate, transport-specific (usually JSON) variables dictionary 用$ 替换查询中的静态值 将$ 声明为查询接受变量之一 通常传递json. 123456789101112131415161718queryHeroNameAndFriends( $episode: Episode, )&#123; hero( episode: $episode)&#123; name friends&#123; name &#125; &#125;&#125;//variables&#123; "episode": "JEDI"&#125; 123456789101112131415161718&#123; "data": &#123; "hero": &#123; "name": "R2-D2", "friends": [ &#123; "name": "Luke Skywalker" &#125;, &#123; "name": "Han Solo" &#125;, &#123; "name": "Leia Organa" &#125; ] &#125; &#125;&#125; fieldsFields就是客户端要求GraphQL返回的数据说明，一个Fields也可以包含参数 Root fields &amp; resolvers1234567Query: &#123; human(obj, args, context) &#123; return context.db.loadHumanByID(args.id).then( userData =&gt; new Human(userData) ) &#125;&#125; obj上一个对象，其对于根查询类型的字段通常不被使用 args提供给GraphQL查询中的字段的参数。 context提供给每个解析器并保存重要的上下文信息（如当前登录的用户）或访问数据库的值。]]></content>
      <categories>
        <category>GraphQL</category>
      </categories>
      <tags>
        <tag>GraphQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React State与Props的小心思]]></title>
    <url>%2FReact-State%E4%B8%8EProps%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D.html</url>
    <content type="text"><![CDATA[忙于期末考。。很久都没有更新博客了！因为找了个实习需要React所以这里写写自己在看React的官方文档中，遇到的问题。 Props与State很容易让我经常弄混先来说说Props 官方解释 组件从概念上看就是函数，之后这个组件可以接受任意的输入值，并返回一个需要页面上展示的React元素。那么这个输入值就为props。 个人理解 props是不可变的，传入什么值进去，最后返回的也是传入的值。也就是说，只读。 props父子传递12345678910111213141516function Uesr(props)&#123; return( &lt;div className=&#123;'abc'+ props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; );&#125;------------------------------------------------------------------------ function My()&#123; return( &lt;User color="red"&gt; &lt;h1&gt;nihao&lt;/h1&gt; &lt;/User&gt; );&#125; 在JSX标签内的任何内容都将通过children属性传入User。因为User在一个div内渲染了{props.children}，所以被传递的所有元素都会出现在最终输出中。 其实，我们也可以不用children。借用React官方文档的例子： 1234567891011121314151617181920212223242526272829303132function Contacts() &#123; return &lt;div className="Contacts" /&gt;;&#125;function Chat() &#123; return &lt;div className="Chat" /&gt;;&#125;function SplitPane(props) &#123; return ( &lt;div className="SplitPane"&gt; &lt;div className="SplitPane-left"&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className="SplitPane-right"&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; );&#125; 接下来Statestate怎么工作？通过调用setState(data,callback)方法，改变状态，就会触发React更新UI。 什么时候组件需要state呢？一般来说，大部分的组件应该从props属性中获取数据然后渲染。那么在！ 用户输入，服务器交互，这些情况下会用到State。在官方上说，尽可能的保持你的组件无状态化。 通过看官方文档。。我发现他们的模式是：构建几个无状态的组件用来渲染数据，然后在这些之上去构建一个有状态的组件同用户和服务器交互，数据通过props传递给无状态组件。 setState:更新组件状态。 setState会触发diff算法：判断state和页面结果的区别，是否需要更新。 状态(state)和属性(props)对比 状态和属性都会触发render更新，都是纯JS对象 状态：是和自己相关的，既不受父组件也不受子组件影响 属性：本身是不能自己去修改的，只能从父组件获取属性，父组件也能修改它的属性 根本的区别：组件在运行时需要去修改维护的就是状态]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript闭包]]></title>
    <url>%2FJavaScript%E9%97%AD%E5%8C%85.html</url>
    <content type="text"><![CDATA[闭包/bibao/Closures什么是闭包MDN对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 阮老师对闭包的定义为： 闭包就是能够读取其他函数内部变量的函数。 可以把闭包简单理解成”定义在一个函数内部的函数”。 红宝书对闭包的定义为： 闭包是指有权访问另一个函数作用域中的变量的函数 那么圣经犀牛书对闭包定义为： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为‘闭包’” 我个人比较认同红宝书的定义。 12345678function foo()&#123; var a = 2; function bar()&#123; console.log(a); // 2 &#125; bar();&#125;foo(); 我们来做一个数组求和 123456function sum(arr)&#123; return arr.reduce(function(x,y)&#123; return x+y; &#125;);&#125;sum([3,4,5,6]); //18 但是我们想要返回函数 12345678function smallsum(arr)&#123; var sum = function()&#123; return arr.reduce(function(x,y)&#123; return x+y; &#125;); &#125; return sum;&#125; 当我们想要用smallsum的时候返回的却是个函数。 1var result = smallsum([3,4,5,6]); //function sum() 直到我们调用result 1result(); //18 在这个例子中，我发现内部函数sum可以调用外部函数smallsum的参数和局部变量。 当我们调用smallsum的时候，每次调用都会产生一个新的函数。即使你传入的值相同。 123var result1 = smallsum([3,4,5,6]);var result2 = smallsum([3,4,5,6]);result1 === result2; //false 假如123456789function l()&#123; var arr= []; for(var i=0;i&lt;4;i++)&#123; arr.push(function()&#123; return i; &#125;); &#125; return arr;&#125; 12345678var a= l();var f1=a[0];var f2=a[1];var f3=a[2];f1(); //4f2(); //4f3(); //4 12345678910111213141516171819function l()&#123; var arr= []; for(var i=0;i&lt;4;i++)&#123; arr.push((function(n)&#123; return function()&#123; return n; &#125; &#125;)(i)); &#125; return arr;&#125;var a= l();var f1=a[0];var f2=a[1];var f3=a[2];f1(); //0f2(); //1f3(); //2 注意这里用了一个“创建一个匿名函数并立刻执行”的语法： 123(function (n) &#123; return n;&#125;)(1); //1 总结可能上面的例子都不够很清晰 12345678910111213141516function a() &#123; var b = 1; function c()&#123; console.log(b++); &#125; return c;&#125;var d1 = a();var d2 = a();d1(); //1d1(); //2d2(); //1d2(); //2 也就是说他们都会去创建一个属于自己的执行环境！ok一切明了。]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript作用域与作用域链]]></title>
    <url>%2FJavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F.html</url>
    <content type="text"><![CDATA[Javascript作用域与作用域链作用域简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。 变量作用域全局变量拥有全局作用域。在JavaScript任何地方都是有定义的。123456var l="我是全局变量"; //声明了一个全局变量function scope()&#123; var l="我是局部变量"; //声明了一个同名的局部变量 return l;&#125;scope() //输出“我是局部变量” 在函数内声明变量前不加var就是一个全局变量。 123456789var l="我是全局变量";function scope()&#123; l="我还是全局变量"; //改变了全局变量 m="我是一个新的全局变量"; //声明了一个新的全局变量 return [l,m];&#125;scope() //输出"我是一个新的全局变量"lm 在函数内声明的变量只在函数内有定义，它们是局部变量，作用域是局部性的。12345678910var l="我是全局变量";function scope()&#123; var l="我是局部变量"; function scope1()&#123; var l="我是一个新的局部变量"; //嵌套作用域内的局部变量 return l; //返回当前作用域内的值 &#125; return scope1();&#125;scope(); //嵌套作用域 函数作用域和声明提前函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。只是改变函数内部。 变量在声明它们的函数体以及这个函数体嵌套的任意的函数体内都是有定义的。 123456function func() &#123; console.log(num); //输出：undefined，而非报错，因为变量num在整个函数体内都是有定义的 var num = 1; //声明num 在整个函数体func内都有定义 console.log(num); //输出：1 &#125; func(); 再看看下面这个例子： 123456789var num=2;function func() &#123; var num; console.log(num); //输出：undefined，而非报错，因为变量num在整个函数体内都是有定义的 var num = 1; //声明num 在整个函数体func内都有定义 console.log(num); //输出：1 &#125; console.log(num); //输出2 func(); 作用域链用途： 保证对执行环境有权访问的所有变量和函数的有序访问。 作用域链上有两个对象。 第一个是定义函数参数和局部变量的对象 第二个是全局对象 当定义一个函数时，它实际上保存一个作用域链。 高程三下这个例子就特别好 1234567891011121314var color = "blue";function changeColor()&#123; var anotherColor = "red"; function swapColors()&#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; //能访问 color、anotherColor、tempColor。 &#125; swapColors(); //能访问color、anotherColor不能访问tempColor。&#125;changeColor(); //只能访问color changeColor()的作用域链中只包含2个对象：它自己的变量对象和全局变量对象。所以它不能访问swapColor()的环境。 那么在swapColors()的作用域链中又3个对象：swapColors()的变量对象、changeColor()的变量对象和全局变量对象。]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript——16道算法题]]></title>
    <url>%2FJavaScript%E2%80%94%E2%80%9416%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[Let‘s go1.Reverse a String翻转字符串 先把字符串转化成数组，再借助数组的reverse方法翻转数组顺序，最后把数组转化成字符串。 你的结果必须得是一个字符串 这是一些对你有帮助的资源: Global String Object String.split() Array.reverse() Array.join() reverseString(&quot;hello&quot;) 应该返回 &quot;olleh&quot;. 1234function reverseString(str) &#123; return str.split('').reverse().join('');&#125;reverseString("hello"); 2.Factorialize a Number计算一个整数的阶乘 如果用字母n来代表一个整数，阶乘代表着所有小于或等于n的整数的乘积。 阶乘通常简写成 n! 例如: 5! = 1 * 2 * 3 * 4 * 5 = 120 这是一些对你有帮助的资源: Arithmetic Operators factorialize(5) 应该返回 120. 12345678910function factorialize(num) &#123; if(num&lt;0)&#123; return -1; &#125;else if(num ===0||num===1)&#123; return 1; &#125;else&#123; return (num*factorialize(num-1)); &#125;&#125;factorialize(5); 3.Check for Palindromes如果给定的字符串是回文，返回true，反之，返回false。 如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)。 注意你需要去掉字符串多余的标点符号和空格，然后把字符串转化成小写来验证此字符串是否为回文。 函数参数的值可以为&quot;racecar&quot;，&quot;RaceCar&quot;和&quot;race CAR&quot;。 这是一些对你有帮助的资源: String.replace() String.toLowerCase() palindrome(&quot;race car&quot;) 应该返回 true. palindrome(&quot;not a palindrome&quot;) 应该返回 false. 123456789101112function palindrome(str) &#123; // Good luck! var re = /[\W_]/g; var slo=str.toLowerCase().replace(re,""); var slow=slo.split('').reverse().join(''); if(slo==slow)&#123; return true;&#125; else&#123; return false; &#125;&#125;palindrome("我爱你"); 4.Find the Longest Word in a String找到提供的句子中最长的单词，并计算它的长度。 函数的返回值应该是一个数字。 这是一些对你有帮助的资源: String.split() String.length findLongestWord(&quot;The quick brown fox jumped over the lazy dog&quot;) 应该返回 6. 123456789101112function findLongestWord(str) &#123; var arr=str.split(' '); var long=0; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i].length&gt;long)&#123; long=arr[i].length; &#125; &#125; return long;&#125;findLongestWord("The quick brown fox jumped over the lazy dog"); 5.Title Case a Sentence确保字符串的每个单词首字母都大写，其余部分小写。 像’the’和’of’这样的连接符同理。 这是一些对你有帮助的资源: String.split titleCase(&quot;I&#39;m a little tea pot&quot;) 应该返回 “I’m A Little Tea Pot”. 1234567891011function titleCase(str) &#123; var arr=str.toLowerCase().split(' '); var l=[]; for(var i=0;i&lt;arr.length;i++)&#123; var str1=arr[i].slice(0,1).toUpperCase()+arr[i].slice(1); l.push(str1); &#125; return l.join(' ');&#125;titleCase("I'm a little tea pot"); 首先我们需要把这个字符串的每一项都变成小写字母并转换成数组 创建一个保存新的空数组 用遍历数组的长度。之后我们把每一项数组的第一个字母用slice()变成大写。 再push到空的数组里。 最后用join()数组返回字符串。 6.Return Largest Numbers in Arrays右边大数组中包含了4个小数组，分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新数组。 提示：你可以用for循环来迭代数组，并通过arr[i]的方式来访问数组的每个元素。 这是一些对你有帮助的资源: Comparison Operators largestOfFour([[13, 27, 18, 26], [4, 5, 1, 3], [32, 35, 37, 39], [1000, 1001, 857, 1]]) 应该返回 [27,5,39,1001]. 第一种方法1234567891011function largestOfFour(arr) &#123; // You can do this! var l=[]; for(var i=0;i&lt;arr.length;i++)&#123; arr[i].sort(function(a,b)&#123;return b-a&#125;); &#125; l.push(arr[i][0]);&#125;return l;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); 第二种方法 123456789101112function largestOfFour(arr) &#123; // You can do this! var temp = []; for(var i = 0; i &lt; arr.length; i++)&#123; var l = arr[i].reduce(function(prev,cur,index,array)&#123; return prev &gt; cur ? prev : cur; &#125;); temp.push(l); &#125; return temp;&#125;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[前端面试题题目来自朴灵大大的github 介绍JavaScript的基本数据类型JavaScript有5种简单数据类型： Undefined、Null、Boolean、Number、String。还有一种复杂数据类型Object。 typeof操作符用typeof操作符能检测给定变量的数据类型。（括号中是自己的理解意思） “undefined” ————这个值没有被定义。（这个变量存在但是没有给它值） “boolean” ————这个值是布尔值。（这个值有true或false输出） “string” ————这个值是字符串。（字符串或字符序列） “number” ————这个值是数值。（字面意思） “object” ————这个值是对象或null。(这个值可能是个对象或者空) “function” ————这个值是函数。(字面意思) 12var message="wa";alert(typeof wa); //string Undefined类型使用var声明变量但没有给它加以初始化，这个变量的值就是undefined。 12var message;alert(message == undefined); //true Null类型null表示一个空对象指针，但是用typeof操作符检测null会返回object的原因是什么？ 12var car =null;alert("typeof car"); //"object" 只要意在保存对象的变量还没有真正的保存对象，就应该明确地让该变量保存null值。这样有助于进一步区分null和undefined。 Boolean类型这个字母值就是true、false。但是这两个值和数字不是一回事情。所以 true不一定等于 1 ， false不一定等于 0 。 还有布尔值是区分大小的 True和 False都不是 Boolean值。 Number类型 浮点数值 数值范围 最小值保存在Number.MIN_VALUE ： 5e-324。 保存着-Infinity 最大值保存在Number.MAX_VALUE : 1.796931348623157e+308。保存着Infinity。 想确定一个数值是否有穷可以用isFinite()函数。这个函数会在最小和最大数值之间会返回 true。 1alert(isFinite(result)); NaN（Not a Number） 任何涉及NaN的操作（NaN/10）都会返回 NaN。 还有 NaN与任何值都不想等，包括 NaN本身。 实际上0除以0才会返回 NaN，正数除以0返回 Infinity，负数除以0返回 -Infinity。 isNaN()函数可以确定这个函数是否不是数值。这个函数在收到一个值后会去尝试将转换为数值。不能被转换就返回true。 数值转换 三个函数 可以 把非数值转换为数值。 Number() 可以用于任何数据类型 parseInt() 字符串转换成数值 parseFloat() 字符串转换成数值 String类型由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以用双引号（”）或单引号（’）表示。 字符字面量——转义序列 （\n 换行 ​ \t 制表···） 字符串的特点——字符串是不可改变的。一旦创建，它们的值就不能改变。要改变就要先摧毁。 12var lang="Java";lang=lang+"Script"; 转换为字符串 使用 toString()方法 但是null和undefined没有这个方法所以， 就使用String()方法 Object类型对象其实就是一组数据和功能的集合。 1var o =new Object(); 说说写JavaScript的基本规范？]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js小记]]></title>
    <url>%2FVue.js%E5%B0%8F%E8%AE%B0.html</url>
    <content type="text"><![CDATA[#Vue小记 v-bind 缩写： ： 修饰符 .prop - 被用于绑定DOM属性 .camel 用法 动态的绑定一个或多个特性，或一个组件prop到表达式 1&lt;a v-bind:href="url" href="#"&gt;&lt;/a&gt; 在这里:href是参数，通过v-bind指令将该元素的href属性与表达式的url绑定。 v-if1&lt;p v-if="seen"&gt;Now you see me&lt;/p&gt; 这个v-if指令将判断seen的真假值来移出/插入&lt;p&gt;元素。 v-on 缩写：@ 1&lt;a v-on:click="doSomething"&gt; 这个指令是用来监听DOM事件。 事件修饰符 .stop .prevent .capture .self .once 12345678910111213141516&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;2.1.4新增&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once="doThis"&gt;&lt;/a&gt; 按键修饰符1234567&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13="submit"&gt;记住keyCode各种值很难所以提供了别名&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt; .enter .tab .delete(捕获“删除”和“退格”按键) .esc .space .up .down .left .right 2.1.0新增 .ctrl .alt .shift .meta(Mac上为(⌘)在windows上为(⊞)) v-for我们用 v-for 指令根据一组数组的选项列表进行渲染。 v-for 指令需要以 item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名。 12345&lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789var example1 = new Vue(&#123; el: '#example-1', data: &#123; items: [ &#123;message: 'Foo' &#125;, &#123;message: 'Bar' &#125; ] &#125;&#125;) 结果： Foo Bar v-model你可以用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。 具体看]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6箭头函数]]></title>
    <url>%2FEs6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0.html</url>
    <content type="text"><![CDATA[简单地说， 12345var a = x =&gt; x;//var a =function(x)&#123; return x;&#125;; 这个就是最简单的箭头函数。 接着如果箭头函数不需要参数或者多个参数的话， 1234567var a = () =&gt; 1;//var a =function()&#123; return 1;&#125;;或者var a = _ =&gt;1; 12345var sum = (num1,num2) =&gt;num1 +num2;//var sum =function(num1,num2)&#123; return num1+num2;&#125;; 箭头函数没有自己的this， 123456(function ()&#123; return [ (()=&gt; this.x).bind(&#123;x :'inner'&#125;)() ]&#125;).call(&#123;x :'outer'&#125;);//['outer'] 所以bind的方法无效。并且call(),apply(),也无效。 MDN上的 1234567891011121314151617181920var adder = &#123; base : 1, add : function(a) &#123; var f = v =&gt; v + this.base; return f(a); &#125;, addThruCall: function(a) &#123; var f = v =&gt; v + this.base; var b = &#123; base : 2 &#125;; return f.call(b, a); &#125;&#125;;console.log(adder.add(1)); // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注）]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初入React+Webpack(入门)]]></title>
    <url>%2F%E5%88%9D%E5%85%A5React.html</url>
    <content type="text"><![CDATA[因为需要做一个自己的小想法以后需要去实现把这个想法变成项目，在重多得框架中选择React.js，因为它需要学习成本，所以我觉得我在学习的过程中能学到很多东西。 通过npm使用React建议在 React 中使用 CommonJS 模块系统，比如 browserify 或 webpack。使用 react 和 react-dom npm 包. 我使用webpack来安装React DOM的 12$ npm install --save react react-dom babelify babel-preset-react$ browserify -t [ babelify --presets [ react ] ] main.js -o bundle.js 那么第一步肯定是创建Hello World啦~ 我们需要创建一个helloworld.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Hello React!&lt;/title&gt; &lt;script src="build/react.js"&gt;&lt;/script&gt; &lt;script src="build/react-dom.js"&gt;&lt;/script&gt; &lt;script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在代码中 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); 这是jsx语法。可以去 JSX 语法 里学习更多 JSX 相关的知识。为了把 JSX 转成标准的 JavaScript，我们用 &lt;script type=&quot;text/babel&quot;&gt; 标签，并引入 Babel 来完成在浏览器里的代码转换。在浏览器里打开这个html，你应该可以看到成功的消息！ 分离文件那么我们在React中也是可以分离js的。 我们需要创建一个下面的build/helloworld.js 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example')); 之后我们在html的文件中像以前引用文件一样去引用就可以了。 1&lt;script type="text/babel" src="src/helloworld.js"&gt;&lt;/script&gt; 但是我是用chrome不会显示效果。之后我用safari效果成功显示，后来打开控制台发现http以外的协议加载失败了。读取不了&lt;script src=&quot;https://npmcdn.com/babel-core@5.8.38/browser.min.js&quot;&gt;&lt;/script&gt;那么就我就去跟着开发文档配置了babel。 BabelBabel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看：Babel Webpack(入门)webpack是什么？webpack是一个模块化打包工具，使用js作为载体将所有静态资源打包在一起，支持的loader和plugin等能对各种静态资源进行预处理，极大地方便了前端的工程化开发。详情参考官网 ###开始使用Webpack我们来一步一步去开始学习使用Webpack。 ###安装Webpack可以使用npm安装，新建一个空白的文件夹（我的为webpackwhat），在终端中转到该文件夹下（cd webpackwhat）进行安装。 1234//全局安装npm install -g webpack//安装到你的项目目录npm install --save-dev webpack 我们在终端中使用npm init的命令可以自动创建这个package.json文件 1npm init 输入后，会有一些需要你输入的信息，你只需要一直回车就行了。 接下来我们在这个文件夹下进行安装Webpack作为依赖包 12//安装Webpacknpm install --save-dev webpack 回到之前的空文件夹，并在里面创建两个文件夹,app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放准备给浏览器读取的数据（包括使用webpack生成的打包后的js文件以及一个index.html文件）。在这里还需要创建三个文件，index.html 文件放在public文件夹中，两个js文件（Greeter.js和main.js）放在app文件夹中. index.html文件只有最基础的html代码，它唯一的目的就是加载打包后的js文件（bundle.js） 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='root'&gt; &lt;/div&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Greeter.js只包括一个用来返回包含问候信息的html元素的函数。 123//main.js var greeter = require(&apos;./Greeter.js&apos;);document.getElementById(&apos;root&apos;).appendChild(greeter()); main.js用来把Greeter模块返回的节点插入页面。 123456// Greeter.jsmodule.exports = function() &#123; var greet = document.createElement(&apos;div&apos;); greet.textContent = &quot;Hi there and greetings!&quot;; return greet;&#125;; 正式使用Webpack12//webpack非全局安装的情况node_modules/.bin/webpack app/main.js public/bundle.js 可以看出webpack同时编译了main.js 和Greeter,js,现在打开index.html,可以看到如下结果 通过配置文件来使用WebpackWebpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如已经提到的，这样不太方便且容易出错的，一个更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，可以把所有的与构建相关的信息放在里面。 还是继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，并在其中进行最最简单的配置，如下所示，它包含入口文件路径和存放打包后文件的地方的路径。 1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 更快捷的执行打包任务执行类似于node_modules/.bin/webpack这样的命令其实是比较烦人且容易出错的，不过值得庆幸的是npm可以引导任务执行，对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可，设置方法如下。 12345678910111213&#123; &quot;name&quot;: &quot;webpack-sample-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Sample webpack project&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令 &#125;, &quot;author&quot;: &quot;zhang&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^1.12.9&quot; &#125;&#125; 注：package.json中的脚本部分已经默认在命令前添加了node_modules/.bin路径，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。 npm的start是一个特殊的脚本名称，它的特殊性表现在，在命令行中使用npm start就可以执行相关命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build Loaders鼎鼎大名的Loaders登场了！ Loaders是webpack中最让人激动人心的功能之一了。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。 Loaders需要单独安装并且需要在webpack.config.js下的modules关键字下进行配置，Loaders的配置选项包括以下几方面： test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 继续上面的例子，我们把Greeter.js里的问候消息放在一个单独的JSON文件里,并通过合适的配置使Greeter.js可以读取该JSON文件的值，配置方法如下 12//安装可以装换JSON的loadernpm install --save-dev json-loader 12345678910111213141516171819202122232425module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123;//在配置文件里添加JSON loader loaders: [ &#123; test: /\.json$/, loader: &quot;json&quot; &#125; ] &#125;, devServer: &#123; contentBase: &quot;./public&quot;, colors: true, historyApiFallback: true, inline: true &#125;&#125; 创建带有问候信息的JSON文件(命名为config.json) 1234//config.json&#123; &quot;greetText&quot;: &quot;Hi there and greetings from JSON!&quot;&#125; 更新后的Greeter.js 1234567var config = require(&apos;./config.json&apos;);module.exports = function() &#123; var greet = document.createElement(&apos;div&apos;); greet.textContent = config.greetText; return greet;&#125;; Loaders很好，不过有的Loaders使用起来比较复杂，比如说Babel。 BabelBabel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过编译帮你达到以下目的： 下一代的JavaScript标准（ES6，ES7），这些标准目前并未被当前的浏览器完全的支持； 使用基于JavaScript进行了拓展的语言，比如React的JSX Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，不过webpack把它们整合在一起使用，但是对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包）。 我们先来一次性安装这些依赖包 12// npm一次性安装多个依赖模块，模块之间用空格隔开npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react 在webpack中配置Babel的方法如下 123456789101112131415161718192021222324252627282930313233module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json-loaders&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loaders&apos;,//在webpack的module部分的loaders里进行配置即可 query: &#123; presets: [&apos;es2015&apos;,&apos;react&apos;] &#125; &#125; ] &#125;, devServer: &#123; contentBase: &quot;./public&quot;, colors: true, historyApiFallback: true, inline: true &#125;&#125; 现在你的webpack的配置已经允许你使用ES6以及JSX的语法了。继续用上面的例子进行测试，不过这次我们会使用React，记得先安装 React 和 React-DOM 1npm install --save react react-dom 使用ES6的语法，更新Greeter.js并返回一个React组件 123456789101112131415//Greeter,jsimport React, &#123;Component&#125; from &apos;react&apos;import config from &apos;./config.json&apos;;class Greeter extends Component&#123; render() &#123; return ( &lt;div&gt; &#123;config.greetText&#125; &lt;/div&gt; ); &#125;&#125;export default Greeter 使用ES6的模块定义和渲染Greeter模块 12345import React from &apos;react&apos;;import &#123;render&#125; from &apos;react-dom&apos;;import Greeter from &apos;./Greeter&apos;;render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;)); Babel的配置选项Babel其实可以完全在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下： 1234567891011121314151617181920212223242526// webpack.config.jsmodule.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json-loaders&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loaders&apos; &#125; ] &#125;, devServer: &#123;...&#125; // Omitted for brevity&#125; 1234//.babelrc&#123; &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;]&#125; 到目前为止，我们已经知道了，对于模块，Webpack能提供非常强大的处理功能，那那些是模块呢。 CSSwebpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(...)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。 继续上面的例子 12//安装npm install --save-dev style-loader css-loader 123456789101112131415161718192021222324252627282930//使用module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/build&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json-loaders&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loaders&apos; &#125;, &#123; test: /\.css$/, loader: &apos;style-loaders!css-loaders&apos;//添加对样式表的处理 &#125; ] &#125;, devServer: &#123;...&#125;&#125; 注：感叹号的作用在于使同一文件能够使用不同类型的loader 接下来，在app文件夹里创建一个名字为”main.css”的文件，对一些元素设置样式 12345678910111213141516171819html &#123; box-sizing: border-box; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125;body &#123; margin: 0; font-family: &apos;Helvetica Neue&apos;, Helvetica, Arial, sans-serif;&#125;h1, h2, h3, h4, h5, h6, p, ul &#123; margin: 0; padding: 0;&#125; 你还记得吗？webpack只有单一的入口，其它的模块需要通过 import, require, url等导入相关位置，为了让webpack能找到”main.css“文件，我们把它导入”main.js “中，如下 12345678//main.jsimport React from &apos;react&apos;;import &#123;render&#125; from &apos;react-dom&apos;;import Greeter from &apos;./Greeter&apos;;import &apos;./main.css&apos;;//使用require导入css文件render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;)); 通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独的文件的。 不过这也只是webpack把css当做模块而已，咱们继续看看一个真的CSS模块的实践。 感谢网上各大资源 参考以及转载（其中在原文中有些错误我已经更改） 入门Webpack，看这篇就够了]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript变量+方法]]></title>
    <url>%2FJavaScript%E5%8F%98%E9%87%8F.html</url>
    <content type="text"><![CDATA[JavaScript变量+方法ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。 基本类型值指的是简单的数据段，而引用类型值指那些可能有多个值构成的对象。 传递参数12345678function addTen(num)&#123; num +=10; return num;&#125;var count =20;var result = addTen(count);alert(count); //20,没变化alert(result); //30 在这上面看了高程三的话懵懵懂懂，实际上在说的是，要执行alert(count);时count只是把20复制给参数num，以便20在addTen()中使用，在函数里面num的值确实+10变成了30，但是不影响外部count的变量。 方法 split() 方法讲一个字符串对象的每个字符拆出来，并且将每个字符串当数组的每个元素。 重排序方法 reverse()和sort() reverse()方法会反转数组项的顺序。 123var values = [1,2,3,4,5];values.reverse();alert(values); //5,4,3,2,1 而 sort()方法是按升序排列数组项。——最小的值位于前面，最大的值排在最后面。而且sort()方法会调用每个数组项的toString()转型方法，然后去比较得到的字符串。 123var values = [0,1,5,10,15];values.sort();alert(values); //0,1,10,15,5 在字符串的比较时，10则位于5的前面，于是数组的顺序就被修改了。当然改为降序也行参考注释 123456789function compare (value1,value2)&#123; if(value1 &lt;value2)&#123; return -1; //return 1; &#125;else if(value1 &gt;value2)&#123; return 1; //return -1; &#125;else&#123; return 0; &#125;&#125; 然后我们再把这个参数传给sort()方法即可。 123var values = [0,1,5,10,15];values.sort(compare);alert(values); //0,1,5,10,15]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基本概念（高程3）]]></title>
    <url>%2FJavaScript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5copy.html</url>
    <content type="text"><![CDATA[JavaScript基本概念（高程3）数据类型typeof操作符“undefined”——如果这个值未定义; “boolean”——如果这个值是布尔值; “string”——如果这个值是字符串; “number”——如果这个值是数值; “object”——如果这个值是对象或null; “function”——如果这个值是函数; Undefined类型 Undefined类型只有一个值，即特殊的undefined。 Null类型 Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值会返回”object”的原因。 Boolean类型 Boolean类型是ECMAScript中使用得最多的一种类型，该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0. Number类型整数通过八进制（以8为基数）或十六进制（以16为基数）的字面值来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0~7）。 十六进制字面值的前两位必须是0x，后跟任何十六进制数字（0~9及A~F）。 浮点数值 永远不要测试某个特定的浮点数值。 如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。 数值范围 12var result= Number.MAX_VALUE +Number.MAX_VALUE;alert(isFinite(result)); //false NaN NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。 它本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不想等，包括NaN本身。例如， 1alert(NaN == NaN); //false 数值转换 1234var num1 = Number("Hello world"); //NaNvar num2 = Number(" "); //0var num3 = Number("000011"); //11var num4 = Number("true"); //1 String类型 字符字面量-也叫转义序列 字符串的特定 字符串一旦创建，它们的值就不能改变。 转换为字符串 要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的toString()方法。第二用String方法。 Object类型 constructor:保存着用于创建当前对象的函数。 hasOwnProperty（propertyName）:用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(“name”)）。 isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型。 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。与2方法一样，作为参数必须以字符串形式指定。 toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。 toString():返回对象的字符串表示。 valueOf():返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。 操作符一元操作符 递增和递减操作符 ​ 递增和递减操作符直接借鉴C。 位操作符 符号位的值决定了其他为数值的格式。 负数同样以二进制码存储，但使用的格式是二进制补码 按位非（NOT） 按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码。 1234var num1 = 25;//二进制00000000000000000000000000011001//二进制11111111111111111111111111100110var num2 = ~num1;alert(num2);//-26 按位与（AND） 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 0 0 1 0 0 0 0 简而言之，按位与操作只在两个数值的对应位都是1时才返回1，任何一位是0，结果都是0. 按位或（OR） 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 1 0 1 1 0 0 0 按位或操作在有一个位是1的情况下就返回1，而只有在两个位都是0的情况下才返回0. 按位异或（XOR） 第一个数值的位 第二个数值的位 结果 1 1 0 1 0 1 0 1 1 0 0 0 按位异或与按位或的不同之处在于，这个操作两个数值对应位上只有一个1时才返回1，如果对应的两位都是1或是0，则返回0. 左移 左移操作符由两个小于号（&lt;&lt;）表示。 12var oldValue = 2; //等于二进制的10var newValue = oldValue &lt;&lt; 5;//等于二进制的1000000,十进制的64 有符号的右移 有符号的右移操作符由两个大于号（&gt;&gt;）表示。 12var oldValue = 64;//等于二进制的1000000var newValue = oldValue &gt;&gt; 5;//等于二进制的10，即十进制的2 无符号右移 无符号右移操作符由3个大于号（&gt;&gt;&gt;）表示。 12var oldValue = 64;//等于二进制的1000000var newValue =oldValue &gt;&gt;&gt; 5;//等于二进制的10，即十进制的2 无符号右移操作符会把负数的二进制码当成正数的二进制码。而且由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。 12var oldValue = -64;//等于二进制的11111111111111111111111111000000var newValue = oldValue &gt;&gt;&gt;5;//等于十进制的134217726 布尔操作符 逻辑非（！） 123456alert(!false); //truealert(!"blue"); //falsealert(!0); //truealert(!NaN); //truealert(!""); //truealert(!12345); //false 逻辑与（&amp;&amp;） 第一个操作数 第二个操作数 结果 true true true true false false false true false false false false 在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值。 逻辑或 true true true true false true false true true false false false 第一个操作数 第二个操作数 结果 与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值，]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript DOM编程艺术学习笔记一（第三章兼高程三）]]></title>
    <url>%2FJavascript%20Dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%85%BC%E9%AB%98%E7%A8%8B%E4%B8%89%EF%BC%89.html</url>
    <content type="text"><![CDATA[1.Dom基础Element 三种DOM方法可获取元素节点，分别是通过元素ID、通过标签名字和通过类名字来获取 getElementById 根据Id获取元素节点 getElementByTagName 根据Html获取元素节点 getElementByClassName 根据ClassName（class）获取元素节点 高程三中学到Html元素 id，元素在文档中的唯一标识 - title，有关元素的附加说明信息，一般通过工具提示条显示出来 lang，元素内容的语言比如中文zh-hans dir，语言的方向，值为”ltr”（left-to-right，从左至右）或”rtl”（right-to-left，从右至左），很少使用 className，与元素的class特性对应，即为元素指定的CSS类，没有将这个属性命名为class。 1&lt;div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr"&gt;Some text&lt;/div&gt; 可以获得元素中指定的所有信息。 123456div = document.getElementById("myDiv"); alert(div.id); //"myDiv" alert(div.className); //"bd" alert(div.title); //"Body text" alert(div.lang); //"en" alert(div.dir); //"ltr" 还可以为每个属性赋予新的值。 123456div = document.getElementById("myDiv"); div.id = "someOtherId"; div.className = "ft"; div.title = "Some other text"; div.lang = "fr"; div.dir ="rtl"; 获取和设置属性 getAttribute getAttribute是一个函数。它只有一个参数——你打算查询的属性名字：1object.getAttribute(attribute); setAttribute 它允许我们对属性节点的值做出修改。 1object.setAttribute(&quot;attribute&quot;,value);]]></content>
      <categories>
        <category>Javascript修仙之旅</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017Web程序员技术发展路线图]]></title>
    <url>%2F2017Web%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E8%B7%AF%E7%BA%BF%E5%9B%BE.html</url>
    <content type="text"><![CDATA[这个是国外一个工程师的总结，在知乎上的前端技术文章精选专栏看见的，看着实用转来到这。 2017 年 Web 开发工程师技术发展路线图 下面的脑图展现了前端、后端以及 devops 技术栈的发展路线图，作者起初做这份技术发展脑图是给初学者和学生们准备的。 简介 前端开发工程师路线图 后端开发工程师路线图对于后端方面的技术，原作者表示比较喜欢和看好Nodejs、PHP7 以及 Ruby ，我自己觉得在国内来说 Nodejs 和 React Native 是目前很多前端开发工程师热衷探索的技术，而 Ruby 技术在国内始终不温不火，PHP技术比较传统。建议初学者们还是选择岗位更多的技术栈学习，当然如果你有自己喜欢的技术栈，那就可以暂时不考虑市场因素！ DevOps [GitHub链接:][1] [1] : kamranahmedse/developer-roadmap]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
        <tag>git</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置SSH Key+Next主题以及个性化改动]]></title>
    <url>%2F%E9%85%8D%E7%BD%AESSH%20Key%2BNext%E4%B8%BB%E9%A2%98%E4%BB%A5%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E6%94%B9%E5%8A%A8.html</url>
    <content type="text"><![CDATA[Git SSH Key 生成步骤Git是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。 第一次使用要设置Git的user name 和email 1$ git config --global user.name 1$ git config --global user.email 查看你是否已经拥有密钥 1$cd ~/.ssh 如果没有的话就不会有此文件，有的话就会备份删除掉 生成密钥 1$ ssh-keygen -t rsa -C “user.email” 你将会遇到以下情况的处理： 12345678 Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): 直接回车Enter passphrase (empty for no passphrase): 直接回车Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa. 公钥Your public key has been saved in /root/.ssh/id_rsa.pub. 私钥The key fingerprint is:4d:dd:48:af:76:c2:ba:a8:bc:20:f3:28:1d:6a:28:53 就是按3次回车，密码为空！最后你会得到两个文件：id_rsa和id_rsa.pub 把密钥加到Github或者码云或者Coding的SSH上我们需要把id_rsa.pub中的内容全选复制，然后粘贴进Pages的各自SSH地方，当然需要输入密码。 测试SSHGithub：1$ssh -T git@github.com 码云：1$ssh -T git@git.oschina.net Coding:1$ssh -T git@coding.net 若返回则配置成功github:1234The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added ‘github.com,207.97.227.239′ (RSA) to the list of known hosts. 码云：Welcome to Git@OSC, yourname!Coding：Enter passphrase for key ‘/c/Users/Yuankai/.ssh/id_rsa’: Coding.net Tips : [ Hello Kyle_lyk! You have connected to Coding.net by SSH successfully! ]那么配置好，我们就可以把Hexo部署到Git上了1$hexo deploy Hexo之Next Hexo有很多主题，有大道至简的maupassant 也有casper还有uno。但是我还是最喜欢next的风格。 安装Next安装Next是非常的简单。如果你熟悉Git那么你就可以直接使用Git checkout代码：12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 还有一种方法是下载稳定版本 前往Next版本发布页面 一直下拉找到Source code(zip)点击即可下载 之后把下载的压缩包至站点的themes目录下，并将解压后的文件名改为next。 启用Next 你需要打开你的站点目录找到_config.yml这个文件，记住不是themes下next中的_config.yml。 我们需要在站点文件_config.yml中ctrl+F打入theme字段，并将其值改为next：1theme:next 验证主题是否生成完成首先我们要右击你的站点然后选择Git Bash Here，并开启调试模式。1$ hexo s --debug 命令行出现：1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 那么我们就可以在网址上输入http://0.0.0.0:4000去查看效果，检查站点是否正确运行。 Next各种细节主题设定Scheme 是Next提供的一种特性，就因为Scheme我们有三种选择外观。 Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新Scheme 的切换通过更改 主题配置文件（theme/next下的_config.yml），搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。123#scheme: Muse#scheme: Mistscheme: Pisces 还有更多的小东西大家可以去Next官方文档看。比如说 菜单， 侧栏， 头像， 作者昵称， 站点描述， 第三方服务等。 Next中foot更改我把原来的什么Hexo啊..Next.Pisces啊通通改了，这才像我们自己的博客呀！没得说。我们需要打开next下的layout接着打开_partials下的footer.swig。然后我们要把其中红框里的删除。紧接着我们回到next下，找到languages，打开zh-Hans.yml。我们可以改成如下：123footer: powered: "个人专属 " theme: Adherent 看大家的想法自己随意发挥！好啦，我要去研究SEO了！！祝大家建博成功]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js+hexo部署博客]]></title>
    <url>%2FNode.js%2Bhexo%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[初衷想了很久，还是要弄个博客来勉励自己来督促自己学习去记录。因为学生党，没能抢到腾讯云+阿里云学生优惠，又用过github pages而且挺想用markdown写作，就选择Hexo来搭建自己的博客。也许有人会说为什么不用Jekyll，因为我所用的是windows系统，而且不建议在windows系统下安装Jekyll，还有我准备发展方向是前端。hexo是基于Node.js而Jekyll是基于Ruby所以你懂的！还有我查了一下Hexo是台湾的程序员开发的，原生态支持中文。Node.js+Hexo。是因为我对js的热爱还有因为是台湾同胞的作品，所去选择的。现在我也就把自己搭建流程说一下以及自己遇到的问题着重提一下。 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Node下载安装Node注意事项Node.js根据自己电脑/喜好去选择是否用安装包还是绿色安装！建议路径中不要包含空格或者其他特殊字符，防止出现莫名其妙的错误，最好纯英文。 环境配置各种都要配置环境，Node也不例外。如果你的文件路径为D:\node也就是你Node.exe所在的位置。回到桌面点击（我是win10，win7,win8方法类似）我的电脑右键-属性-高级系统设置-高级-环境变量在Path项中加入D:\node这个路径。之后我们win+R打入cmd命令行去执行npm命令，如果没有提示找不到命令，则说明Node安装成功，如果有的话去看看自己是不是环境配置没有配置好。 配置国内镜像在国内可以用淘宝NPM镜像，这样各种安装和使用npm快很多而且还可以代替npm。你只要运行下面的命令1npm install -g cnpm --registry=https://registry.npm.taobao.org 同样测试有没有安装好，这次打cnpm就行拉，结果显示与上述相同。那么以后我们只要执行跟npm的命令时我们只要把npm替换成cnpm就行了！ 安装Git下载Git程序包作为萌新最希望能一步一步来，我也就一步一步和大家说，也为了以后自己注意一些Git的小细节。 windows下安装Git SCM Mac下安装GitSCM Linux and Unix下安装GitSCM 附上git使用简易指南 环境配置同样Git也需要环境配置，与Node配置一致。你Git的路径C:\Git\bin那么在Path中就可以这样写C:\Git\bin。下面要进入重点了！ 安装HexoHexo中文文档，我们把Hexo两大依赖Node.js和Git都已经安装配置完成。不出问题，那么下面则是水到渠成。接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli 有些人会发现执行上面那句下载缓慢还出错，那么因为我们已经用了淘宝NPM镜像我们直接使用以下命令：1$ cnpm install -g hexo-cli Windows Mac Linux Unix系统编译时遇到的问题则可以去Hexo中文文档里面寻找解决办法。 使用Hexo建站Hexo建站后产生的文件如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中最重要的是_config.yml这是网站的配置信息，我们可以在里面配置大部分的参数。去让我们的博客变得更加个性化。 创建站点找一个你自己想放你项目的目录，按住Shift然后在空白处右击打开Git Bash here执行下列命令，Hexo则会在指定的文件夹中新建所需要的文件。1$ hexo init site 然后我们再右键site文件夹执行以下命令：1$ hexo generate 这时，我们点开site会发现里面有个public的目录。这里面就是网站的静态文件。我们可以手动的把这些静态文件纳入git的仓库接着推送到开启page服务的分支上或者发布到Web服务器上。但是我还是推荐你们用Hexo的自动化部署。 自动化部署Hexo自动Git部署需要安装hexo-deployer-git，执行下列命令1cnpm install hexo-deployer-git --save 然后修改系统配置文件_config.yml（不是themes子目录下的主题配置文件）。修改deploy这一项的值，按照以下格式配置。如果没有这一项，直接在文件末尾添加即可。注意缩进，yml中使用缩进表示从属关系，用-表示一个序列（可以同时部署到多个仓库）。这里减号后有一个空格。以我的项目为例，配置内容如下：1234deploy:- type: git repo: git@git.coding.net:Adherent/Adherent.git branch: coding-pages type值不用修改，因为这里使用的是git的pages服务，类型就是git。repo为仓库地址，为了方便部署（免输账号密码），使用的是ssh协议的仓库地址。这需要配置ssh秘钥，具体参考生成并部署SSH key。branch为开启pages服务的分支名称。一般的，码云为osc-pages，Coding为coding-pages，GitHub为gh-pages。配置好部署信息后，即可用Hexo把静态页面部署到git上了。1hexo deploy 部署完成后，通过域名，应该就能访问到这些页面了。 部署SSH key则可以看我的部署SSH key的文章 Pages服务的选择都说做编程必须有GitHub而且上面还聚集了世界各地的开发者吧，因此很多人都在使用github的pages服务建站。但我还是推荐使用国内的码云或者Coding以获得更好的访问速度。Coding是支持自己添加域名的所以我选择用Coding。首先要创建一个项目，才能开启pages服务。可以去Coding Pages帮助中心看看如何开启以我的网站为例，项目地址为https://coding.net/u/Adherent/p/Adherent/git，开启pages服务的分支名称为coding-pages。项目初始化时并没有codingc-pages分支，可以等Hexo部署静态文件后再开启pages服务。 添加新文章博客建成，那么我们就可以写自己的博文了！执行下列命令：1$ hexo n 文章题目 以上命令就可以在source/_posts/目录中生成一个文件名为文章题目后缀名为.md`的文件。剩下的文件内容我们就可以用markdown语法写文章就好了。markdown语法参见Markdown 语法说明 (简体中文版)我推荐一款Cmd Markdown个人感觉用的还是很舒服的。这是Cmd Markdown的简明语法手册。然后执行以下命令即可生成新的页面，部署到git。1hexo g -d 同样的，把新添加的文件纳入git仓库，并推送到网上的仓库。123git add *git commit -m "新的文章"git push 到了这里，该系统已经能很好的运行了。更多的使用以及设置方法参考文档|Hexo即可。 参考文章 淘宝NPM镜像 git使用简易指南 文档|Hexo Cmd Markdown 启蒙`]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node.js</tag>
        <tag>git</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello, World!]]></title>
    <url>%2FHello%20World.html</url>
    <content type="text"><![CDATA[Hello World Hello World 第一篇就和大家打个招呼！ 多种语言的Hello World C 123456#include &lt;stdio.h&gt;int main()&#123; printf("Hello, World"); return 0;&#125; Java 12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("Hello World!"); &#125;&#125; Javascript 1console.log("Hello, World!"); Python 1print("Hello, World!") PHP 1echo 'Hello,World!'; Go 12345package mainimport "fmt"func main()&#123; fmt.Print("Hello, World!");&#125; setTimeout(function(){ console.log("I Love Mu"); alert("Hello, World!"); }, 5000);]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>C</tag>
        <tag>Java</tag>
        <tag>Python</tag>
        <tag>PHP</tag>
        <tag>go</tag>
      </tags>
  </entry>
</search>
