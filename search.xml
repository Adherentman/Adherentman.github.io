<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Vue.js小记]]></title>
      <url>%2F2017%2F04%2F28%2FVue.js%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[#Vue小记 v-bind 缩写： ： 修饰符 .prop - 被用于绑定DOM属性 .camel 用法 动态的绑定一个或多个特性，或一个组件prop到表达式 1&lt;a v-bind:href="url" href="#"&gt;&lt;/a&gt; 在这里:href是参数，通过v-bind指令将该元素的href属性与表达式的url绑定。 v-if1&lt;p v-if="seen"&gt;Now you see me&lt;/p&gt; 这个v-if指令将判断seen的真假值来移出/插入&lt;p&gt;元素。 v-on 缩写：@ 1&lt;a v-on:click="doSomething"&gt; 这个指令是用来监听DOM事件。 事件修饰符 .stop .prevent .capture .self .once 12345678910111213141516&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;2.1.4新增&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once="doThis"&gt;&lt;/a&gt; 按键修饰符1234567&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13="submit"&gt;记住keyCode各种值很难所以提供了别名&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt; .enter .tab .delete(捕获“删除”和“退格”按键) .esc .space .up .down .left .right 2.1.0新增 .ctrl .alt .shift .meta(Mac上为(⌘)在windows上为(⊞)) v-for我们用 v-for 指令根据一组数组的选项列表进行渲染。 v-for 指令需要以 item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名。 12345&lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789var example1 = new Vue(&#123; el: '#example-1', data: &#123; items: [ &#123;message: 'Foo' &#125;, &#123;message: 'Bar' &#125; ] &#125;&#125;) 结果： Foo Bar v-model你可以用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。 具体看]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初入React+Webpack(入门)]]></title>
      <url>%2F2017%2F04%2F27%2F%E5%88%9D%E5%85%A5React%2F</url>
      <content type="text"><![CDATA[因为需要做一个自己的小想法以后需要去实现把这个想法变成项目，在重多得框架中选择React.js，因为它需要学习成本，所以我觉得我在学习的过程中能学到很多东西。 通过npm使用React建议在 React 中使用 CommonJS 模块系统，比如 browserify 或 webpack。使用 react 和 react-dom npm 包. 我使用webpack来安装React DOM的 12$ npm install --save react react-dom babelify babel-preset-react$ browserify -t [ babelify --presets [ react ] ] main.js -o bundle.js 那么第一步肯定是创建Hello World啦~ 我们需要创建一个helloworld.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Hello React!&lt;/title&gt; &lt;script src="build/react.js"&gt;&lt;/script&gt; &lt;script src="build/react-dom.js"&gt;&lt;/script&gt; &lt;script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在代码中 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); 这是jsx语法。可以去 JSX 语法 里学习更多 JSX 相关的知识。为了把 JSX 转成标准的 JavaScript，我们用 &lt;script type=&quot;text/babel&quot;&gt; 标签，并引入 Babel 来完成在浏览器里的代码转换。在浏览器里打开这个html，你应该可以看到成功的消息！ 分离文件那么我们在React中也是可以分离js的。 我们需要创建一个下面的build/helloworld.js 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example')); 之后我们在html的文件中像以前引用文件一样去引用就可以了。 1&lt;script type="text/babel" src="src/helloworld.js"&gt;&lt;/script&gt; 但是我是用chrome不会显示效果。之后我用safari效果成功显示，后来打开控制台发现http以外的协议加载失败了。读取不了&lt;script src=&quot;https://npmcdn.com/babel-core@5.8.38/browser.min.js&quot;&gt;&lt;/script&gt;那么就我就去跟着开发文档配置了babel。 BabelBabel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看：Babel Webpack(入门)webpack是什么？webpack是一个模块化打包工具，使用js作为载体将所有静态资源打包在一起，支持的loader和plugin等能对各种静态资源进行预处理，极大地方便了前端的工程化开发。详情参考官网，此处放张官网概念图: ###开始使用Webpack我们来一步一步去开始学习使用Webpack。 ###安装Webpack可以使用npm安装，新建一个空白的文件夹（我的为webpackwhat），在终端中转到该文件夹下（cd webpackwhat）进行安装。 1234//全局安装npm install -g webpack//安装到你的项目目录npm install --save-dev webpack 我们在终端中使用npm init的命令可以自动创建这个package.json文件 1npm init 输入后，会有一些需要你输入的信息，你只需要一直回车就行了。 接下来我们在这个文件夹下进行安装Webpack作为依赖包 12//安装Webpacknpm install --save-dev webpack 回到之前的空文件夹，并在里面创建两个文件夹,app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放准备给浏览器读取的数据（包括使用webpack生成的打包后的js文件以及一个index.html文件）。在这里还需要创建三个文件，index.html 文件放在public文件夹中，两个js文件（Greeter.js和main.js）放在app文件夹中. index.html文件只有最基础的html代码，它唯一的目的就是加载打包后的js文件（bundle.js） 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='root'&gt; &lt;/div&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Greeter.js只包括一个用来返回包含问候信息的html元素的函数。 123//main.js var greeter = require(&apos;./Greeter.js&apos;);document.getElementById(&apos;root&apos;).appendChild(greeter()); main.js用来把Greeter模块返回的节点插入页面。 123456// Greeter.jsmodule.exports = function() &#123; var greet = document.createElement(&apos;div&apos;); greet.textContent = &quot;Hi there and greetings!&quot;; return greet;&#125;; 正式使用Webpack12//webpack非全局安装的情况node_modules/.bin/webpack app/main.js public/bundle.js 可以看出webpack同时编译了main.js 和Greeter,js,现在打开index.html,可以看到如下结果 通过配置文件来使用WebpackWebpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如已经提到的，这样不太方便且容易出错的，一个更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，可以把所有的与构建相关的信息放在里面。 还是继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，并在其中进行最最简单的配置，如下所示，它包含入口文件路径和存放打包后文件的地方的路径。 1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 更快捷的执行打包任务执行类似于node_modules/.bin/webpack这样的命令其实是比较烦人且容易出错的，不过值得庆幸的是npm可以引导任务执行，对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可，设置方法如下。 12345678910111213&#123; &quot;name&quot;: &quot;webpack-sample-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Sample webpack project&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令 &#125;, &quot;author&quot;: &quot;zhang&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^1.12.9&quot; &#125;&#125; 注：package.json中的脚本部分已经默认在命令前添加了node_modules/.bin路径，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。 npm的start是一个特殊的脚本名称，它的特殊性表现在，在命令行中使用npm start就可以执行相关命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build Loaders鼎鼎大名的Loaders登场了！ Loaders是webpack中最让人激动人心的功能之一了。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。 Loaders需要单独安装并且需要在webpack.config.js下的modules关键字下进行配置，Loaders的配置选项包括以下几方面： test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 继续上面的例子，我们把Greeter.js里的问候消息放在一个单独的JSON文件里,并通过合适的配置使Greeter.js可以读取该JSON文件的值，配置方法如下 12//安装可以装换JSON的loadernpm install --save-dev json-loader 12345678910111213141516171819202122232425module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123;//在配置文件里添加JSON loader loaders: [ &#123; test: /\.json$/, loader: &quot;json&quot; &#125; ] &#125;, devServer: &#123; contentBase: &quot;./public&quot;, colors: true, historyApiFallback: true, inline: true &#125;&#125; 创建带有问候信息的JSON文件(命名为config.json) 1234//config.json&#123; &quot;greetText&quot;: &quot;Hi there and greetings from JSON!&quot;&#125; 更新后的Greeter.js 1234567var config = require(&apos;./config.json&apos;);module.exports = function() &#123; var greet = document.createElement(&apos;div&apos;); greet.textContent = config.greetText; return greet;&#125;; Loaders很好，不过有的Loaders使用起来比较复杂，比如说Babel。 BabelBabel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过编译帮你达到以下目的： 下一代的JavaScript标准（ES6，ES7），这些标准目前并未被当前的浏览器完全的支持； 使用基于JavaScript进行了拓展的语言，比如React的JSX Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，不过webpack把它们整合在一起使用，但是对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包）。 我们先来一次性安装这些依赖包 12// npm一次性安装多个依赖模块，模块之间用空格隔开npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react 在webpack中配置Babel的方法如下 123456789101112131415161718192021222324252627282930313233module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json-loaders&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loaders&apos;,//在webpack的module部分的loaders里进行配置即可 query: &#123; presets: [&apos;es2015&apos;,&apos;react&apos;] &#125; &#125; ] &#125;, devServer: &#123; contentBase: &quot;./public&quot;, colors: true, historyApiFallback: true, inline: true &#125;&#125; 现在你的webpack的配置已经允许你使用ES6以及JSX的语法了。继续用上面的例子进行测试，不过这次我们会使用React，记得先安装 React 和 React-DOM 1npm install --save react react-dom 使用ES6的语法，更新Greeter.js并返回一个React组件 123456789101112131415//Greeter,jsimport React, &#123;Component&#125; from &apos;react&apos;import config from &apos;./config.json&apos;;class Greeter extends Component&#123; render() &#123; return ( &lt;div&gt; &#123;config.greetText&#125; &lt;/div&gt; ); &#125;&#125;export default Greeter 使用ES6的模块定义和渲染Greeter模块 12345import React from &apos;react&apos;;import &#123;render&#125; from &apos;react-dom&apos;;import Greeter from &apos;./Greeter&apos;;render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;)); Babel的配置选项Babel其实可以完全在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下： 1234567891011121314151617181920212223242526// webpack.config.jsmodule.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json-loaders&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loaders&apos; &#125; ] &#125;, devServer: &#123;...&#125; // Omitted for brevity&#125; 1234//.babelrc&#123; &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;]&#125; 到目前为止，我们已经知道了，对于模块，Webpack能提供非常强大的处理功能，那那些是模块呢。 CSSwebpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(...)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。 继续上面的例子 12//安装npm install --save-dev style-loader css-loader 123456789101112131415161718192021222324252627282930//使用module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/build&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json-loaders&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loaders&apos; &#125;, &#123; test: /\.css$/, loader: &apos;style-loaders!css-loaders&apos;//添加对样式表的处理 &#125; ] &#125;, devServer: &#123;...&#125;&#125; 注：感叹号的作用在于使同一文件能够使用不同类型的loader 接下来，在app文件夹里创建一个名字为”main.css”的文件，对一些元素设置样式 12345678910111213141516171819html &#123; box-sizing: border-box; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125;body &#123; margin: 0; font-family: &apos;Helvetica Neue&apos;, Helvetica, Arial, sans-serif;&#125;h1, h2, h3, h4, h5, h6, p, ul &#123; margin: 0; padding: 0;&#125; 你还记得吗？webpack只有单一的入口，其它的模块需要通过 import, require, url等导入相关位置，为了让webpack能找到”main.css“文件，我们把它导入”main.js “中，如下 12345678//main.jsimport React from &apos;react&apos;;import &#123;render&#125; from &apos;react-dom&apos;;import Greeter from &apos;./Greeter&apos;;import &apos;./main.css&apos;;//使用require导入css文件render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;)); 通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独的文件的。 不过这也只是webpack把css当做模块而已，咱们继续看看一个真的CSS模块的实践。 感谢网上各大资源 参考以及转载（其中在原文中有些错误我已经更改） 入门Webpack，看这篇就够了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript变量+方法]]></title>
      <url>%2F2017%2F04%2F24%2FJavaScript%E5%8F%98%E9%87%8F%2F</url>
      <content type="text"><![CDATA[JavaScript变量+方法ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。 基本类型值指的是简单的数据段，而引用类型值指那些可能有多个值构成的对象。 传递参数12345678function addTen(num)&#123; num +=10; return num;&#125;var count =20;var result = addTen(count);alert(count); //20,没变化alert(result); //30 在这上面看了高程三的话懵懵懂懂，实际上在说的是，要执行alert(count);时count只是把20复制给参数num，以便20在addTen()中使用，在函数里面num的值确实+10变成了30，但是不影响外部count的变量。 方法 split() 方法讲一个字符串对象的每个字符拆出来，并且将每个字符串当数组的每个元素。 重排序方法 reverse()和sort() reverse()方法会反转数组项的顺序。 123var values = [1,2,3,4,5];values.reverse();alert(values); //5,4,3,2,1 而 sort()方法是按升序排列数组项。——最小的值位于前面，最大的值排在最后面。而且sort()方法会调用每个数组项的toString()转型方法，然后去比较得到的字符串。 123var values = [0,1,5,10,15];values.sort();alert(values); //0,1,10,15,5 在字符串的比较时，10则位于5的前面，于是数组的顺序就被修改了。当然改为降序也行参考注释 123456789function compare (value1,value2)&#123; if(value1 &lt;value2)&#123; return -1; //return 1; &#125;else if(value1 &gt;value2)&#123; return 1; //return -1; &#125;else&#123; return 0; &#125;&#125; 然后我们再把这个参数传给sort()方法即可。 123var values = [0,1,5,10,15];values.sort(compare);alert(values); //0,1,5,10,15]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基本概念（高程3）]]></title>
      <url>%2F2017%2F04%2F11%2FJavaScript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5copy%2F</url>
      <content type="text"><![CDATA[JavaScript基本概念（高程3）JavaScript高级程序设计第三章数据类型typeof操作符“undefined”——如果这个值未定义; “boolean”——如果这个值是布尔值; “string”——如果这个值是字符串; “number”——如果这个值是数值; “object”——如果这个值是对象或null; “function”——如果这个值是函数; Undefined类型 Undefined类型只有一个值，即特殊的undefined。 Null类型 Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值会返回”object”的原因。 Boolean类型 Boolean类型是ECMAScript中使用得最多的一种类型，该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0. Number类型整数通过八进制（以8为基数）或十六进制（以16为基数）的字面值来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0~7）。 十六进制字面值的前两位必须是0x，后跟任何十六进制数字（0~9及A~F）。 浮点数值 永远不要测试某个特定的浮点数值。 如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。 数值范围 12var result= Number.MAX_VALUE +Number.MAX_VALUE;alert(isFinite(result)); //false NaN NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。 它本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不想等，包括NaN本身。例如， 1alert(NaN == NaN); //false 数值转换 1234var num1 = Number("Hello world"); //NaNvar num2 = Number(" "); //0var num3 = Number("000011"); //11var num4 = Number("true"); //1 String类型 字符字面量-也叫转义序列 字符串的特定 字符串一旦创建，它们的值就不能改变。 转换为字符串 要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的toString()方法。第二用String方法。 Object类型 constructor:保存着用于创建当前对象的函数。 hasOwnProperty（propertyName）:用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(“name”)）。 isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型。 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。与2方法一样，作为参数必须以字符串形式指定。 toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。 toString():返回对象的字符串表示。 valueOf():返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。 操作符一元操作符 递增和递减操作符 ​ 递增和递减操作符直接借鉴C。 位操作符 符号位的值决定了其他为数值的格式。 负数同样以二进制码存储，但使用的格式是二进制补码 按位非（NOT） 按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码。 1234var num1 = 25;//二进制00000000000000000000000000011001//二进制11111111111111111111111111100110var num2 = ~num1;alert(num2);//-26 按位与（AND） 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 0 0 1 0 0 0 0 简而言之，按位与操作只在两个数值的对应位都是1时才返回1，任何一位是0，结果都是0. 按位或（OR） 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 1 0 1 1 0 0 0 按位或操作在有一个位是1的情况下就返回1，而只有在两个位都是0的情况下才返回0. 按位异或（XOR） 第一个数值的位 第二个数值的位 结果 1 1 0 1 0 1 0 1 1 0 0 0 按位异或与按位或的不同之处在于，这个操作两个数值对应位上只有一个1时才返回1，如果对应的两位都是1或是0，则返回0. 左移 左移操作符由两个小于号（&lt;&lt;）表示。 12var oldValue = 2; //等于二进制的10var newValue = oldValue &lt;&lt; 5;//等于二进制的1000000,十进制的64 有符号的右移 有符号的右移操作符由两个大于号（&gt;&gt;）表示。 12var oldValue = 64;//等于二进制的1000000var newValue = oldValue &gt;&gt; 5;//等于二进制的10，即十进制的2 无符号右移 无符号右移操作符由3个大于号（&gt;&gt;&gt;）表示。 12var oldValue = 64;//等于二进制的1000000var newValue =oldValue &gt;&gt;&gt; 5;//等于二进制的10，即十进制的2 无符号右移操作符会把负数的二进制码当成正数的二进制码。而且由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。 12var oldValue = -64;//等于二进制的11111111111111111111111111000000var newValue = oldValue &gt;&gt;&gt;5;//等于十进制的134217726 布尔操作符 逻辑非（！） 123456alert(!false); //truealert(!"blue"); //falsealert(!0); //truealert(!NaN); //truealert(!""); //truealert(!12345); //false 逻辑与（&amp;&amp;） 第一个操作数 第二个操作数 结果 true true true true false false false true false false false false 在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值。 逻辑或 true true true true false true false true true false false false 第一个操作数 第二个操作数 结果 与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值，]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript DOM编程艺术学习笔记一（第三章兼高程三）]]></title>
      <url>%2F2017%2F03%2F26%2FJavascript%20Dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%85%BC%E9%AB%98%E7%A8%8B%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[1.Dom基础Element 三种DOM方法可获取元素节点，分别是通过元素ID、通过标签名字和通过类名字来获取 getElementById 根据Id获取元素节点 getElementByTagName 根据Html获取元素节点 getElementByClassName 根据ClassName（class）获取元素节点 高程三中学到Html元素 id，元素在文档中的唯一标识 - title，有关元素的附加说明信息，一般通过工具提示条显示出来 lang，元素内容的语言比如中文zh-hans dir，语言的方向，值为”ltr”（left-to-right，从左至右）或”rtl”（right-to-left，从右至左），很少使用 className，与元素的class特性对应，即为元素指定的CSS类，没有将这个属性命名为class。 1&lt;div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr"&gt;Some text&lt;/div&gt; 可以获得元素中指定的所有信息。 123456div = document.getElementById("myDiv"); alert(div.id); //"myDiv" alert(div.className); //"bd" alert(div.title); //"Body text" alert(div.lang); //"en" alert(div.dir); //"ltr" 还可以为每个属性赋予新的值。 123456div = document.getElementById("myDiv"); div.id = "someOtherId"; div.className = "ft"; div.title = "Some other text"; div.lang = "fr"; div.dir ="rtl"; 获取和设置属性 getAttribute getAttribute是一个函数。它只有一个参数——你打算查询的属性名字：1object.getAttribute(attribute); setAttribute 它允许我们对属性节点的值做出修改。 1object.setAttribute(&quot;attribute&quot;,value);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017Web程序员技术发展路线图]]></title>
      <url>%2F2017%2F03%2F22%2F2017Web%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E8%B7%AF%E7%BA%BF%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[这个是国外一个工程师的总结，在知乎上的前端技术文章精选专栏看见的，看着实用转来到这。 2017 年 Web 开发工程师技术发展路线图 下面的脑图展现了前端、后端以及 devops 技术栈的发展路线图，作者起初做这份技术发展脑图是给初学者和学生们准备的。 简介 前端开发工程师路线图 后端开发工程师路线图对于后端方面的技术，原作者表示比较喜欢和看好Nodejs、PHP7 以及 Ruby ，我自己觉得在国内来说 Nodejs 和 React Native 是目前很多前端开发工程师热衷探索的技术，而 Ruby 技术在国内始终不温不火，PHP技术比较传统。建议初学者们还是选择岗位更多的技术栈学习，当然如果你有自己喜欢的技术栈，那就可以暂时不考虑市场因素！ DevOps [GitHub链接:][1] [1] : kamranahmedse/developer-roadmap]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[配置SSH Key+Next主题以及个性化改动]]></title>
      <url>%2F2017%2F03%2F20%2F%E9%85%8D%E7%BD%AESSH%20Key%2BNext%E4%B8%BB%E9%A2%98%E4%BB%A5%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E6%94%B9%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[Git SSH Key 生成步骤Git是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。 第一次使用要设置Git的user name 和email1$ git config --global user.name 1$ git config --global user.email 查看你是否已经拥有密钥 1$cd ~/.ssh 如果没有的话就不会有此文件，有的话就会备份删除掉 生成密钥 1$ ssh-keygen -t rsa -C “user.email” 你将会遇到以下情况的处理： 12345678 Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): 直接回车Enter passphrase (empty for no passphrase): 直接回车Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa. 公钥Your public key has been saved in /root/.ssh/id_rsa.pub. 私钥The key fingerprint is:4d:dd:48:af:76:c2:ba:a8:bc:20:f3:28:1d:6a:28:53 就是按3次回车，密码为空！最后你会得到两个文件：id_rsa和id_rsa.pub 把密钥加到Github或者码云或者Coding的SSH上我们需要把id_rsa.pub中的内容全选复制，然后粘贴进Pages的各自SSH地方，当然需要输入密码。 测试SSHGithub：1$ssh -T git@github.com 码云：1$ssh -T git@git.oschina.net Coding:1$ssh -T git@coding.net 若返回则配置成功github:1234The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added ‘github.com,207.97.227.239′ (RSA) to the list of known hosts. 码云：Welcome to Git@OSC, yourname!Coding：Enter passphrase for key ‘/c/Users/Yuankai/.ssh/id_rsa’: Coding.net Tips : [ Hello Kyle_lyk! You have connected to Coding.net by SSH successfully! ]那么配置好，我们就可以把Hexo部署到Git上了1$hexo deploy Hexo之Next Hexo有很多主题，有大道至简的maupassant 也有casper还有uno。但是我还是最喜欢next的风格。 安装Next安装Next是非常的简单。如果你熟悉Git那么你就可以直接使用Git checkout代码：12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 还有一种方法是下载稳定版本 前往Next版本发布页面 一直下拉找到Source code(zip)点击即可下载 之后把下载的压缩包至站点的themes目录下，并将解压后的文件名改为next。 启用Next 你需要打开你的站点目录找到_config.yml这个文件，记住不是themes下next中的_config.yml。 我们需要在站点文件_config.yml中ctrl+F打入theme字段，并将其值改为next：1theme:next 验证主题是否生成完成首先我们要右击你的站点然后选择Git Bash Here，并开启调试模式。1$ hexo s --debug 命令行出现：1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 那么我们就可以在网址上输入http://0.0.0.0:4000去查看效果，检查站点是否正确运行。 Next各种细节主题设定Scheme 是Next提供的一种特性，就因为Scheme我们有三种选择外观。 Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新Scheme 的切换通过更改 主题配置文件（theme/next下的_config.yml），搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。123#scheme: Muse#scheme: Mistscheme: Pisces 还有更多的小东西大家可以去Next官方文档看。比如说 菜单， 侧栏， 头像， 作者昵称， 站点描述， 第三方服务等。 Next中foot更改我把原来的什么Hexo啊..Next.Pisces啊通通改了，这才像我们自己的博客呀！没得说。我们需要打开next下的layout接着打开_partials下的footer.swig。然后我们要把其中红框里的删除。紧接着我们回到next下，找到languages，打开zh-Hans.yml。我们可以改成如下：123footer: powered: &quot;个人专属 &quot; theme: Adherent 看大家的想法自己随意发挥！好啦，我要去研究SEO了！！祝大家建博成功]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node.js+hexo部署博客]]></title>
      <url>%2F2017%2F03%2F20%2FNode.js%2Bhexo%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[初衷想了很久，还是要弄个博客来勉励自己来督促自己学习去记录。因为学生党，没能抢到腾讯云+阿里云学生优惠，又用过github pages而且挺想用markdown写作，就选择Hexo来搭建自己的博客。也许有人会说为什么不用Jekyll，因为我所用的是windows系统，而且不建议在windows系统下安装Jekyll，还有我准备发展方向是前端。hexo是基于Node.js而Jekyll是基于Ruby所以你懂的！还有我查了一下Hexo是台湾的程序员开发的，原生态支持中文。Node.js+Hexo。是因为我对js的热爱还有因为是台湾同胞的作品，所去选择的。现在我也就把自己搭建流程说一下以及自己遇到的问题着重提一下。 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Node下载安装Node注意事项Node.js根据自己电脑/喜好去选择是否用安装包还是绿色安装！建议路径中不要包含空格或者其他特殊字符，防止出现莫名其妙的错误，最好纯英文。 环境配置各种都要配置环境，Node也不例外。如果你的文件路径为D:\node也就是你Node.exe所在的位置。回到桌面点击（我是win10，win7,win8方法类似）我的电脑右键-属性-高级系统设置-高级-环境变量在Path项中加入D:\node这个路径。之后我们win+R打入cmd命令行去执行npm命令，如果没有提示找不到命令，则说明Node安装成功，如果有的话去看看自己是不是环境配置没有配置好。 配置国内镜像在国内可以用淘宝NPM镜像，这样各种安装和使用npm快很多而且还可以代替npm。你只要运行下面的命令1npm install -g cnpm --registry=https://registry.npm.taobao.org 同样测试有没有安装好，这次打cnpm就行拉，结果显示与上述相同。那么以后我们只要执行跟npm的命令时我们只要把npm替换成cnpm就行了！ 安装Git下载Git程序包作为萌新最希望能一步一步来，我也就一步一步和大家说，也为了以后自己注意一些Git的小细节。 windows下安装Git SCM Mac下安装GitSCM Linux and Unix下安装GitSCM 附上git使用简易指南 环境配置同样Git也需要环境配置，与Node配置一致。你Git的路径C:\Git\bin那么在Path中就可以这样写C:\Git\bin。下面要进入重点了！ 安装HexoHexo中文文档，我们把Hexo两大依赖Node.js和Git都已经安装配置完成。不出问题，那么下面则是水到渠成。接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli 有些人会发现执行上面那句下载缓慢还出错，那么因为我们已经用了淘宝NPM镜像我们直接使用以下命令：1$ cnpm install -g hexo-cli Windows Mac Linux Unix系统编译时遇到的问题则可以去Hexo中文文档里面寻找解决办法。 使用Hexo建站Hexo建站后产生的文件如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中最重要的是_config.yml这是网站的配置信息，我们可以在里面配置大部分的参数。去让我们的博客变得更加个性化。 创建站点找一个你自己想放你项目的目录，按住Shift然后在空白处右击打开Git Bash here执行下列命令，Hexo则会在指定的文件夹中新建所需要的文件。1$ hexo init site 然后我们再右键site文件夹执行以下命令：1$ hexo generate 这时，我们点开site会发现里面有个public的目录。这里面就是网站的静态文件。我们可以手动的把这些静态文件纳入git的仓库接着推送到开启page服务的分支上或者发布到Web服务器上。但是我还是推荐你们用Hexo的自动化部署。 自动化部署Hexo自动Git部署需要安装hexo-deployer-git，执行下列命令1cnpm install hexo-deployer-git --save 然后修改系统配置文件_config.yml（不是themes子目录下的主题配置文件）。修改deploy这一项的值，按照以下格式配置。如果没有这一项，直接在文件末尾添加即可。注意缩进，yml中使用缩进表示从属关系，用-表示一个序列（可以同时部署到多个仓库）。这里减号后有一个空格。以我的项目为例，配置内容如下：1234deploy:- type: git repo: git@git.coding.net:Adherent/Adherent.git branch: coding-pages type值不用修改，因为这里使用的是git的pages服务，类型就是git。repo为仓库地址，为了方便部署（免输账号密码），使用的是ssh协议的仓库地址。这需要配置ssh秘钥，具体参考生成并部署SSH key。branch为开启pages服务的分支名称。一般的，码云为osc-pages，Coding为coding-pages，GitHub为gh-pages。配置好部署信息后，即可用Hexo把静态页面部署到git上了。1hexo deploy 部署完成后，通过域名，应该就能访问到这些页面了。 部署SSH key则可以看我的部署SSH key的文章 Pages服务的选择都说做编程必须有GitHub而且上面还聚集了世界各地的开发者吧，因此很多人都在使用github的pages服务建站。但我还是推荐使用国内的码云或者Coding以获得更好的访问速度。Coding是支持自己添加域名的所以我选择用Coding。首先要创建一个项目，才能开启pages服务。可以去Coding Pages帮助中心看看如何开启以我的网站为例，项目地址为https://coding.net/u/Adherent/p/Adherent/git，开启pages服务的分支名称为coding-pages。项目初始化时并没有codingc-pages分支，可以等Hexo部署静态文件后再开启pages服务。 添加新文章博客建成，那么我们就可以写自己的博文了！执行下列命令：1$ hexo n 文章题目 以上命令就可以在source/_posts/目录中生成一个文件名为文章题目后缀名为.md`的文件。剩下的文件内容我们就可以用markdown语法写文章就好了。markdown语法参见Markdown 语法说明 (简体中文版)我推荐一款Cmd Markdown个人感觉用的还是很舒服的。这是Cmd Markdown的简明语法手册。然后执行以下命令即可生成新的页面，部署到git。1hexo g -d 同样的，把新添加的文件纳入git仓库，并推送到网上的仓库。123git add *git commit -m &quot;新的文章&quot;git push 到了这里，该系统已经能很好的运行了。更多的使用以及设置方法参考文档|Hexo即可。 参考文章 淘宝NPM镜像 git使用简易指南 文档|Hexo Cmd Markdown 启蒙`]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello, World!]]></title>
      <url>%2F2017%2F03%2F19%2FHello%20World%2F</url>
      <content type="text"><![CDATA[Hello World Hello World 第一篇就和大家打个招呼！ 多种语言的Hello World C 123456#include &lt;stdio.h&gt;int main()&#123; printf("Hello, World"); return 0;&#125; Java 12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("Hello World!"); &#125;&#125; Javascript 1console.log("Hello, World!"); Python 1print("Hello, World!") PHP 1echo 'Hello,World!'; Go 12345package mainimport "fmt"func main()&#123; fmt.Print("Hello, World!");&#125; setTimeout(function(){ console.log("I Love Mu"); alert("Hello, World!"); }, 5000);]]></content>
    </entry>

    
  
  
</search>
