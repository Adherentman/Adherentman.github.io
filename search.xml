<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Mongodb之旅(一)]]></title>
      <url>%2F2017%2F07%2F27%2Fmongodb%2F</url>
      <content type="text"><![CDATA[Mongodb之旅(一)插入,insertOne/ManyinsertOne( )123db.inventory.insertOne( &#123; item: &quot;canvas&quot;, qty: 100, tags: [&quot;cotton&quot;], size: &#123; h: 28, w: 35.5, uom: &quot;cm&quot; &#125; &#125;) insertMany([ ])12345db.inventory.insertMany([ &#123; item: &quot;journal&quot;, qty: 25, tags: [&quot;blank&quot;, &quot;red&quot;], size: &#123; h: 14, w: 21, uom: &quot;cm&quot; &#125; &#125;, &#123; item: &quot;mat&quot;, qty: 85, tags: [&quot;gray&quot;], size: &#123; h: 27.9, w: 35.5, uom: &quot;cm&quot; &#125; &#125;, &#123; item: &quot;mousepad&quot;, qty: 25, tags: [&quot;gel&quot;, &quot;blue&quot;], size: &#123; h: 19, w: 22.85, uom: &quot;cm&quot; &#125; &#125;]) 查找,findfind( )1db.inventory.find( &#123;&#125; ) 更新,updateOne/Many$set123456789db.memberplan.update(&#123;_id:&quot;xxx&quot;&#125;,&#123;$set:&#123;tags:[&quot;coats&quot;,&quot;outerwear&quot;]&#125;&#125;) $currentDate,当前时间1234567db.inventory.updateOne( &#123; item: &quot;paper&quot; &#125;, &#123; $set: &#123; &quot;size.uom&quot;: &quot;cm&quot;, status: &quot;P&quot; &#125;, $currentDate: &#123; lastModified: true &#125; &#125;) updateMany1234567db.inventory.updateMany( &#123; &quot;qty&quot;: &#123; $lt: 50 &#125; &#125;, &#123; $set: &#123; &quot;size.uom&quot;: &quot;in&quot;, status: &quot;P&quot; &#125;, $currentDate: &#123; lastModified: true &#125; &#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学Node日志(一)]]></title>
      <url>%2F2017%2F07%2F26%2FNode%2F</url>
      <content type="text"><![CDATA[学Node日志(一)node实例1234567891011121314const http = require('http');const hostname = '127.0.0.1';const port = 9000;const server = http.createServer((req,res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type','text/plain'); res.end('Hello World\n');&#125;);server.listen(port,hostname, () =&gt; &#123; console.log('服务器运行在 http://$&#123;hostname&#125;:$&#123;port&#125;/');&#125;); response.statusCode()控制响应头刷新时将被发送到客户端的状态码 res.statusCode = 200 状态码 11xx的代码代表请求已被接受，需要继续处理。2xx这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。3xx 重定向。4xx 请求错误。5xx表示服务器错误。 ​ response.setHeader() 响应头如果存在,则值会被覆盖 如果要发送多个名称相同的响应头,则使用字符串数组 res.setHeader(&#39;Content-Type&#39;,&#39;text/plain&#39;) Content-Type表明信息类型,缺省值为” text/plain”.它包含了主要类型（primary type）和次要类型（subtype）两个部分，两者之间用”/“分割. 12345678text/plain：纯文本，文件扩展名.txttext/html：HTML文本，文件扩展名.htm和.htmlimage/jpeg：jpeg格式的图片，文件扩展名.jpgimage/gif：GIF格式的图片，文件扩展名.gifaudio/x-wave：WAVE格式的音频，文件扩展名.wavaudio/mpeg：MP3格式的音频，文件扩展名.mp3video/mpeg：MPEG格式的视频，文件扩展名.mpgapplication/zip：PK-ZIP格式的压缩文件，文件扩展名.zip ​ response.end() 每次响应都必须调用 response.end() 方法. 该方法会通知服务器,所有响应头和响应主体都已被发送,即服务器就将他看成已完成 res.end(&#39;Hello World\n&#39;) Hello World已经被发送. server.listen(port,hostname)开始在指定的 port 和 hostname 上接受连接 端口 端口号是一个 16位的 uint, 所以其范围为 1 to 65535 URL 定义的url格式笼统版本&lt;scheme&gt;:&lt;scheme-specific-part&gt; scheme有我们很熟悉的http、https、ftp，以及著名的ed2k，thunder 通常我们熟悉的url定义成这个样子 1&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt; 用过ftp的估计能体会这么长的，网页上很少带auth信息，所以就精简成这样: 1&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt; 在上面的例子中, scheme=http, host=localhost, port=3000, url-path=/. ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git基本操作]]></title>
      <url>%2F2017%2F07%2F25%2Fgit%2F</url>
      <content type="text"><![CDATA[gitgit addgit add -A 和 git add . 和 git add -u git add . ：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。 git add -u ：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add –update的缩写) git add -A ：是上面两个功能的合集（git add –all的缩写） 自我理解: git add -A 提交所有变化 git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 commit过程 git status 检查工作区是否干净 git add 命令主要用于把我们要提交的文件的信息添加到索引库中。当我们使用git commit时，git将依据索引库中的内容来进行文件的提交。 git commit -am “xxxxxxx” git branch git push origin xxxx 删除分支 git branch -D xx 删除本地分支 git push origin :br (origin 后面有空格) 删除远程分支 解决冲突 git fetch origin cms:new 创建新本地分支new git branch git merge new 合并 git branch -D new 删除本地分支]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实习谈业务时所学]]></title>
      <url>%2F2017%2F07%2F24%2Fyewu%2F</url>
      <content type="text"><![CDATA[一些。。。1.业务员可能都没有理清业务或者需求，需要自己去帮他们理清，好让自己设计开发的产品更健壮和在未来更有扩展性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多说挂了好久。现在换成disqus]]></title>
      <url>%2F2017%2F07%2F23%2F%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%E8%BF%81%E7%A7%BB%2F</url>
      <content type="text"><![CDATA[多说已挂，将评论迁移到disqus有很多可替代的方案 网易云跟帖 畅言 友言 Disqus 来必力 还有许多评论功能就不一一举例了. 具体说下该如何迁移因为我是hexo搭建的博客，然后我用的主题是next。 我们只需打开Disqus主页（需要翻墙），然后登录。 之后 get started 。 然后 website name 就是你的后面要用到的sortname 如果你也是hexo，就不用管installation直接跳到第三步设置。 这样就差不多了。 然后再设置里把你的 url填入你的域名。 最后在你的根目录下的config.yml里插入以下 disqus_shortname: your shortname 因为我是next主题。 然后在自己的主题文件下中的config.yml插入 1234disqus: enable: true shortname: count: true 之后在终端输入hexo clean &amp;&amp; hexo g -d 完成~~！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据库E-R图]]></title>
      <url>%2F2017%2F07%2F17%2FE-R%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[E-R图E-R图是指实体-关系-属性三个基本概括数据的基本结构. 强调ER模型设计的两大内容：一是将需求通过ER表达，另一个是将ER转换为关系模型。ER图是从实践归纳出来的理论方法，可以重新指导实践行为，既可以作为理解和表达用户数据需求的手段，同时也构成如何生成关系模型的依据。 ER图的实体（entity）即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示，每个实体都有自己的实体成员（entity member）或者说实体对象（entity instance），例如学生实体里包括张三、李四等，实体成员（entity member）/实体实例（entity instance） 不需要出现在ER图中。 ER图的属性（attribute）即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性，用椭圆形表示，属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。 ER图的关系（relationship）用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系，关系用菱形来表示。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GraphQL基本操作]]></title>
      <url>%2F2017%2F07%2F17%2FGraphQL%2F</url>
      <content type="text"><![CDATA[GraphQL()操作(operation) 查询(Query) 修改(mutation) 123456query&#123; clent(id:1)&#123; id name &#125;&#125; client 是查询的operation (id:1)包含了传入给Query的参数 查询包含id和name字段,这些字段也是我们希望查询可以返回的. server会给这个查询返回什么： 12345678&#123; "data": &#123; "client": &#123; "id": "1", "name": "Uncle Charlie" &#125; &#125;&#125; server会返回一个JSON串。这个JSON的schema和查询的基本一致。 变量(Variable)1234567891011121314151617181920212223query($clientId: Int) &#123; client(id: $clientId) &#123; name dob &#125; purchases(client_id: $clientId) &#123; date quantity total product &#123; name price product_category &#123; name &#125; &#125; client &#123; name dob &#125; &#125;&#125; 123&#123; "clientId": 1&#125; Mutation（修改）增、删、改一类的operation在GraphQL里统称为Muration（修改） create_client增加 12345678910mutation &#123; create_client ( name: "查理大叔" dob: "2017/01/28" ) &#123; id name dob &#125;&#125; update_client更新 12345678910mutation &#123; update_client ( id: 5 dob: "1990/01/01" ) &#123; id name dob &#125;&#125; destroy_client删除 123456mutation &#123; destroy_client(id: 5) &#123; name dob &#125;&#125; 强类型由于 GraphQL 是一个强类型语言，所以它可以在执行查询之前检查每个查询语句是否满足事先设定的 schema，符合则合法，如果查询语句不合法则不进行查询。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Router]]></title>
      <url>%2F2017%2F07%2F17%2FReact-Router%2F</url>
      <content type="text"><![CDATA[React-Router路径语法路由路径是匹配一个（或一部分）URL 的 一个字符串模式。大部分的路由路径都可以直接按照字面量理解，除了以下几个特殊的符号： :paramName – 匹配一段位于 /、? 或 # 之后的 URL。 命中的部分将被作为一个参数 () – 在它内部的内容被认为是可选的 * – 匹配任意字符（非贪婪的）直到命中下一个字符或者整个 URL 的末尾，并创建一个 splat 参数 12345678910//匹配 /hello/michael 和 /hello/ryan&lt;Route path=&quot;/hello/:name&quot;&gt; //匹配 /hello, /hello/02 和 /hello/01&lt;Route path=&quot;/hello(/:id)&quot;&gt; //匹配 /files/hello.jpg和/files/path/to/hello.jpg&lt;Route path=&quot;/files/*.*&quot;&gt; Histories常用的 history 有三种形式， 但是你也可以使用 React Router 实现自定义的 history。 browserHistory (推荐) hashHistory createMemoryHistory 1&lt;Router history=&#123;browserHistory&#125;&gt; browserHistoryBrowser history 是使用 React Router 的应用推荐的 history。它使用浏览器中的 History API 用于处理 URL，创建一个像example.com/some/path这样真实的 URL 。 在组件外部使用导航虽然在组件内部可以使用 this.context.router 来实现导航，但许多应用想要在组件外部使用导航。使用Router组件上被赋予的history可以在组件外部实现导航。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React State与Props的小心思]]></title>
      <url>%2F2017%2F06%2F30%2FReact-State%E4%B8%8EProps%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D%2F</url>
      <content type="text"><![CDATA[忙于期末考。。很久都没有更新博客了！因为找了个实习需要React所以这里写写自己在看React的官方文档中，遇到的问题。 Props与State很容易让我经常弄混先来说说Props 官方解释 组件从概念上看就是函数，之后这个组件可以接受任意的输入值，并返回一个需要页面上展示的React元素。那么这个输入值就为props。 个人理解 props是不可变的，传入什么值进去，最后返回的也是传入的值。也就是说，只读。 props父子传递12345678910111213141516function Uesr(props)&#123; return( &lt;div className=&#123;'abc'+ props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; );&#125;------------------------------------------------------------------------ function My()&#123; return( &lt;User color="red"&gt; &lt;h1&gt;nihao&lt;/h1&gt; &lt;/User&gt; );&#125; 在JSX标签内的任何内容都将通过children属性传入User。因为User在一个div内渲染了{props.children}，所以被传递的所有元素都会出现在最终输出中。 其实，我们也可以不用children。借用React官方文档的例子： 1234567891011121314151617181920212223242526272829303132function Contacts() &#123; return &lt;div className="Contacts" /&gt;;&#125;function Chat() &#123; return &lt;div className="Chat" /&gt;;&#125;function SplitPane(props) &#123; return ( &lt;div className="SplitPane"&gt; &lt;div className="SplitPane-left"&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className="SplitPane-right"&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; );&#125; 接下来Statestate怎么工作？通过调用setState(data,callback)方法，改变状态，就会触发React更新UI。 什么时候组件需要state呢？一般来说，大部分的组件应该从props属性中获取数据然后渲染。那么在！ 用户输入，服务器交互，这些情况下会用到State。在官方上说，尽可能的保持你的组件无状态化。 通过看官方文档。。我发现他们的模式是：构建几个无状态的组件用来渲染数据，然后在这些之上去构建一个有状态的组件同用户和服务器交互，数据通过props传递给无状态组件。 setState:更新组件状态。 setState会触发diff算法：判断state和页面结果的区别，是否需要更新。 状态(state)和属性(props)对比 状态和属性都会触发render更新，都是纯JS对象 状态：是和自己相关的，既不受父组件也不受子组件影响 属性：本身是不能自己去修改的，只能从父组件获取属性，父组件也能修改它的属性 根本的区别：组件在运行时需要去修改维护的就是状态]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript闭包]]></title>
      <url>%2F2017%2F05%2F22%2FJavaScript%E9%97%AD%E5%8C%85%2F</url>
      <content type="text"><![CDATA[闭包/bibao/Closures什么是闭包MDN对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 阮老师对闭包的定义为： 闭包就是能够读取其他函数内部变量的函数。 可以把闭包简单理解成”定义在一个函数内部的函数”。 红宝书对闭包的定义为： 闭包是指有权访问另一个函数作用域中的变量的函数 那么圣经犀牛书对闭包定义为： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为‘闭包’” 我个人比较认同红宝书的定义。 12345678function foo()&#123; var a = 2; function bar()&#123; console.log(a); // 2 &#125; bar();&#125;foo(); 我们来做一个数组求和 123456function sum(arr)&#123; return arr.reduce(function(x,y)&#123; return x+y; &#125;);&#125;sum([3,4,5,6]); //18 但是我们想要返回函数 12345678function smallsum(arr)&#123; var sum = function()&#123; return arr.reduce(function(x,y)&#123; return x+y; &#125;); &#125; return sum;&#125; 当我们想要用smallsum的时候返回的却是个函数。 1var result = smallsum([3,4,5,6]); //function sum() 直到我们调用result 1result(); //18 在这个例子中，我发现内部函数sum可以调用外部函数smallsum的参数和局部变量。 当我们调用smallsum的时候，每次调用都会产生一个新的函数。即使你传入的值相同。 123var result1 = smallsum([3,4,5,6]);var result2 = smallsum([3,4,5,6]);result1 === result2; //false 假如123456789function l()&#123; var arr= []; for(var i=0;i&lt;4;i++)&#123; arr.push(function()&#123; return i; &#125;); &#125; return arr;&#125; 12345678var a= l();var f1=a[0];var f2=a[1];var f3=a[2];f1(); //4f2(); //4f3(); //4 12345678910111213141516171819function l()&#123; var arr= []; for(var i=0;i&lt;4;i++)&#123; arr.push((function(n)&#123; return function()&#123; return n; &#125; &#125;)(i)); &#125; return arr;&#125;var a= l();var f1=a[0];var f2=a[1];var f3=a[2];f1(); //0f2(); //1f3(); //2 注意这里用了一个“创建一个匿名函数并立刻执行”的语法： 123(function (n) &#123; return n;&#125;)(1); //1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript作用域与作用域链]]></title>
      <url>%2F2017%2F05%2F18%2FJavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[Javascript作用域与作用域链作用域简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。 变量作用域全局变量拥有全局作用域。在JavaScript任何地方都是有定义的。123456var l="我是全局变量"; //声明了一个全局变量function scope()&#123; var l="我是局部变量"; //声明了一个同名的局部变量 return l;&#125;scope() //输出“我是局部变量” 在函数内声明变量前不加var就是一个全局变量。 123456789var l="我是全局变量";function scope()&#123; l="我还是全局变量"; //改变了全局变量 m="我是一个新的全局变量"; //声明了一个新的全局变量 return [l,m];&#125;scope() //输出"我是一个新的全局变量"lm 在函数内声明的变量只在函数内有定义，它们是局部变量，作用域是局部性的。12345678910var l="我是全局变量";function scope()&#123; var l="我是局部变量"; function scope1()&#123; var l="我是一个新的局部变量"; //嵌套作用域内的局部变量 return l; //返回当前作用域内的值 &#125; return scope1();&#125;scope(); //嵌套作用域 函数作用域和声明提前函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。只是改变函数内部。 变量在声明它们的函数体以及这个函数体嵌套的任意的函数体内都是有定义的。 123456function func() &#123; console.log(num); //输出：undefined，而非报错，因为变量num在整个函数体内都是有定义的 var num = 1; //声明num 在整个函数体func内都有定义 console.log(num); //输出：1 &#125; func(); 再看看下面这个例子： 123456789var num=2;function func() &#123; var num; console.log(num); //输出：undefined，而非报错，因为变量num在整个函数体内都是有定义的 var num = 1; //声明num 在整个函数体func内都有定义 console.log(num); //输出：1 &#125; console.log(num); //输出2 func(); 作用域链用途： 保证对执行环境有权访问的所有变量和函数的有序访问。 作用域链上有两个对象。 第一个是定义函数参数和局部变量的对象 第二个是全局对象 当定义一个函数时，它实际上保存一个作用域链。 高程三下这个例子就特别好 1234567891011121314var color = "blue";function changeColor()&#123; var anotherColor = "red"; function swapColors()&#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; //能访问 color、anotherColor、tempColor。 &#125; swapColors(); //能访问color、anotherColor不能访问tempColor。&#125;changeColor(); //只能访问color changeColor()的作用域链中只包含2个对象：它自己的变量对象和全局变量对象。所以它不能访问swapColor()的环境。 那么在swapColors()的作用域链中又3个对象：swapColors()的变量对象、changeColor()的变量对象和全局变量对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript——16道算法题]]></title>
      <url>%2F2017%2F05%2F15%2FJavaScript%E2%80%94%E2%80%9416%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
      <content type="text"><![CDATA[Let‘s go1.Reverse a String翻转字符串 先把字符串转化成数组，再借助数组的reverse方法翻转数组顺序，最后把数组转化成字符串。 你的结果必须得是一个字符串 这是一些对你有帮助的资源: Global String Object String.split() Array.reverse() Array.join() reverseString(&quot;hello&quot;) 应该返回 &quot;olleh&quot;. 1234function reverseString(str) &#123; return str.split('').reverse().join('');&#125;reverseString("hello"); 2.Factorialize a Number计算一个整数的阶乘 如果用字母n来代表一个整数，阶乘代表着所有小于或等于n的整数的乘积。 阶乘通常简写成 n! 例如: 5! = 1 * 2 * 3 * 4 * 5 = 120 这是一些对你有帮助的资源: Arithmetic Operators factorialize(5) 应该返回 120. 12345678910function factorialize(num) &#123; if(num&lt;0)&#123; return -1; &#125;else if(num ===0||num===1)&#123; return 1; &#125;else&#123; return (num*factorialize(num-1)); &#125;&#125;factorialize(5); 3.Check for Palindromes如果给定的字符串是回文，返回true，反之，返回false。 如果一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样，那么这个字符串就是palindrome(回文)。 注意你需要去掉字符串多余的标点符号和空格，然后把字符串转化成小写来验证此字符串是否为回文。 函数参数的值可以为&quot;racecar&quot;，&quot;RaceCar&quot;和&quot;race CAR&quot;。 这是一些对你有帮助的资源: String.replace() String.toLowerCase() palindrome(&quot;race car&quot;) 应该返回 true. palindrome(&quot;not a palindrome&quot;) 应该返回 false. 123456789101112function palindrome(str) &#123; // Good luck! var re = /[\W_]/g; var slo=str.toLowerCase().replace(re,""); var slow=slo.split('').reverse().join(''); if(slo==slow)&#123; return true;&#125; else&#123; return false; &#125;&#125;palindrome("我爱你"); 4.Find the Longest Word in a String找到提供的句子中最长的单词，并计算它的长度。 函数的返回值应该是一个数字。 这是一些对你有帮助的资源: String.split() String.length findLongestWord(&quot;The quick brown fox jumped over the lazy dog&quot;) 应该返回 6. 123456789101112function findLongestWord(str) &#123; var arr=str.split(' '); var long=0; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i].length&gt;long)&#123; long=arr[i].length; &#125; &#125; return long;&#125;findLongestWord("The quick brown fox jumped over the lazy dog"); 5.Title Case a Sentence确保字符串的每个单词首字母都大写，其余部分小写。 像’the’和’of’这样的连接符同理。 这是一些对你有帮助的资源: String.split titleCase(&quot;I&#39;m a little tea pot&quot;) 应该返回 “I’m A Little Tea Pot”. 1234567891011function titleCase(str) &#123; var arr=str.toLowerCase().split(' '); var l=[]; for(var i=0;i&lt;arr.length;i++)&#123; var str1=arr[i].slice(0,1).toUpperCase()+arr[i].slice(1); l.push(str1); &#125; return l.join(' ');&#125;titleCase("I'm a little tea pot"); 首先我们需要把这个字符串的每一项都变成小写字母并转换成数组 创建一个保存新的空数组 用遍历数组的长度。之后我们把每一项数组的第一个字母用slice()变成大写。 再push到空的数组里。 最后用join()数组返回字符串。 6.Return Largest Numbers in Arrays右边大数组中包含了4个小数组，分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新数组。 提示：你可以用for循环来迭代数组，并通过arr[i]的方式来访问数组的每个元素。 这是一些对你有帮助的资源: Comparison Operators largestOfFour([[13, 27, 18, 26], [4, 5, 1, 3], [32, 35, 37, 39], [1000, 1001, 857, 1]]) 应该返回 [27,5,39,1001]. 第一种方法1234567891011function largestOfFour(arr) &#123; // You can do this! var l=[]; for(var i=0;i&lt;arr.length;i++)&#123; arr[i].sort(function(a,b)&#123;return b-a&#125;); &#125; l.push(arr[i][0]);&#125;return l;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); 第二种方法 123456789101112function largestOfFour(arr) &#123; // You can do this! var temp = []; for(var i = 0; i &lt; arr.length; i++)&#123; var l = arr[i].reduce(function(prev,cur,index,array)&#123; return prev &gt; cur ? prev : cur; &#125;); temp.push(l); &#125; return temp;&#125;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端面试题]]></title>
      <url>%2F2017%2F05%2F07%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
      <content type="text"><![CDATA[前端面试题题目来自朴灵大大的github 介绍JavaScript的基本数据类型JavaScript有5种简单数据类型： Undefined、Null、Boolean、Number、String。还有一种复杂数据类型Object。 typeof操作符用typeof操作符能检测给定变量的数据类型。（括号中是自己的理解意思） “undefined” ————这个值没有被定义。（这个变量存在但是没有给它值） “boolean” ————这个值是布尔值。（这个值有true或false输出） “string” ————这个值是字符串。（字符串或字符序列） “number” ————这个值是数值。（字面意思） “object” ————这个值是对象或null。(这个值可能是个对象或者空) “function” ————这个值是函数。(字面意思) 12var message="wa";alert(typeof wa); //string Undefined类型使用var声明变量但没有给它加以初始化，这个变量的值就是undefined。 12var message;alert(message == undefined); //true Null类型null表示一个空对象指针，但是用typeof操作符检测null会返回object的原因是什么？ 12var car =null;alert("typeof car"); //"object" 只要意在保存对象的变量还没有真正的保存对象，就应该明确地让该变量保存null值。这样有助于进一步区分null和undefined。 Boolean类型这个字母值就是true、false。但是这两个值和数字不是一回事情。所以 true不一定等于 1 ， false不一定等于 0 。 还有布尔值是区分大小的 True和 False都不是 Boolean值。 Number类型 浮点数值 数值范围 最小值保存在Number.MIN_VALUE ： 5e-324。 保存着-Infinity 最大值保存在Number.MAX_VALUE : 1.796931348623157e+308。保存着Infinity。 想确定一个数值是否有穷可以用isFinite()函数。这个函数会在最小和最大数值之间会返回 true。 1alert(isFinite(result)); NaN（Not a Number） 任何涉及NaN的操作（NaN/10）都会返回 NaN。 还有 NaN与任何值都不想等，包括 NaN本身。 实际上0除以0才会返回 NaN，正数除以0返回 Infinity，负数除以0返回 -Infinity。 isNaN()函数可以确定这个函数是否不是数值。这个函数在收到一个值后会去尝试将转换为数值。不能被转换就返回true。 数值转换 三个函数 可以 把非数值转换为数值。 Number() 可以用于任何数据类型 parseInt() 字符串转换成数值 parseFloat() 字符串转换成数值 String类型由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以用双引号（”）或单引号（’）表示。 字符字面量——转义序列 （\n 换行 ​ \t 制表···） 字符串的特点——字符串是不可改变的。一旦创建，它们的值就不能改变。要改变就要先摧毁。 12var lang="Java";lang=lang+"Script"; 转换为字符串 使用 toString()方法 但是null和undefined没有这个方法所以， 就使用String()方法 Object类型对象其实就是一组数据和功能的集合。 1var o =new Object(); 说说写JavaScript的基本规范？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue.js小记]]></title>
      <url>%2F2017%2F04%2F28%2FVue.js%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[#Vue小记 v-bind 缩写： ： 修饰符 .prop - 被用于绑定DOM属性 .camel 用法 动态的绑定一个或多个特性，或一个组件prop到表达式 1&lt;a v-bind:href="url" href="#"&gt;&lt;/a&gt; 在这里:href是参数，通过v-bind指令将该元素的href属性与表达式的url绑定。 v-if1&lt;p v-if="seen"&gt;Now you see me&lt;/p&gt; 这个v-if指令将判断seen的真假值来移出/插入&lt;p&gt;元素。 v-on 缩写：@ 1&lt;a v-on:click="doSomething"&gt; 这个指令是用来监听DOM事件。 事件修饰符 .stop .prevent .capture .self .once 12345678910111213141516&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;2.1.4新增&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once="doThis"&gt;&lt;/a&gt; 按键修饰符1234567&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13="submit"&gt;记住keyCode各种值很难所以提供了别名&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt; .enter .tab .delete(捕获“删除”和“退格”按键) .esc .space .up .down .left .right 2.1.0新增 .ctrl .alt .shift .meta(Mac上为(⌘)在windows上为(⊞)) v-for我们用 v-for 指令根据一组数组的选项列表进行渲染。 v-for 指令需要以 item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名。 12345&lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789var example1 = new Vue(&#123; el: '#example-1', data: &#123; items: [ &#123;message: 'Foo' &#125;, &#123;message: 'Bar' &#125; ] &#125;&#125;) 结果： Foo Bar v-model你可以用 v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件以更新数据，并特别处理一些极端的例子。 具体看]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6箭头函数]]></title>
      <url>%2F2017%2F04%2F27%2FEs6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[简单地说， 12345var a = x =&gt; x;//var a =function(x)&#123; return x;&#125;; 这个就是最简单的箭头函数。 接着如果箭头函数不需要参数或者多个参数的话， 1234567var a = () =&gt; 1;//var a =function()&#123; return 1;&#125;;或者var a = _ =&gt;1; 12345var sum = (num1,num2) =&gt;num1 +num2;//var sum =function(num1,num2)&#123; return num1+num2;&#125;; 箭头函数没有自己的this， 123456(function ()&#123; return [ (()=&gt; this.x).bind(&#123;x :'inner'&#125;)() ]&#125;).call(&#123;x :'outer'&#125;);//['outer'] 所以bind的方法无效。并且call(),apply(),也无效。 MDN上的 1234567891011121314151617181920var adder = &#123; base : 1, add : function(a) &#123; var f = v =&gt; v + this.base; return f(a); &#125;, addThruCall: function(a) &#123; var f = v =&gt; v + this.base; var b = &#123; base : 2 &#125;; return f.call(b, a); &#125;&#125;;console.log(adder.add(1)); // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[初入React+Webpack(入门)]]></title>
      <url>%2F2017%2F04%2F27%2F%E5%88%9D%E5%85%A5React%2F</url>
      <content type="text"><![CDATA[因为需要做一个自己的小想法以后需要去实现把这个想法变成项目，在重多得框架中选择React.js，因为它需要学习成本，所以我觉得我在学习的过程中能学到很多东西。 通过npm使用React建议在 React 中使用 CommonJS 模块系统，比如 browserify 或 webpack。使用 react 和 react-dom npm 包. 我使用webpack来安装React DOM的 12$ npm install --save react react-dom babelify babel-preset-react$ browserify -t [ babelify --presets [ react ] ] main.js -o bundle.js 那么第一步肯定是创建Hello World啦~ 我们需要创建一个helloworld.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;Hello React!&lt;/title&gt; &lt;script src="build/react.js"&gt;&lt;/script&gt; &lt;script src="build/react-dom.js"&gt;&lt;/script&gt; &lt;script src="https://npmcdn.com/babel-core@5.8.38/browser.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在代码中 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); 这是jsx语法。可以去 JSX 语法 里学习更多 JSX 相关的知识。为了把 JSX 转成标准的 JavaScript，我们用 &lt;script type=&quot;text/babel&quot;&gt; 标签，并引入 Babel 来完成在浏览器里的代码转换。在浏览器里打开这个html，你应该可以看到成功的消息！ 分离文件那么我们在React中也是可以分离js的。 我们需要创建一个下面的build/helloworld.js 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example')); 之后我们在html的文件中像以前引用文件一样去引用就可以了。 1&lt;script type="text/babel" src="src/helloworld.js"&gt;&lt;/script&gt; 但是我是用chrome不会显示效果。之后我用safari效果成功显示，后来打开控制台发现http以外的协议加载失败了。读取不了&lt;script src=&quot;https://npmcdn.com/babel-core@5.8.38/browser.min.js&quot;&gt;&lt;/script&gt;那么就我就去跟着开发文档配置了babel。 BabelBabel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看：Babel Webpack(入门)webpack是什么？webpack是一个模块化打包工具，使用js作为载体将所有静态资源打包在一起，支持的loader和plugin等能对各种静态资源进行预处理，极大地方便了前端的工程化开发。详情参考官网 ###开始使用Webpack我们来一步一步去开始学习使用Webpack。 ###安装Webpack可以使用npm安装，新建一个空白的文件夹（我的为webpackwhat），在终端中转到该文件夹下（cd webpackwhat）进行安装。 1234//全局安装npm install -g webpack//安装到你的项目目录npm install --save-dev webpack 我们在终端中使用npm init的命令可以自动创建这个package.json文件 1npm init 输入后，会有一些需要你输入的信息，你只需要一直回车就行了。 接下来我们在这个文件夹下进行安装Webpack作为依赖包 12//安装Webpacknpm install --save-dev webpack 回到之前的空文件夹，并在里面创建两个文件夹,app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放准备给浏览器读取的数据（包括使用webpack生成的打包后的js文件以及一个index.html文件）。在这里还需要创建三个文件，index.html 文件放在public文件夹中，两个js文件（Greeter.js和main.js）放在app文件夹中. index.html文件只有最基础的html代码，它唯一的目的就是加载打包后的js文件（bundle.js） 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='root'&gt; &lt;/div&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Greeter.js只包括一个用来返回包含问候信息的html元素的函数。 123//main.js var greeter = require(&apos;./Greeter.js&apos;);document.getElementById(&apos;root&apos;).appendChild(greeter()); main.js用来把Greeter模块返回的节点插入页面。 123456// Greeter.jsmodule.exports = function() &#123; var greet = document.createElement(&apos;div&apos;); greet.textContent = &quot;Hi there and greetings!&quot;; return greet;&#125;; 正式使用Webpack12//webpack非全局安装的情况node_modules/.bin/webpack app/main.js public/bundle.js 可以看出webpack同时编译了main.js 和Greeter,js,现在打开index.html,可以看到如下结果 通过配置文件来使用WebpackWebpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如已经提到的，这样不太方便且容易出错的，一个更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，可以把所有的与构建相关的信息放在里面。 还是继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，并在其中进行最最简单的配置，如下所示，它包含入口文件路径和存放打包后文件的地方的路径。 1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 更快捷的执行打包任务执行类似于node_modules/.bin/webpack这样的命令其实是比较烦人且容易出错的，不过值得庆幸的是npm可以引导任务执行，对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可，设置方法如下。 12345678910111213&#123; &quot;name&quot;: &quot;webpack-sample-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Sample webpack project&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令 &#125;, &quot;author&quot;: &quot;zhang&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^1.12.9&quot; &#125;&#125; 注：package.json中的脚本部分已经默认在命令前添加了node_modules/.bin路径，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。 npm的start是一个特殊的脚本名称，它的特殊性表现在，在命令行中使用npm start就可以执行相关命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build Loaders鼎鼎大名的Loaders登场了！ Loaders是webpack中最让人激动人心的功能之一了。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。 Loaders需要单独安装并且需要在webpack.config.js下的modules关键字下进行配置，Loaders的配置选项包括以下几方面： test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 继续上面的例子，我们把Greeter.js里的问候消息放在一个单独的JSON文件里,并通过合适的配置使Greeter.js可以读取该JSON文件的值，配置方法如下 12//安装可以装换JSON的loadernpm install --save-dev json-loader 12345678910111213141516171819202122232425module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123;//在配置文件里添加JSON loader loaders: [ &#123; test: /\.json$/, loader: &quot;json&quot; &#125; ] &#125;, devServer: &#123; contentBase: &quot;./public&quot;, colors: true, historyApiFallback: true, inline: true &#125;&#125; 创建带有问候信息的JSON文件(命名为config.json) 1234//config.json&#123; &quot;greetText&quot;: &quot;Hi there and greetings from JSON!&quot;&#125; 更新后的Greeter.js 1234567var config = require(&apos;./config.json&apos;);module.exports = function() &#123; var greet = document.createElement(&apos;div&apos;); greet.textContent = config.greetText; return greet;&#125;; Loaders很好，不过有的Loaders使用起来比较复杂，比如说Babel。 BabelBabel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过编译帮你达到以下目的： 下一代的JavaScript标准（ES6，ES7），这些标准目前并未被当前的浏览器完全的支持； 使用基于JavaScript进行了拓展的语言，比如React的JSX Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，不过webpack把它们整合在一起使用，但是对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包）。 我们先来一次性安装这些依赖包 12// npm一次性安装多个依赖模块，模块之间用空格隔开npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react 在webpack中配置Babel的方法如下 123456789101112131415161718192021222324252627282930313233module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json-loaders&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loaders&apos;,//在webpack的module部分的loaders里进行配置即可 query: &#123; presets: [&apos;es2015&apos;,&apos;react&apos;] &#125; &#125; ] &#125;, devServer: &#123; contentBase: &quot;./public&quot;, colors: true, historyApiFallback: true, inline: true &#125;&#125; 现在你的webpack的配置已经允许你使用ES6以及JSX的语法了。继续用上面的例子进行测试，不过这次我们会使用React，记得先安装 React 和 React-DOM 1npm install --save react react-dom 使用ES6的语法，更新Greeter.js并返回一个React组件 123456789101112131415//Greeter,jsimport React, &#123;Component&#125; from &apos;react&apos;import config from &apos;./config.json&apos;;class Greeter extends Component&#123; render() &#123; return ( &lt;div&gt; &#123;config.greetText&#125; &lt;/div&gt; ); &#125;&#125;export default Greeter 使用ES6的模块定义和渲染Greeter模块 12345import React from &apos;react&apos;;import &#123;render&#125; from &apos;react-dom&apos;;import Greeter from &apos;./Greeter&apos;;render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;)); Babel的配置选项Babel其实可以完全在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下： 1234567891011121314151617181920212223242526// webpack.config.jsmodule.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json-loaders&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loaders&apos; &#125; ] &#125;, devServer: &#123;...&#125; // Omitted for brevity&#125; 1234//.babelrc&#123; &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;]&#125; 到目前为止，我们已经知道了，对于模块，Webpack能提供非常强大的处理功能，那那些是模块呢。 CSSwebpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(...)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。 继续上面的例子 12//安装npm install --save-dev style-loader css-loader 123456789101112131415161718192021222324252627282930//使用module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/build&quot;, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.json$/, loader: &quot;json-loaders&quot; &#125;, &#123; test: /\.js$/, exclude: /node_modules/, loader: &apos;babel-loaders&apos; &#125;, &#123; test: /\.css$/, loader: &apos;style-loaders!css-loaders&apos;//添加对样式表的处理 &#125; ] &#125;, devServer: &#123;...&#125;&#125; 注：感叹号的作用在于使同一文件能够使用不同类型的loader 接下来，在app文件夹里创建一个名字为”main.css”的文件，对一些元素设置样式 12345678910111213141516171819html &#123; box-sizing: border-box; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%;&#125;*, *:before, *:after &#123; box-sizing: inherit;&#125;body &#123; margin: 0; font-family: &apos;Helvetica Neue&apos;, Helvetica, Arial, sans-serif;&#125;h1, h2, h3, h4, h5, h6, p, ul &#123; margin: 0; padding: 0;&#125; 你还记得吗？webpack只有单一的入口，其它的模块需要通过 import, require, url等导入相关位置，为了让webpack能找到”main.css“文件，我们把它导入”main.js “中，如下 12345678//main.jsimport React from &apos;react&apos;;import &#123;render&#125; from &apos;react-dom&apos;;import Greeter from &apos;./Greeter&apos;;import &apos;./main.css&apos;;//使用require导入css文件render(&lt;Greeter /&gt;, document.getElementById(&apos;root&apos;)); 通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独的文件的。 不过这也只是webpack把css当做模块而已，咱们继续看看一个真的CSS模块的实践。 感谢网上各大资源 参考以及转载（其中在原文中有些错误我已经更改） 入门Webpack，看这篇就够了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript变量+方法]]></title>
      <url>%2F2017%2F04%2F24%2FJavaScript%E5%8F%98%E9%87%8F%2F</url>
      <content type="text"><![CDATA[JavaScript变量+方法ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。 基本类型值指的是简单的数据段，而引用类型值指那些可能有多个值构成的对象。 传递参数12345678function addTen(num)&#123; num +=10; return num;&#125;var count =20;var result = addTen(count);alert(count); //20,没变化alert(result); //30 在这上面看了高程三的话懵懵懂懂，实际上在说的是，要执行alert(count);时count只是把20复制给参数num，以便20在addTen()中使用，在函数里面num的值确实+10变成了30，但是不影响外部count的变量。 方法 split() 方法讲一个字符串对象的每个字符拆出来，并且将每个字符串当数组的每个元素。 重排序方法 reverse()和sort() reverse()方法会反转数组项的顺序。 123var values = [1,2,3,4,5];values.reverse();alert(values); //5,4,3,2,1 而 sort()方法是按升序排列数组项。——最小的值位于前面，最大的值排在最后面。而且sort()方法会调用每个数组项的toString()转型方法，然后去比较得到的字符串。 123var values = [0,1,5,10,15];values.sort();alert(values); //0,1,10,15,5 在字符串的比较时，10则位于5的前面，于是数组的顺序就被修改了。当然改为降序也行参考注释 123456789function compare (value1,value2)&#123; if(value1 &lt;value2)&#123; return -1; //return 1; &#125;else if(value1 &gt;value2)&#123; return 1; //return -1; &#125;else&#123; return 0; &#125;&#125; 然后我们再把这个参数传给sort()方法即可。 123var values = [0,1,5,10,15];values.sort(compare);alert(values); //0,1,5,10,15]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript基本概念（高程3）]]></title>
      <url>%2F2017%2F04%2F11%2FJavaScript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5copy%2F</url>
      <content type="text"><![CDATA[JavaScript基本概念（高程3）JavaScript高级程序设计第三章数据类型typeof操作符“undefined”——如果这个值未定义; “boolean”——如果这个值是布尔值; “string”——如果这个值是字符串; “number”——如果这个值是数值; “object”——如果这个值是对象或null; “function”——如果这个值是函数; Undefined类型 Undefined类型只有一个值，即特殊的undefined。 Null类型 Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值会返回”object”的原因。 Boolean类型 Boolean类型是ECMAScript中使用得最多的一种类型，该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0. Number类型整数通过八进制（以8为基数）或十六进制（以16为基数）的字面值来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0~7）。 十六进制字面值的前两位必须是0x，后跟任何十六进制数字（0~9及A~F）。 浮点数值 永远不要测试某个特定的浮点数值。 如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。 数值范围 12var result= Number.MAX_VALUE +Number.MAX_VALUE;alert(isFinite(result)); //false NaN NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。 它本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不想等，包括NaN本身。例如， 1alert(NaN == NaN); //false 数值转换 1234var num1 = Number("Hello world"); //NaNvar num2 = Number(" "); //0var num3 = Number("000011"); //11var num4 = Number("true"); //1 String类型 字符字面量-也叫转义序列 字符串的特定 字符串一旦创建，它们的值就不能改变。 转换为字符串 要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的toString()方法。第二用String方法。 Object类型 constructor:保存着用于创建当前对象的函数。 hasOwnProperty（propertyName）:用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(“name”)）。 isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型。 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。与2方法一样，作为参数必须以字符串形式指定。 toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。 toString():返回对象的字符串表示。 valueOf():返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。 操作符一元操作符 递增和递减操作符 ​ 递增和递减操作符直接借鉴C。 位操作符 符号位的值决定了其他为数值的格式。 负数同样以二进制码存储，但使用的格式是二进制补码 按位非（NOT） 按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码。 1234var num1 = 25;//二进制00000000000000000000000000011001//二进制11111111111111111111111111100110var num2 = ~num1;alert(num2);//-26 按位与（AND） 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 0 0 1 0 0 0 0 简而言之，按位与操作只在两个数值的对应位都是1时才返回1，任何一位是0，结果都是0. 按位或（OR） 第一个数值的位 第二个数值的位 结果 1 1 1 1 0 1 0 1 1 0 0 0 按位或操作在有一个位是1的情况下就返回1，而只有在两个位都是0的情况下才返回0. 按位异或（XOR） 第一个数值的位 第二个数值的位 结果 1 1 0 1 0 1 0 1 1 0 0 0 按位异或与按位或的不同之处在于，这个操作两个数值对应位上只有一个1时才返回1，如果对应的两位都是1或是0，则返回0. 左移 左移操作符由两个小于号（&lt;&lt;）表示。 12var oldValue = 2; //等于二进制的10var newValue = oldValue &lt;&lt; 5;//等于二进制的1000000,十进制的64 有符号的右移 有符号的右移操作符由两个大于号（&gt;&gt;）表示。 12var oldValue = 64;//等于二进制的1000000var newValue = oldValue &gt;&gt; 5;//等于二进制的10，即十进制的2 无符号右移 无符号右移操作符由3个大于号（&gt;&gt;&gt;）表示。 12var oldValue = 64;//等于二进制的1000000var newValue =oldValue &gt;&gt;&gt; 5;//等于二进制的10，即十进制的2 无符号右移操作符会把负数的二进制码当成正数的二进制码。而且由于负数以其绝对值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大。 12var oldValue = -64;//等于二进制的11111111111111111111111111000000var newValue = oldValue &gt;&gt;&gt;5;//等于十进制的134217726 布尔操作符 逻辑非（！） 123456alert(!false); //truealert(!"blue"); //falsealert(!0); //truealert(!NaN); //truealert(!""); //truealert(!12345); //false 逻辑与（&amp;&amp;） 第一个操作数 第二个操作数 结果 true true true true false false false true false false false false 在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值。 逻辑或 true true true true false true false true true false false false 第一个操作数 第二个操作数 结果 与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值，]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript DOM编程艺术学习笔记一（第三章兼高程三）]]></title>
      <url>%2F2017%2F03%2F26%2FJavascript%20Dom%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%85%BC%E9%AB%98%E7%A8%8B%E4%B8%89%EF%BC%89%2F</url>
      <content type="text"><![CDATA[1.Dom基础Element 三种DOM方法可获取元素节点，分别是通过元素ID、通过标签名字和通过类名字来获取 getElementById 根据Id获取元素节点 getElementByTagName 根据Html获取元素节点 getElementByClassName 根据ClassName（class）获取元素节点 高程三中学到Html元素 id，元素在文档中的唯一标识 - title，有关元素的附加说明信息，一般通过工具提示条显示出来 lang，元素内容的语言比如中文zh-hans dir，语言的方向，值为”ltr”（left-to-right，从左至右）或”rtl”（right-to-left，从右至左），很少使用 className，与元素的class特性对应，即为元素指定的CSS类，没有将这个属性命名为class。 1&lt;div id="myDiv" class="bd" title="Body text" lang="en" dir="ltr"&gt;Some text&lt;/div&gt; 可以获得元素中指定的所有信息。 123456div = document.getElementById("myDiv"); alert(div.id); //"myDiv" alert(div.className); //"bd" alert(div.title); //"Body text" alert(div.lang); //"en" alert(div.dir); //"ltr" 还可以为每个属性赋予新的值。 123456div = document.getElementById("myDiv"); div.id = "someOtherId"; div.className = "ft"; div.title = "Some other text"; div.lang = "fr"; div.dir ="rtl"; 获取和设置属性 getAttribute getAttribute是一个函数。它只有一个参数——你打算查询的属性名字：1object.getAttribute(attribute); setAttribute 它允许我们对属性节点的值做出修改。 1object.setAttribute(&quot;attribute&quot;,value);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017Web程序员技术发展路线图]]></title>
      <url>%2F2017%2F03%2F22%2F2017Web%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E8%B7%AF%E7%BA%BF%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[这个是国外一个工程师的总结，在知乎上的前端技术文章精选专栏看见的，看着实用转来到这。 2017 年 Web 开发工程师技术发展路线图 下面的脑图展现了前端、后端以及 devops 技术栈的发展路线图，作者起初做这份技术发展脑图是给初学者和学生们准备的。 简介 前端开发工程师路线图 后端开发工程师路线图对于后端方面的技术，原作者表示比较喜欢和看好Nodejs、PHP7 以及 Ruby ，我自己觉得在国内来说 Nodejs 和 React Native 是目前很多前端开发工程师热衷探索的技术，而 Ruby 技术在国内始终不温不火，PHP技术比较传统。建议初学者们还是选择岗位更多的技术栈学习，当然如果你有自己喜欢的技术栈，那就可以暂时不考虑市场因素！ DevOps [GitHub链接:][1] [1] : kamranahmedse/developer-roadmap]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[配置SSH Key+Next主题以及个性化改动]]></title>
      <url>%2F2017%2F03%2F20%2F%E9%85%8D%E7%BD%AESSH%20Key%2BNext%E4%B8%BB%E9%A2%98%E4%BB%A5%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E6%94%B9%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[Git SSH Key 生成步骤Git是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。 第一次使用要设置Git的user name 和email1$ git config --global user.name 1$ git config --global user.email 查看你是否已经拥有密钥 1$cd ~/.ssh 如果没有的话就不会有此文件，有的话就会备份删除掉 生成密钥 1$ ssh-keygen -t rsa -C “user.email” 你将会遇到以下情况的处理： 12345678 Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): 直接回车Enter passphrase (empty for no passphrase): 直接回车Enter same passphrase again:Your identification has been saved in /root/.ssh/id_rsa. 公钥Your public key has been saved in /root/.ssh/id_rsa.pub. 私钥The key fingerprint is:4d:dd:48:af:76:c2:ba:a8:bc:20:f3:28:1d:6a:28:53 就是按3次回车，密码为空！最后你会得到两个文件：id_rsa和id_rsa.pub 把密钥加到Github或者码云或者Coding的SSH上我们需要把id_rsa.pub中的内容全选复制，然后粘贴进Pages的各自SSH地方，当然需要输入密码。 测试SSHGithub：1$ssh -T git@github.com 码云：1$ssh -T git@git.oschina.net Coding:1$ssh -T git@coding.net 若返回则配置成功github:1234The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added ‘github.com,207.97.227.239′ (RSA) to the list of known hosts. 码云：Welcome to Git@OSC, yourname!Coding：Enter passphrase for key ‘/c/Users/Yuankai/.ssh/id_rsa’: Coding.net Tips : [ Hello Kyle_lyk! You have connected to Coding.net by SSH successfully! ]那么配置好，我们就可以把Hexo部署到Git上了1$hexo deploy Hexo之Next Hexo有很多主题，有大道至简的maupassant 也有casper还有uno。但是我还是最喜欢next的风格。 安装Next安装Next是非常的简单。如果你熟悉Git那么你就可以直接使用Git checkout代码：12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 还有一种方法是下载稳定版本 前往Next版本发布页面 一直下拉找到Source code(zip)点击即可下载 之后把下载的压缩包至站点的themes目录下，并将解压后的文件名改为next。 启用Next 你需要打开你的站点目录找到_config.yml这个文件，记住不是themes下next中的_config.yml。 我们需要在站点文件_config.yml中ctrl+F打入theme字段，并将其值改为next：1theme:next 验证主题是否生成完成首先我们要右击你的站点然后选择Git Bash Here，并开启调试模式。1$ hexo s --debug 命令行出现：1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 那么我们就可以在网址上输入http://0.0.0.0:4000去查看效果，检查站点是否正确运行。 Next各种细节主题设定Scheme 是Next提供的一种特性，就因为Scheme我们有三种选择外观。 Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新Scheme 的切换通过更改 主题配置文件（theme/next下的_config.yml），搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。123#scheme: Muse#scheme: Mistscheme: Pisces 还有更多的小东西大家可以去Next官方文档看。比如说 菜单， 侧栏， 头像， 作者昵称， 站点描述， 第三方服务等。 Next中foot更改我把原来的什么Hexo啊..Next.Pisces啊通通改了，这才像我们自己的博客呀！没得说。我们需要打开next下的layout接着打开_partials下的footer.swig。然后我们要把其中红框里的删除。紧接着我们回到next下，找到languages，打开zh-Hans.yml。我们可以改成如下：123footer: powered: &quot;个人专属 &quot; theme: Adherent 看大家的想法自己随意发挥！好啦，我要去研究SEO了！！祝大家建博成功]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Node.js+hexo部署博客]]></title>
      <url>%2F2017%2F03%2F20%2FNode.js%2Bhexo%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[初衷想了很久，还是要弄个博客来勉励自己来督促自己学习去记录。因为学生党，没能抢到腾讯云+阿里云学生优惠，又用过github pages而且挺想用markdown写作，就选择Hexo来搭建自己的博客。也许有人会说为什么不用Jekyll，因为我所用的是windows系统，而且不建议在windows系统下安装Jekyll，还有我准备发展方向是前端。hexo是基于Node.js而Jekyll是基于Ruby所以你懂的！还有我查了一下Hexo是台湾的程序员开发的，原生态支持中文。Node.js+Hexo。是因为我对js的热爱还有因为是台湾同胞的作品，所去选择的。现在我也就把自己搭建流程说一下以及自己遇到的问题着重提一下。 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Node下载安装Node注意事项Node.js根据自己电脑/喜好去选择是否用安装包还是绿色安装！建议路径中不要包含空格或者其他特殊字符，防止出现莫名其妙的错误，最好纯英文。 环境配置各种都要配置环境，Node也不例外。如果你的文件路径为D:\node也就是你Node.exe所在的位置。回到桌面点击（我是win10，win7,win8方法类似）我的电脑右键-属性-高级系统设置-高级-环境变量在Path项中加入D:\node这个路径。之后我们win+R打入cmd命令行去执行npm命令，如果没有提示找不到命令，则说明Node安装成功，如果有的话去看看自己是不是环境配置没有配置好。 配置国内镜像在国内可以用淘宝NPM镜像，这样各种安装和使用npm快很多而且还可以代替npm。你只要运行下面的命令1npm install -g cnpm --registry=https://registry.npm.taobao.org 同样测试有没有安装好，这次打cnpm就行拉，结果显示与上述相同。那么以后我们只要执行跟npm的命令时我们只要把npm替换成cnpm就行了！ 安装Git下载Git程序包作为萌新最希望能一步一步来，我也就一步一步和大家说，也为了以后自己注意一些Git的小细节。 windows下安装Git SCM Mac下安装GitSCM Linux and Unix下安装GitSCM 附上git使用简易指南 环境配置同样Git也需要环境配置，与Node配置一致。你Git的路径C:\Git\bin那么在Path中就可以这样写C:\Git\bin。下面要进入重点了！ 安装HexoHexo中文文档，我们把Hexo两大依赖Node.js和Git都已经安装配置完成。不出问题，那么下面则是水到渠成。接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli 有些人会发现执行上面那句下载缓慢还出错，那么因为我们已经用了淘宝NPM镜像我们直接使用以下命令：1$ cnpm install -g hexo-cli Windows Mac Linux Unix系统编译时遇到的问题则可以去Hexo中文文档里面寻找解决办法。 使用Hexo建站Hexo建站后产生的文件如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中最重要的是_config.yml这是网站的配置信息，我们可以在里面配置大部分的参数。去让我们的博客变得更加个性化。 创建站点找一个你自己想放你项目的目录，按住Shift然后在空白处右击打开Git Bash here执行下列命令，Hexo则会在指定的文件夹中新建所需要的文件。1$ hexo init site 然后我们再右键site文件夹执行以下命令：1$ hexo generate 这时，我们点开site会发现里面有个public的目录。这里面就是网站的静态文件。我们可以手动的把这些静态文件纳入git的仓库接着推送到开启page服务的分支上或者发布到Web服务器上。但是我还是推荐你们用Hexo的自动化部署。 自动化部署Hexo自动Git部署需要安装hexo-deployer-git，执行下列命令1cnpm install hexo-deployer-git --save 然后修改系统配置文件_config.yml（不是themes子目录下的主题配置文件）。修改deploy这一项的值，按照以下格式配置。如果没有这一项，直接在文件末尾添加即可。注意缩进，yml中使用缩进表示从属关系，用-表示一个序列（可以同时部署到多个仓库）。这里减号后有一个空格。以我的项目为例，配置内容如下：1234deploy:- type: git repo: git@git.coding.net:Adherent/Adherent.git branch: coding-pages type值不用修改，因为这里使用的是git的pages服务，类型就是git。repo为仓库地址，为了方便部署（免输账号密码），使用的是ssh协议的仓库地址。这需要配置ssh秘钥，具体参考生成并部署SSH key。branch为开启pages服务的分支名称。一般的，码云为osc-pages，Coding为coding-pages，GitHub为gh-pages。配置好部署信息后，即可用Hexo把静态页面部署到git上了。1hexo deploy 部署完成后，通过域名，应该就能访问到这些页面了。 部署SSH key则可以看我的部署SSH key的文章 Pages服务的选择都说做编程必须有GitHub而且上面还聚集了世界各地的开发者吧，因此很多人都在使用github的pages服务建站。但我还是推荐使用国内的码云或者Coding以获得更好的访问速度。Coding是支持自己添加域名的所以我选择用Coding。首先要创建一个项目，才能开启pages服务。可以去Coding Pages帮助中心看看如何开启以我的网站为例，项目地址为https://coding.net/u/Adherent/p/Adherent/git，开启pages服务的分支名称为coding-pages。项目初始化时并没有codingc-pages分支，可以等Hexo部署静态文件后再开启pages服务。 添加新文章博客建成，那么我们就可以写自己的博文了！执行下列命令：1$ hexo n 文章题目 以上命令就可以在source/_posts/目录中生成一个文件名为文章题目后缀名为.md`的文件。剩下的文件内容我们就可以用markdown语法写文章就好了。markdown语法参见Markdown 语法说明 (简体中文版)我推荐一款Cmd Markdown个人感觉用的还是很舒服的。这是Cmd Markdown的简明语法手册。然后执行以下命令即可生成新的页面，部署到git。1hexo g -d 同样的，把新添加的文件纳入git仓库，并推送到网上的仓库。123git add *git commit -m &quot;新的文章&quot;git push 到了这里，该系统已经能很好的运行了。更多的使用以及设置方法参考文档|Hexo即可。 参考文章 淘宝NPM镜像 git使用简易指南 文档|Hexo Cmd Markdown 启蒙`]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello, World!]]></title>
      <url>%2F2017%2F03%2F19%2FHello%20World%2F</url>
      <content type="text"><![CDATA[Hello World Hello World 第一篇就和大家打个招呼！ 多种语言的Hello World C 123456#include &lt;stdio.h&gt;int main()&#123; printf("Hello, World"); return 0;&#125; Java 12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("Hello World!"); &#125;&#125; Javascript 1console.log("Hello, World!"); Python 1print("Hello, World!") PHP 1echo 'Hello,World!'; Go 12345package mainimport "fmt"func main()&#123; fmt.Print("Hello, World!");&#125; setTimeout(function(){ console.log("I Love Mu"); alert("Hello, World!"); }, 5000);]]></content>
    </entry>

    
  
  
</search>
