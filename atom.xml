<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>壮壮-Technology</title>
  <subtitle>宠辱不惊，闲看庭前花落花开</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xuzihao.fun/"/>
  <updated>2017-12-10T10:35:26.925Z</updated>
  <id>http://xuzihao.fun/</id>
  
  <author>
    <name>XuZiHao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DOM</title>
    <link href="http://xuzihao.fun/DOM.html"/>
    <id>http://xuzihao.fun/DOM.html</id>
    <published>2017-12-10T07:17:00.000Z</published>
    <updated>2017-12-10T10:35:26.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文档对象模型"><a href="#文档对象模型" class="headerlink" title="文档对象模型"></a>文档对象模型</h1><p>一点小差异，IE中所有DOM对象都是以COM对象的形式实现的。</p>
<h2 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h2><p>每个节点的属性</p>
<ul>
<li>childNodes<ul>
<li>它里面有一个对象叫NodeList</li>
</ul>
</li>
<li>patentNode</li>
<li>previousSibling</li>
<li>nextSibling</li>
<li>ownerDoucment</li>
</ul>
<h2 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h2><ul>
<li>appendChild（）<ul>
<li>向childNodes列表的末尾添加一个节点</li>
</ul>
</li>
<li>insertBefour()<ul>
<li>​把节点放在childNodes列表的特定位置，它接受两参数要插入的节点，和作为参照的节点。</li>
</ul>
</li>
<li>replaceChild()<ul>
<li>把节点替换，这个方法接受两个参数：要插入的节点和要替换的节点</li>
</ul>
</li>
<li>removeChild()<ul>
<li>看英文就知道remove,移除。就只接受一个参数：就是你要移除的节点。</li>
</ul>
</li>
<li>cloneNode()<ul>
<li>这个方法接受一个布尔值参数，在参数为true进行深复制，反之则执行浅复制。</li>
</ul>
</li>
<li>normalize()<ul>
<li>处理文档树中的文本节点。</li>
</ul>
</li>
</ul>
<h2 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h2><p>nodeType的值是9.</p>
<p>document的对象是window对象的一个属性，因此可以将其作为全局对象来访问。</p>
<p>查找元素的方法：</p>
<ul>
<li>getElementById()</li>
<li>getElementByTagName()</li>
<li>getElementByName()</li>
<li>document.anchors<ul>
<li>包含文档中所有带name特性的<a>元素</a></li>
</ul>
</li>
<li>document.applets<ul>
<li>包含文档中所有的<applet>元素​</applet></li>
</ul>
</li>
<li>document.forms</li>
<li>document.images</li>
<li>document.links<ul>
<li>包含文档中所有带href特性的<a>元素</a></li>
</ul>
</li>
</ul>
<h2 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h2><p>nodeType的值是1。</p>
<p>它提供了对元素标签名、子节点及特性的访问。</p>
<p>操作特性的DOM方法：</p>
<ul>
<li>getAttribute()</li>
<li>setAttribute()</li>
<li>removeAttribute()</li>
</ul>
<p>attributes属性中包含一个NamedNodeMap，与NodeList类似，也是一个“动态”的集合。<br>NamedNodeMap对象有下列方法</p>
<ul>
<li>getNamedItem(name)<ul>
<li>返回nodeName属性等于name的节点</li>
</ul>
</li>
<li>removeNamedItem(name)<ul>
<li>从列表移除nodeName属性等于name的节点</li>
</ul>
</li>
<li>setNamedItem(node)<ul>
<li>向列表中添加节点，以节点的nodeName属性为索引</li>
</ul>
</li>
<li>item(pos)<ul>
<li>返回位于数字pos属性位置处的节点。</li>
</ul>
</li>
</ul>
<h2 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h2><p>nodeType的值是3</p>
<p>下列方法可以操作节点中的文本：</p>
<ul>
<li>appendData(text)<ul>
<li>将text添加到节点的末尾</li>
</ul>
</li>
<li>deleteData(offset, count)<ul>
<li>从<strong>offset</strong>指定的位置开始删除<strong>count</strong>个字符</li>
</ul>
</li>
<li>insertData(offset, text)<ul>
<li>在<strong>offset</strong>指定的位置插入<strong>text</strong></li>
</ul>
</li>
<li>replaceData(offset, count, text)<ul>
<li>用<strong>text</strong>替换从<strong>offset</strong>指定的位置开始到<strong>offset + count</strong>为止处的文本</li>
</ul>
</li>
<li>splitText(offset)<ul>
<li>从<strong>offset</strong>指定的位置将当前文本节点分成两个文本节点</li>
</ul>
</li>
<li><p>substringData(offset, count)</p>
<ul>
<li>提取从<strong>offset</strong>指定的位置开始到<strong>offset + count</strong>为止处的字符串</li>
</ul>
</li>
<li><p>document.createTextNode()</p>
<ul>
<li>接受一个参数就是，要插入的文本内容</li>
<li>document.createTextNode(“<strong>Hello</strong> world!”);</li>
</ul>
</li>
</ul>
<h3 id="文本节点合并"><a href="#文本节点合并" class="headerlink" title="文本节点合并"></a>文本节点合并</h3><p>normalize()</p>
<h3 id="文本节点分割"><a href="#文本节点分割" class="headerlink" title="文本节点分割"></a>文本节点分割</h3><p>splitText()</p>
<h2 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h2><p>nodeType的值是8</p>
<p>Comment类型与Text类型继承自相同的基类，所以它拥有除了splitText()之外的所有字符串操作方法。<br>document.createComment()<br>创建注释节点</p>
<h2 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h2><p>nodeType的值是4</p>
<p>CDATA区域只会出现在XML文档中</p>
<h2 id="DocumentType类型"><a href="#DocumentType类型" class="headerlink" title="DocumentType类型"></a>DocumentType类型</h2><p>nodeType的值是10</p>
<p>DocumentType包含着与文档的doctype有关的所有信息。</p>
<h2 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h2><p>nodeType的值是11</p>
<p>DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为DocumentFragment不是真实DOM树的一部分，它的变化不会引起DOM树的重新渲染的操作(reflow) ，且不会导致性能等问题。</p>
<p>该接口继承 Node 的全部方法，并实现了 ParentNode 接口中的方法。</p>
<h2 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h2><p>nodeType的值是2.</p>
<p>Attr对象有三个属性：name、 value、 specified</p>
<p>#总结：<br>DOM由各种节点构成：</p>
<ol>
<li>最基本的节点类型是Node;所有其他类型都继承自Node。</li>
<li>Document类型表示整个文档，是一组分层节点的根节点。在JS中document对象是Document的一个实例。</li>
<li>Element节点表示文档中所有HTML或XML元素，可以用来操作这些元素的内容和特性。</li>
<li>还有一些节点就是文本内容啊、注释、文档类型、CDATA区域和文档片段。</li>
<li>理解DOM的关键，就是理解DOM对性能的影响。DOM操作是Js程序中开销最大的部分，因此访问NodeList导致的问题为最多。所以每次访问NodeList对象，都会运行一次查询。</li>
<li><strong>尽量减少DOM操作！！！</strong></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;文档对象模型&quot;&gt;&lt;a href=&quot;#文档对象模型&quot; class=&quot;headerlink&quot; title=&quot;文档对象模型&quot;&gt;&lt;/a&gt;文档对象模型&lt;/h1&gt;&lt;p&gt;一点小差异，IE中所有DOM对象都是以COM对象的形式实现的。&lt;/p&gt;
&lt;h2 id=&quot;节点属性&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="JavaScript修仙之旅" scheme="http://xuzihao.fun/categories/JavaScript%E4%BF%AE%E4%BB%99%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="JavaScript" scheme="http://xuzihao.fun/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>C++ 初体验</title>
    <link href="http://xuzihao.fun/C++%E5%88%9D%E4%BD%93%E9%AA%8C.html"/>
    <id>http://xuzihao.fun/C++初体验.html</id>
    <published>2017-12-08T14:05:00.000Z</published>
    <updated>2017-12-09T06:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p>Clion给我建的第一个C++文件如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么我在想这和平常写得js不同啊，那个<code>std::</code>是啥…</p>
<p>经过强大的搜索引擎我知道了！这玩意儿就是一个类（std）啊（输入输出标准），它包括了cin成员和cout成员。</p>
<p>当我加了<code>using namespace std;</code>以后，我才能使用它的成员。我的c++程序可以写成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="comment">// main() 是程序开始执行的地方</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World"</span>; <span class="comment">// 输出 Hello World</span></div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那我又发现 <code>namespace</code>这个东西。原来它是指标识符的各种可见范围。</p>
<h2 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C++数据类型"></a>C++数据类型</h2><p>讲到数据类型。。我这个写惯了动态语言的人。。。诶西。强制让我写静态有点不行惯，没办法只能去写啊！</p>
<p>C++有七种数据类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔型</td>
<td>bool</td>
</tr>
<tr>
<td>字符型</td>
<td>Char</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
</tr>
<tr>
<td>浮点型</td>
<td>float</td>
</tr>
<tr>
<td>双浮点型</td>
<td>double</td>
</tr>
<tr>
<td>无类型</td>
<td>void</td>
</tr>
<tr>
<td>宽字符型</td>
<td>wchar_t</td>
</tr>
</tbody>
</table>
<p>有一些基本类型可以使用一个或多个类型装饰符进行修饰：</p>
<ul>
<li>signed</li>
<li>unsigned</li>
<li>short</li>
<li>long</li>
</ul>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举大家可能都听过吧，它其实就是将变量的值一一列举出来，在这提醒下！变量的值只能在列举出来的值的范围内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> animal &#123; dog, cat, pig &#125; c;</div><div class="line">c = cat;</div><div class="line"><span class="comment">//这段代码意思为 变量c的类型为animal，最后c被赋值给cat。</span></div></pre></td></tr></table></figure>
<p>在默认情况下第一个名称的值为0，第二个名称值为1，第三个名称的值为2.</p>
<p>如果我这有写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> animal &#123; dog, cat=<span class="number">5</span>, pig &#125;;</div></pre></td></tr></table></figure>
<p>在这里，cat的值为5，那么pig值为6.</p>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>
<ul>
<li>布尔</li>
<li>char<ul>
<li>通常为8位字节，这是一个整数类型</li>
</ul>
</li>
<li>int</li>
<li>float<ul>
<li>单精度浮点类型，32位</li>
</ul>
</li>
<li>double<ul>
<li>双精度浮点类型，64位</li>
</ul>
</li>
<li>void</li>
<li>wchar_t</li>
</ul>
<p>而且C++ 也允许定义各种其他类型的变量，比如<strong>枚举、指针、数组、引用、数据结构、类</strong>。</p>
<p>我们可以使用 <strong>extern</strong> 关键字在任何地方声明一个变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a, b;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> a, b;</div><div class="line">  </div><div class="line">  	a = <span class="number">10</span>;</div><div class="line">  </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; a ;  <span class="comment">//=&gt; 10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在JS中我们的作用域可是太坑了！现在我们来看看C++的作用域吧。</p>
<ul>
<li>（1）在函数或一个代码块内部声明的变量，称为局部变量。</li>
<li>（2）在函数参数的定义中声明的变量，称为形式参数。</li>
<li>（3）在所有函数外部声明的变量，称为全局变量。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>局部变量)</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// 局部变量声明</span></div><div class="line">  <span class="keyword">int</span> a, b;</div><div class="line">  <span class="keyword">int</span> c;</div><div class="line"> </div><div class="line">  <span class="comment">// 实际初始化</span></div><div class="line">  a = <span class="number">10</span>;</div><div class="line">  b = <span class="number">20</span>;</div><div class="line">  c = a + b;</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; c;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">(<span class="number">3</span>全局变量)</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="comment">// 全局变量声明</span></div><div class="line"><span class="keyword">int</span> g;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// 局部变量声明</span></div><div class="line">  <span class="keyword">int</span> a, b;</div><div class="line"> </div><div class="line">  <span class="comment">// 实际初始化</span></div><div class="line">  a = <span class="number">10</span>;</div><div class="line">  b = <span class="number">20</span>;</div><div class="line">  g = a + b;</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; g;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们遇到全局变量和局部变量的名称相同时，和js一样，<strong>在函数体内局部变量的值会覆盖全局变量</strong>。</p>
<h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><p>在 C++ 中，有两种简单的定义常量的方式：</p>
<ul>
<li>使用 <strong>#define</strong> 预处理器。</li>
<li>使用 <strong>const</strong> 关键字。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DOGFOOT 4   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CHICKENFOOT  2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NEWLINE <span class="meta-string">'\n'</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"> </div><div class="line">   <span class="keyword">int</span> area;  </div><div class="line">   </div><div class="line">   allFoot = DOGFOOT * CHICKENFOOT;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; allFoot;</div><div class="line">   <span class="built_in">cout</span> &lt;&lt; NEWLINE;</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//会输出8.</span></div></pre></td></tr></table></figure>
<p>那么const很简单就和es6中一样只<strong>可读不可写</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;First&quot;&gt;&lt;a href=&quot;#First&quot; class=&quot;headerlink&quot; title=&quot;First&quot;&gt;&lt;/a&gt;First&lt;/h2&gt;&lt;p&gt;Clion给我建的第一个C++文件如下&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;tabl
    
    </summary>
    
      <category term="C++" scheme="http://xuzihao.fun/categories/C/"/>
    
    
      <category term="C++" scheme="http://xuzihao.fun/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>BOM</title>
    <link href="http://xuzihao.fun/BOM.html"/>
    <id>http://xuzihao.fun/BOM.html</id>
    <published>2017-12-06T13:42:00.000Z</published>
    <updated>2017-12-07T13:22:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>它既是window对象的属性，也是document对象的属性。</p>
<a id="more"></a>
<ul>
<li>location.hash        “#contents”<ul>
<li>返回URL中的hash，如果URL中不包含散列，则返回空字符串</li>
</ul>
</li>
<li>location.host                 “www.wrox.com:80”<ul>
<li>返回服务器名称和端口号</li>
</ul>
</li>
<li>location.hostname       “www.wrox.com”<ul>
<li>返回不带端口号的服务器名称</li>
</ul>
</li>
<li>location.href                  “http:/www.wrox.com”<ul>
<li>返回当前加载页面的完整URL</li>
</ul>
</li>
<li>location.pathname       “/WileyCDA/“<ul>
<li>返回URL中的目录和（或者）文件名</li>
</ul>
</li>
<li>location.port                  “8080”<ul>
<li>返回URL中指定的端口号</li>
</ul>
</li>
<li>location.protocol           “http:”<ul>
<li>返回页面使用的协议</li>
</ul>
</li>
<li>location.search              “?q=javascript”<ul>
<li>返回URL的查询字符串，字符串以问号开头</li>
</ul>
</li>
</ul>
<h2 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h2><ul>
<li>location.assign <ul>
<li>可以立即打开新URL，而且还在浏览器的历史记录中生成一条记录</li>
</ul>
</li>
<li>location.replace             <ul>
<li>导航到的URL，不会在历史记录中生成新纪录，用户不能回到前一个页面。</li>
</ul>
</li>
<li>location.reload <ul>
<li>不传递任何参数，页面就会以最有效的方式重新加载</li>
<li>要强制从服务器重新加载，那么就需要给个参数为<strong>true</strong></li>
</ul>
</li>
</ul>
<h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator" target="_blank" rel="external">查看MDN</a></p>
<h2 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Screen" target="_blank" rel="external">查看MDN</a></p>
<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><ul>
<li>history.go(-1)        后退一页</li>
<li>history.go(1)                 前进一页，以此类推</li>
<li>history.go(“wrox.com”)       跳转到最近的wrox.com</li>
</ul>
<p>如果历史记录中不包含该字符串的话，那么这个方法什么也不做</p>
<p>还有两个简写方法,方法可以模仿浏览器的“后退” 和 “前进” 按钮。</p>
<ul>
<li>history.back</li>
<li>history.forward</li>
</ul>
<ul>
<li>history.length<ul>
<li>这个length属性保存着历史记录的数量。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;location对象&quot;&gt;&lt;a href=&quot;#location对象&quot; class=&quot;headerlink&quot; title=&quot;location对象&quot;&gt;&lt;/a&gt;location对象&lt;/h2&gt;&lt;p&gt;它既是window对象的属性，也是document对象的属性。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://xuzihao.fun/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://xuzihao.fun/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络读书笔记（一）</title>
    <link href="http://xuzihao.fun/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>http://xuzihao.fun/计算机网络读书笔记（一）.html</id>
    <published>2017-12-04T07:29:00.000Z</published>
    <updated>2017-12-04T08:20:32.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务原语"><a href="#服务原语" class="headerlink" title="服务原语"></a>服务原语</h2><table>
<thead>
<tr>
<th style="text-align:left">原语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LISTEN</td>
<td style="text-align:left">阻塞操作，等待入境连接请求</td>
</tr>
<tr>
<td style="text-align:left">CONNECT</td>
<td style="text-align:left">与等待中的对等实体建立连接</td>
</tr>
<tr>
<td style="text-align:left">ACCEPT</td>
<td style="text-align:left">接受来自对等实体的入境连接请求</td>
</tr>
<tr>
<td style="text-align:left">RECEIVE</td>
<td style="text-align:left">阻塞操作，等待入境报文</td>
</tr>
<tr>
<td style="text-align:left">SEND</td>
<td style="text-align:left">给对等实体发送一个报文</td>
</tr>
<tr>
<td style="text-align:left">DISCONNECT</td>
<td style="text-align:left">终止一个连接</td>
</tr>
</tbody>
</table>
<h2 id="服务和协议"><a href="#服务和协议" class="headerlink" title="服务和协议"></a>服务和协议</h2><p>服务和协议是两个截然不同的概念。</p>
<p><strong>服务：</strong></p>
<p>是指某一层向它上一层提供的一组原语（操作）。服务定义了该层准备代表其用户执行哪些操作，但是它不会去考虑如何实现这些操作。低层是服务提供者，上层是服务用户。</p>
<p><strong>协议：</strong></p>
<p>协议是一组规则，规定了同一层上对等实体之间所交换的数据包或者报文的格式和含义。</p>
<p><strong>服务涉及层与层之间的接口！！！！那么，协议设计不同机器上两个对等实体之间发送的数据包</strong></p>
<p><img src="http://ozar6ogjb.bkt.clouddn.com/%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%8D%8F%E8%AE%AE.png" alt="服务和协议"></p>
<p>用编程语言来说的话，服务就好像是面向对象语言中的抽象数据类型或者对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;服务原语&quot;&gt;&lt;a href=&quot;#服务原语&quot; class=&quot;headerlink&quot; title=&quot;服务原语&quot;&gt;&lt;/a&gt;服务原语&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;原语&lt;/th&gt;
&lt;th styl
    
    </summary>
    
      <category term="读书笔记" scheme="http://xuzihao.fun/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="网络" scheme="http://xuzihao.fun/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="读书笔记" scheme="http://xuzihao.fun/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《图解HTTP》读书笔记</title>
    <link href="http://xuzihao.fun/%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>http://xuzihao.fun/《图解HTTP》读书笔记.html</id>
    <published>2017-11-24T14:52:00.000Z</published>
    <updated>2017-11-24T14:52:51.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图解HTTP"><a href="#图解HTTP" class="headerlink" title="图解HTTP"></a>图解HTTP</h1><h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><ul>
<li>TCP/IP协议族按层次分别分为四层<ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p><img src="http://ozar6ogjb.bkt.clouddn.com/TCPIP%E5%88%86%E5%B1%82.png" alt="TCP/IP通信传输流"></p>
<p>URI, URL, URN</p>
<ul>
<li>“A Uniform Resource Identifier (URI) 是一个紧凑的字符串用来标示抽象或物理资源。”</li>
<li>URL， URN是URI的子集，除了确定一个资源，还提供一种定位该资源的主要访问机制</li>
<li>换句通俗易懂的话说：</li>
<li>URN作用就好像一个人的名字，URL就像一个人的地址。再换句话说：URN确定了东西的身份，URL提供了找到他的方式。</li>
</ul>
<h2 id="状态码的类别"><a href="#状态码的类别" class="headerlink" title="状态码的类别"></a>状态码的类别</h2><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">类别</th>
<th style="text-align:left">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1xx</td>
<td style="text-align:left">Informational(信息状态码)</td>
<td style="text-align:left">接受的请求正在处理</td>
</tr>
<tr>
<td style="text-align:left">2xx</td>
<td style="text-align:left">Success(成功状态码)</td>
<td style="text-align:left">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:left">3xx</td>
<td style="text-align:left">Redirection(重定向状态码)</td>
<td style="text-align:left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:left">4xx</td>
<td style="text-align:left">Client Error(客户端错误状态码)</td>
<td style="text-align:left">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:left">5xx</td>
<td style="text-align:left">Server Error(服务器错误状态代码)</td>
<td style="text-align:left">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<p>最具有代表性的14个状态码：</p>
<p><em><strong>2xx成功</strong></em></p>
<ul>
<li>200 OK<ul>
<li>表示从客户端发来的请求在服务器端被正常处理了。</li>
</ul>
</li>
<li>204 No Content<ul>
<li>代表服务器接受的请求已成功处理，但在返回的响应报文中不含实体的主体部分。</li>
</ul>
</li>
<li>206 Partial Content<ul>
<li>表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。</li>
</ul>
</li>
</ul>
<p><em><strong>3xx重定向</strong></em></p>
<p>当301， 302， 303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。</p>
<ul>
<li>301 Moved Permanently<ul>
<li>永久性重定向。</li>
</ul>
</li>
<li>302 Found<ul>
<li>临时性重定向。</li>
</ul>
</li>
<li>303 See Other<ul>
<li>由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。</li>
</ul>
</li>
<li>304 Not Modified<ul>
<li>表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求为满足条件的情况后，直接返回304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）。</li>
</ul>
</li>
<li>307 Temporary Redirect<ul>
<li>临时重定向。该状态码与302有相同的含义，但是307不会从POST变成GET。</li>
</ul>
</li>
</ul>
<p><em><strong>4xx客户端错误</strong></em></p>
<ul>
<li>400 Bad Request<ul>
<li>表示请求报文中存在语法错误。</li>
</ul>
</li>
<li>401 Unauthorized<ul>
<li>表示发送的请求需要有通过HTTP认证的认证信息。</li>
</ul>
</li>
<li>403 Forbidden<ul>
<li>表明对请求资源的访问被服务器拒绝了。</li>
</ul>
</li>
<li>404 Not Found<ul>
<li>表明服务器上没有请求的资源。</li>
</ul>
</li>
</ul>
<p><em><strong>5xx服务器错误</strong></em></p>
<ul>
<li>500 Internal Server Error<ul>
<li>表明服务器在执行请求时发生了错误。</li>
</ul>
</li>
<li>503 Service Unavailbale<ul>
<li>表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
</li>
</ul>
<h2 id="通信数据转发程序：代理、网关、隧道"><a href="#通信数据转发程序：代理、网关、隧道" class="headerlink" title="通信数据转发程序：代理、网关、隧道"></a>通信数据转发程序：代理、网关、隧道</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。<strong>代理不改变请求URI</strong>，会直接发送给前方持有资源的目标服务器。</p>
<p>持有资源实体的服务器称为<strong>源服务器</strong>，从源服务器返回的响应经过代理服务器后再传给客户端。</p>
<p>使用代理服务器的理由：</p>
<ul>
<li>利用缓存技术，减少网络带宽的流量。</li>
<li>组织内部针对特定网站的访问控制，以获取访问日志为主要目的。</li>
</ul>
<p>代理有两种基准分类： 一种是是否使用了缓存，另一种是是否会修改报文。</p>
<p>缓存代理：代理转发响应式，<strong>缓存代理</strong>会预先将资源的副本保存在代理服务器上。</p>
<p>透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为<strong>透明代理</strong>。反之，如果对报文内容进行加工的代理就叫做<strong>非透明代理</strong>。</p>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关能使通信线路上的服务器提供非HTTP协议服务。</p>
<p>利用网关能提高通信的安全性。</p>
<p>比如说：网关可以连接数据库。还有在我们淘宝购物用信用卡结账的时候，网关可以和信用卡结算系统联动。</p>
<h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。</p>
<p>也就是说，隧道本身是不会去解析HTTP请求的，他只是作为一个很安全的通道去让客户端与服务器相连。</p>
<h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p>在请求中，HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分构成</p>
<h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><p>在响应中，HTTP报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段 3部分构成。</p>
<h3 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h3><p>使用首部字段是为了给浏览器和服务器提供报文主体大小，所使用的语言、认证信息等内容。</p>
<p>HTTP首部字段是由<strong>首部字段名</strong>和<strong>字段值</strong>构成：</p>
<blockquote>
<p>首部字段名： 字段值</p>
</blockquote>
<p>在HTTP首部中，以Content-Type这个字段来表示报文主题的对象类型：</p>
<blockquote>
<p>Content-Type: text/html</p>
<p>首部字段名：     字段值</p>
</blockquote>
<p>而且在字段值对应单个HTTP首部字段可以有多个值。</p>
<blockquote>
<p>Keep-Alive: timeout=15, max=100</p>
</blockquote>
<h3 id="4种HTTP首部字段类型"><a href="#4种HTTP首部字段类型" class="headerlink" title="4种HTTP首部字段类型"></a>4种HTTP首部字段类型</h3><ul>
<li>通用首部字段<ul>
<li>请求报文和响应报文两端都会使用的首部</li>
</ul>
</li>
<li>请求首部字段<ul>
<li>从客户端向服务器端发送请求报文时使用的首部。<ul>
<li>补充了请求的附加内容、客户端信息、响应内容相关优化级等信息</li>
</ul>
</li>
</ul>
</li>
<li>响应首部字段<ul>
<li>从服务器向客户端返回响应报文时使用的首部。<ul>
<li>补充了响应的附加内容，也会要求客户端附加额外的内容信息。</li>
</ul>
</li>
</ul>
</li>
<li>实体首部字段<ul>
<li>针对请求报文和响应豹纹的实体部分使用的首部<ul>
<li>补充了资源内容更新时间等与实体有关的信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><ul>
<li>通信使用的明文（不加密），可能会被窃听。</li>
<li>不验证通信方的身份，因此有可能遭遇伪装。</li>
<li>无法证明报文的完整性，所以有可能已遭篡改。</li>
</ul>
<h2 id="HTTP使用的认证方式"><a href="#HTTP使用的认证方式" class="headerlink" title="HTTP使用的认证方式"></a>HTTP使用的认证方式</h2><ul>
<li>BASIC认证（基本认证）</li>
<li>DIGEST认证（摘要认证）</li>
<li>SSL客户端认证</li>
<li>FormBase认证（基于表单认证）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图解HTTP&quot;&gt;&lt;a href=&quot;#图解HTTP&quot; class=&quot;headerlink&quot; title=&quot;图解HTTP&quot;&gt;&lt;/a&gt;图解HTTP&lt;/h1&gt;&lt;h2 id=&quot;TCP-IP协议族&quot;&gt;&lt;a href=&quot;#TCP-IP协议族&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议族&quot;&gt;&lt;/a&gt;TCP/IP协议族&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TCP/IP协议族按层次分别分为四层&lt;ul&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;li&gt;传输层&lt;/li&gt;
&lt;li&gt;网络层&lt;/li&gt;
&lt;li&gt;数据链路层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://xuzihao.fun/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://xuzihao.fun/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《编码》读书笔记</title>
    <link href="http://xuzihao.fun/%E3%80%8A%E7%BC%96%E7%A0%81%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"/>
    <id>http://xuzihao.fun/《编码》读书笔记.html</id>
    <published>2017-11-12T06:21:00.000Z</published>
    <updated>2017-11-12T07:56:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十进制，八进制，四进制，二进制"><a href="#十进制，八进制，四进制，二进制" class="headerlink" title="十进制，八进制，四进制，二进制"></a>十进制，八进制，四进制，二进制</h1><blockquote>
<p>在十进制中我们计数方式是：0、 1、 2、 3、 4、 5、 6、 7、 8、 9。</p>
<p>在八进制中我们计数方式是：0、 1、 2、 3、 4、 5、 6、 7。</p>
<p>在四进制中我们计数方式是：0、 1、 2、 3。</p>
<p>在二进制中我们计数方式是：0、 1。</p>
</blockquote>
<a id="more"></a>
<p>下面提供一个模板，这个模板可以将一个数转换最大长度为8的二进制数：</p>
<p><img src="/images/二进制模板.png" alt="二进制模板"></p>
<p><img src="/images/二进制模板计算.png" alt="二进制模板计算"></p>
<p>这就是使用方法。如果要十进制转化成二进制的话，也可以用这个模板，只不过是把乘改成除就行啦。</p>
<table>
<thead>
<tr>
<th style="text-align:center">二进制数</th>
<th style="text-align:center">十进制数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0000</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0001</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">0010</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">0011</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">0100</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">0101</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">0110</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">0111</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">1000</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">1001</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">1010</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">1011</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">1100</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:center">1101</td>
<td style="text-align:center">13</td>
</tr>
<tr>
<td style="text-align:center">1110</td>
<td style="text-align:center">14</td>
</tr>
<tr>
<td style="text-align:center">1111</td>
<td style="text-align:center">15</td>
</tr>
</tbody>
</table>
<ul>
<li>在最右边一直是 0 和 1 之间交替</li>
<li>右边第二列是 每2个0 和 每2个1 之间相互交替</li>
<li>第三列是 每4个0 和 每4个1 之间相互交替</li>
<li>第四列是 每8个0 和 每8个1 之间相互交替</li>
<li>所以只要再重复这16个数字并且在每个数字前面加一个1就可以很容易的写出后面的16个数字。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;十进制，八进制，四进制，二进制&quot;&gt;&lt;a href=&quot;#十进制，八进制，四进制，二进制&quot; class=&quot;headerlink&quot; title=&quot;十进制，八进制，四进制，二进制&quot;&gt;&lt;/a&gt;十进制，八进制，四进制，二进制&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在十进制中我们计数方式是：0、 1、 2、 3、 4、 5、 6、 7、 8、 9。&lt;/p&gt;
&lt;p&gt;在八进制中我们计数方式是：0、 1、 2、 3、 4、 5、 6、 7。&lt;/p&gt;
&lt;p&gt;在四进制中我们计数方式是：0、 1、 2、 3。&lt;/p&gt;
&lt;p&gt;在二进制中我们计数方式是：0、 1。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://xuzihao.fun/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://xuzihao.fun/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>英语单词</title>
    <link href="http://xuzihao.fun/%E5%8D%95%E8%AF%8D.html"/>
    <id>http://xuzihao.fun/单词.html</id>
    <published>2017-10-18T12:24:00.000Z</published>
    <updated>2017-11-12T07:57:05.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>delicate| 易碎的</li>
<li>idleness| 懒惰</li>
<li>tell the truth | 说实话</li>
</ul>
<a id="more"></a>
<ul>
<li>tell a lie / tell lies| 说谎话</li>
<li>hold the view 持某种看法;认为.</li>
<li>in view of | 鉴于，考虑到</li>
<li>working on | 从事于；致力于</li>
<li>set free | 释放</li>
<li>run into | 偶然</li>
<li>allow | 允许，给予(人)</li>
<li>for fear of | 生怕，以免</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;delicate| 易碎的&lt;/li&gt;
&lt;li&gt;idleness| 懒惰&lt;/li&gt;
&lt;li&gt;tell the truth | 说实话&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日常" scheme="http://xuzihao.fun/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="English" scheme="http://xuzihao.fun/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>英语例句</title>
    <link href="http://xuzihao.fun/%E4%BE%8B%E5%8F%A5.html"/>
    <id>http://xuzihao.fun/例句.html</id>
    <published>2017-10-18T12:24:00.000Z</published>
    <updated>2017-11-12T07:57:17.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>No sooner ····· then      <ul>
<li>一。。。就。</li>
</ul>
</li>
<li>not so much …as<ul>
<li>与其。。不如</li>
</ul>
</li>
<li><p>no more…than</p>
<ul>
<li><p>不过，仅仅；至多，同。。。一样不</p>
<a id="more"></a></li>
</ul>
</li>
<li>as…as<ul>
<li>像。。。一样</li>
</ul>
</li>
<li><p>imagined + sth. + to be + adj.    </p>
<ul>
<li>为复合宾语解构</li>
</ul>
</li>
<li><p>put forward to do sth.</p>
<ul>
<li>提出要求做某事</li>
</ul>
</li>
<li>get sth. done<ul>
<li>把某事做了</li>
</ul>
</li>
<li>would rather <ul>
<li>引导从句的虚拟结构中，如果表示对现在或将来情况的愿望，从句用<strong>过去时</strong>。</li>
<li>如果是对过去情况的虚拟，从句用<strong>过去完成时</strong>。</li>
</ul>
</li>
<li>never, hardly, seldom, little, not until, not, not only, no sooner, no    longer, nowhere, by no means <ul>
<li>以上位于句首需要部分倒装</li>
</ul>
</li>
<li>keep diary<ul>
<li>记日记</li>
</ul>
</li>
<li>can’t help doing sth.<ul>
<li>忍不住做。。。</li>
</ul>
</li>
<li>be worth doing<ul>
<li>某（事或物）值得做</li>
</ul>
</li>
<li>be worthy to be done 或 sth. is worthy of being done 以及 sb. be worhty of doing sth. 或者 sb. be worthy to do sth.<ul>
<li>和 worth 的意思一样</li>
</ul>
</li>
<li>It is/was /will be the first time that …句式<ul>
<li>主句谓语是is，从句用现在完成时</li>
<li>主句谓语是was，从句谓语用过去完成时</li>
<li>主句谓语是will be，从句谓语用一般现在时</li>
</ul>
</li>
<li>be appropriate for sb. 或 be appropriate to do sth.<ul>
<li>固定搭配</li>
</ul>
</li>
<li>appreciate + doing sth.<ul>
<li>感激做某事</li>
</ul>
</li>
<li>but to do,但是but之前出现了 do/does/did/done就要 but do</li>
<li>no mood | in the mood<ul>
<li>没有心情 | 有好心情</li>
</ul>
</li>
<li>the impression of + doing sth.<ul>
<li>做过某事的印象</li>
</ul>
</li>
<li>have a(the) right to sth.<ul>
<li>享有。。的权利</li>
</ul>
</li>
<li>do nothing but <ul>
<li>此结构后要求动词原形</li>
</ul>
</li>
<li>need doing / need to done<ul>
<li>需要被</li>
</ul>
</li>
<li>sb. spend some time doing sth.<ul>
<li>花时间做某事</li>
</ul>
</li>
<li>a large amount of, a great deal of <ul>
<li>固定搭配</li>
</ul>
</li>
<li>将来时除了有be going to, will + do, 还有be to do, be about to do.</li>
<li>play a part in<ul>
<li>在。。。起作用。</li>
</ul>
</li>
<li>must have + 过去分词<ul>
<li>过去一定做了某事，表示对过去的肯定推测。</li>
</ul>
</li>
<li>could have + 过去分词<ul>
<li>本来能够做….</li>
</ul>
</li>
<li>another + 基数词 + 名词复数<ul>
<li>另外/在多少个</li>
<li>I want another three apples.</li>
<li>我还需要三个苹果。</li>
</ul>
</li>
<li>mind doing sth.<ul>
<li>介意做某事</li>
</ul>
</li>
<li>to help you to out <ul>
<li>表示目的</li>
</ul>
</li>
<li>be going to + 一般现在时（leaves）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;No sooner ····· then      &lt;ul&gt;
&lt;li&gt;一。。。就。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;not so much …as&lt;ul&gt;
&lt;li&gt;与其。。不如&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;no more…than&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不过，仅仅；至多，同。。。一样不&lt;/p&gt;
    
    </summary>
    
      <category term="日常" scheme="http://xuzihao.fun/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="English" scheme="http://xuzihao.fun/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>英语时态</title>
    <link href="http://xuzihao.fun/%E6%97%B6%E6%80%81.html"/>
    <id>http://xuzihao.fun/时态.html</id>
    <published>2017-10-18T12:24:00.000Z</published>
    <updated>2017-11-12T07:57:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="英语语法——时态"><a href="#英语语法——时态" class="headerlink" title="英语语法——时态"></a>英语语法——时态</h1><p>时间概念包含四种，<strong>过去</strong>、<strong>现在</strong>、<strong>将来</strong>和<strong>过去将来</strong>。</p>
<p>动作方面包含四种，<strong>一般</strong>、<strong>进行</strong>、<strong>完成</strong>和<strong>完成进行</strong>。</p>
<p>将时间概念和动作方面结合一起，就能构成16种时态。</p>
<ul>
<li>一般现在时</li>
<li>现在进行时</li>
<li>现在完成时</li>
<li>现在完成进行时</li>
</ul>
<a id="more"></a>
<p><br></p>
<ul>
<li>一般过去时</li>
<li>过去进行时</li>
<li>过去完成时</li>
<li><p>过去完成进行时<br><br></p>
</li>
<li><p>一般将来时</p>
</li>
<li>将来进行时</li>
<li>将来完成时</li>
<li>将来完成进行时</li>
</ul>
<p><br></p>
<ul>
<li>一般过去将来时</li>
<li>一般过去将来进行时</li>
<li>一般过去将来完成时</li>
<li>一般过去将来完成进行</li>
</ul>
<blockquote>
<p><a href="https://www.zhihu.com/question/19721822" target="_blank" rel="external">以下图片和部分文字参考自知乎赛门喵</a></p>
</blockquote>
<p><img src="/image/时态.jpg" alt="时态"></p>
<p>谓语动词有「时间」和「状态」两个属性。结构上也由「时间+时间状态」构成</p>
<p><strong>将上图总结成一个表：</strong></p>
<p><img src="/image/时态总结.jpg" alt="时态总结"></p>
<p>表格中的「助动词」突出「时间」，「主动词」突出动作「状态」。</p>
<p>动词原形通过两次变形，第一次具有了「动作状态」属性。第二次具有了「时间」属性，完成到了谓语动词的转换。</p>
<p>「时间」+「动作状态」的方式，一方面帮助了我们了解时态的的本质，更让我们可以毫不费力的记住16种时态。</p>
<h2 id="接下来细致的说明这16种时态"><a href="#接下来细致的说明这16种时态" class="headerlink" title="接下来细致的说明这16种时态"></a>接下来细致的说明这16种时态</h2><ul>
<li><h3 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h3><ul>
<li>概念：仅仅陈诉一个事实（fact）</li>
<li>形式：动词原形，我们用play。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">I played baskerball. 								我过去（以前）打篮球。</div><div class="line">I play baskerball.								我现在打篮球。</div><div class="line">I will play baskerball.								我将要打篮球。</div><div class="line">I didn&apos;t know if he would come.  						我不知道她是否回来。</div></pre></td></tr></table></figure>
<blockquote>
<p>did + play = played = 过去 + 一般体 = 一般过去时</p>
<p>do/does + play = play/plays = 现在 + 一般体 = 一般现在时</p>
<p>will + play = will play = 将来 + 一般体 = 一般将来时</p>
<p>would + come = would come = 过去将来 + 一般体 = 一般过去将来时</p>
</blockquote>
<ul>
<li><h3 id="进行"><a href="#进行" class="headerlink" title="进行"></a>进行</h3><ul>
<li><p>概念：表示动作正在发生</p>
</li>
<li><p>形式：ing</p>
<ul>
<li><h4 id="过去进行时-was-were"><a href="#过去进行时-was-were" class="headerlink" title="过去进行时(was/ were)"></a>过去进行时(was/ were)</h4><p>We were discussing the decoration problem 10 minutes ago.<br>10分钟前，我们正讨论装修的问题。</p>
<p>​<br><br>I was cooking when you <strong><em>knocked</em></strong> at the door.</p>
<p>你敲门时我正在做饭。</p>
</li>
<li><h4 id="现在进行时-am-is-are"><a href="#现在进行时-am-is-are" class="headerlink" title="现在进行时(am/ is/ are)"></a>现在进行时(am/ is/ are)</h4><p>I’m felling better now.                    </p>
<p><strong>//表示正在进行的动作</strong></p>
<p>我现在感觉好多了。</p>
<p><br><br>We are leaving tomorrow.               </p>
<p><strong>//有些瞬间动词用进行时表将来</strong></p>
<p>我们明天离开。</p>
<p><br><br>​     He is always asking such foolish questions.            </p>
<p>  <strong>//表示某动作反复发生</strong></p>
<p>​  他总是问如此愚蠢的问题。</p>
<p><br><br>​  You are being modest.                    </p>
<p>​  <strong>//“an, are, is+bing” 强调被描述情况或状态的暂时性。</strong></p>
<p>​  你这会儿倒是挺谦虚的。</p>
<p>  <br><br>  he is buying a new bike soon.        </p>
<p>  <strong>//在时间和条件状语从句中，现在进行时表示将来的动作。</strong></p>
<p>  她不久将买一辆新自行车。    </p>
</li>
<li><h4 id="将来进行时-will-be"><a href="#将来进行时-will-be" class="headerlink" title="将来进行时(will be)"></a>将来进行时(will be)</h4><p>The train will be leaving in a second.</p>
<p>火车就要开了。</p>
<p>What will you be doing this time tomorrow？</p>
<p>明天这个时候你将做什么？</p>
</li>
<li><h4 id="过去将来进行时-should-be-would-be"><a href="#过去将来进行时-should-be-would-be" class="headerlink" title="过去将来进行时(should be/ would be)"></a>过去将来进行时(should be/ would be)</h4><p>I never realized that someday I would be living in Africa.</p>
<p>我以前从没想过将来有一天我会生活在非洲。 </p>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><ul>
<li><p>概念：表示动作完成了</p>
</li>
<li><p>形式：过去分词，drunk</p>
<ul>
<li><h4 id="过去完成时-had-done"><a href="#过去完成时-had-done" class="headerlink" title="过去完成时(had) + done"></a>过去完成时(had) + done</h4><p>Up to the end of last year, the aim <strong>had been achieved</strong> to cut energy use by 80%.            </p>
<p><strong>//过去的过去的动作或状态，“up to/ before/ by + 过去时间”作时间状语。</strong></p>
<p>到去年年底，已经实现节能80%的目标。</p>
<p><br></p>
<p>There <strong>had been</strong> someone in our room just now, because i noticed a burning cigarette end on the floor when we opened the front door.</p>
<p><strong>//过去的过去。这种逻辑关系通过上下文体现</strong></p>
<p>刚才有人在我们的房间里，因为我们打开前门进来时，我注意到地板上有一个仍在燃烧的烟头</p>
</li>
<li><h4 id="现在完成时-hava-has-done"><a href="#现在完成时-hava-has-done" class="headerlink" title="现在完成时(hava/ has) + done"></a>现在完成时(hava/ has) + done</h4><p>She <strong>has won</strong> prizes for her records.</p>
<p><strong>//表示从过去某时刻开始，持续到现在的动作或情况，并且有可能会继续延续下去。</strong></p>
<p>她的唱片曾获奖过几次奖。</p>
<p><br><br>For years i <strong>have been interested</strong> in engineering.</p>
<p><strong>//时间状语常用since加一个过去的时间点，或for加一段时间</strong></p>
<p>多年来，我一直对工程学感兴趣。</p>
<p><br><br>I <strong>have been here</strong> since last June.</p>
<p>从去年6月起，我一直在这里。</p>
<p><br><br>A moment please, I <strong>have almost finished</strong> the report.</p>
<p><strong>//表示发生在过去， 但对现在仍有影响的动作或情况，通常用瞬间动词“arrive begin, find, give, finish, lose”</strong></p>
<p>稍等，我的报告就快完成了。</p>
</li>
<li><h4 id="将来完成时-will-have-done"><a href="#将来完成时-will-have-done" class="headerlink" title="将来完成时(will have) + done"></a>将来完成时(will have) + done</h4><p>If you come at 6 p.m, I shall not yet <strong>have finished</strong> dinner.</p>
<p><strong>//表示将来某一时间之前完成的动作，并往往对将来某一时间产生影响。</strong></p>
<p>你若下午6点来，我还没吃完晚饭呢。</p>
<p><br><br>You must take a taxi, otherwise the train <strong>will have</strong> left <strong>by the time</strong> you get to the station.</p>
<p><strong>//常用 “before + 将来时间点”或“by + 将来时间点”作时间状语</strong></p>
<p>你必须坐出租，否则等你到了车站火车都开走了。</p>
<p><br><br>Before long, he <strong>will have forgotten</strong> all about the matter.</p>
<p>过不久，他就将把这事儿忘记了。</p>
</li>
<li><h4 id="过去将来完成时-would-have-done"><a href="#过去将来完成时-would-have-done" class="headerlink" title="过去将来完成时(would have) + done"></a>过去将来完成时(would have) + done</h4><p>He said that he <strong>would have done</strong> with my camera by the end of next week.</p>
<p><strong>//表示在过去将来某一时间以前发生的动作，并往往会对过去将来某一时间产生影响</strong></p>
<p>他说到下周末就不用我的照相机了。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="完成进行"><a href="#完成进行" class="headerlink" title="完成进行"></a>完成进行</h3><ul>
<li>概念： 表明动作(暂时)完成了，并且还要继续</li>
<li><p>形式： been + (base form) ing</p>
<ul>
<li><h4 id="过去完成进行时-had-been-doing"><a href="#过去完成进行时-had-been-doing" class="headerlink" title="过去完成进行时(had) + been doing"></a>过去完成进行时(had) + been doing</h4><p>He was tired. He <strong>had been working</strong> all day.</p>
<p><strong>//和过去完成时一样，过去完成进行时也必须以一个过去的事就为前提。</strong></p>
<p>他累了，他工作了一整天。</p>
<p>It <strong>had been raining</strong> heavily for two days and the ground was very wet.</p>
<p>连着下了两天大雨，地上很湿。</p>
</li>
<li><h4 id="现在完成进行时-have-has-been-doing"><a href="#现在完成进行时-have-has-been-doing" class="headerlink" title="现在完成进行时(have/ has) + been doing"></a>现在完成进行时(have/ has) + been doing</h4><p>We <strong>have been working</strong> on this project for over a month now.</p>
<p><strong>//表示某一动作开始于过去某一时间，延续或重复的出现至今，或将继续延续至将来。</strong></p>
<p>到目前为止，我们一直在处理那个项目，已经花了一个多月时间了。</p>
<p><strong>//与现在完成时相比，现在完成时进行时更强调在从过去到现在的时间里，动作或状态一直持续或一直反复出现。</strong></p>
</li>
<li><h4 id="将来完成进行时-will-have-been-doing"><a href="#将来完成进行时-will-have-been-doing" class="headerlink" title="将来完成进行时(will have) + been doing"></a>将来完成进行时(will have) + been doing</h4><p>If we don’t hurry up the store <strong>will have been closing</strong> before we get there.</p>
<p><strong>//表示动作从某一时间开始一直延续到将来某一时间。</strong></p>
<p>如果我们不快一点儿， 等到了那儿，商店早关门了。</p>
<p>By then, we <strong>will have been cooperating</strong> for half a year.</p>
<p>到那时为止，我们就将会合作半年了。</p>
</li>
<li><h4 id="过去将来完成进行时-would-have-been-doing"><a href="#过去将来完成进行时-would-have-been-doing" class="headerlink" title="过去将来完成进行时(would have) + been doing"></a>过去将来完成进行时(would have) + been doing</h4><p>He said that by the end of July he <strong>would have been studing</strong> German for six months.</p>
<p><strong>//表示动作从过去某一时间开始一直延续到过去将来某一时间</strong></p>
<p>他说到7月底，他学德语就有半年了。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br><br><br></p>
<p>  <a href="https://link.zhihu.com/?target=http%3A//blog.tarwon.com/english-grammar.html/" target="_blank" rel="external">以下未满18岁请自动屏蔽LoVe 这段我无意间看见</a></p>
<blockquote>
<p><strong>一般现在时:I make love with her everyday.</strong><br>一般过去时:I made love with her yesterday.<br>一般将来时:I will make love with her tomorrow.</p>
<p><strong>现在进行时:I am making love with her.</strong><br>过去进行时:I was making love with her at this time yesterday.<br>将来进行时:I will be making love with her at this time tomorrow.</p>
<p><strong>现在完成时:I have made love with her by now.</strong><br>过去完成时:I had made love with her before yesterday.<br>将来完成时:I will have made love with her by tomorrow.</p>
<p><strong>现在完成进行时:I have been making love with her for two hours.</strong><br>过去完成进行时:I had been making love with her for two hours when her husband came in.<br>将来完成进行时:I will have been making love with her for two hours when her husband wakes up tomorrow morning.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;英语语法——时态&quot;&gt;&lt;a href=&quot;#英语语法——时态&quot; class=&quot;headerlink&quot; title=&quot;英语语法——时态&quot;&gt;&lt;/a&gt;英语语法——时态&lt;/h1&gt;&lt;p&gt;时间概念包含四种，&lt;strong&gt;过去&lt;/strong&gt;、&lt;strong&gt;现在&lt;/strong&gt;、&lt;strong&gt;将来&lt;/strong&gt;和&lt;strong&gt;过去将来&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;动作方面包含四种，&lt;strong&gt;一般&lt;/strong&gt;、&lt;strong&gt;进行&lt;/strong&gt;、&lt;strong&gt;完成&lt;/strong&gt;和&lt;strong&gt;完成进行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;将时间概念和动作方面结合一起，就能构成16种时态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般现在时&lt;/li&gt;
&lt;li&gt;现在进行时&lt;/li&gt;
&lt;li&gt;现在完成时&lt;/li&gt;
&lt;li&gt;现在完成进行时&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="日常" scheme="http://xuzihao.fun/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="English" scheme="http://xuzihao.fun/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期</title>
    <link href="http://xuzihao.fun/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"/>
    <id>http://xuzihao.fun/React生命周期.html</id>
    <published>2017-09-26T09:20:00.000Z</published>
    <updated>2017-09-26T09:20:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h1><p>生命周期可能经历如下三个经历：</p>
<blockquote>
<p>装载过程(Mount): 把组件第一次在DOM树中渲染的过程；</p>
<p>更新过程(Update): 组件被重新渲染的过程;</p>
<p>卸载过程(Unmount): 组件从DOM中删除的过程;</p>
</blockquote>
<a id="more"></a>
<p>接下来，一个一个解释：</p>
<h2 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h2><ol>
<li>constructor</li>
<li>getInitialState</li>
<li>getDefaultProps</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ol>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><ul>
<li>一个React组件需要constructor，往往是为了达到下面的目的<ul>
<li>初始化state，因为组件生命周期中任何函数都可能要访问state</li>
<li>绑定成员函数的this环境<ul>
<li>举个例子：</li>
<li>this.onClickIncrementButton = this.onClickIncrementButton.bind(this);</li>
<li>这条语句的作用，就是通过<strong>bind方法</strong>让当前实例中onClickIncrementButton函数被调用时，this始终是指向当前组件实例。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><ul>
<li><p><code>getInitialState</code>和<code>getDefaultProps</code>是在React.createClass方法创造的组件类才会用到。</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Sample = React.createClass (&#123;</div><div class="line">    <span class="attr">getInitialState</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;;</div><div class="line">    &#125;,</div><div class="line">  	<span class="attr">getDefaultProps</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;<span class="attr">sampleProp</span>: <span class="number">0</span>&#125;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在ES6的话</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">     <span class="attr">foo</span>: <span class="string">'bar'</span></div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">Sample.defaultProps = &#123;</div><div class="line">  <span class="attr">sampleProp</span>: <span class="number">0</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><ul>
<li><code>render</code>函数是一个纯函数。完全根据this.state 和  this.props来决定返回的结果，而且不要产生任何副作用。</li>
<li>在render函数中去<strong>调用this.setState毫无疑问是错误</strong>的。因为一个纯函数不应该<strong>引起状态的改变</strong>。</li>
</ul>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><ul>
<li>在装载过程中，<code>componentWillMount</code>会在调用<code>render</code>函数之前调用。<ul>
<li><code>componentDidMount</code>会在调用<code>render</code>函数之后调用。</li>
</ul>
</li>
<li>这两个函数是<code>render</code>函数的前哨和后卫。</li>
<li>但是一般我们都不用定义<code>componentWillMount</code>,因为这个函数发生在”将要装载”的时候，这个时候没有任何渲染出来的结果。即使我们去调用this.setState修改状态也不会引发重新绘制。<ul>
<li>也就是说所有可以在<code>componentWillMount</code>中做的事情，我们都可以提前到<code>constructor</code>中去做。</li>
</ul>
</li>
<li>我们来说说<code>componentDidMount</code>这个函数，它仅在浏览器端执行。</li>
</ul>
<h2 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h2><ol>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ol>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><ul>
<li><code>componentWillReceiveProps</code><ul>
<li>只要是父组件的<code>render</code>函数被调用，在<code>render</code>函数里面被渲染的子组件就会经历更新过程。不管父组件传给子组件的props有没有改变，都会触发子组件的<code>componentWillReceiveProps</code>函数。</li>
<li>还有，通过<code>this.setState</code>方法触发的更新过程不会调用这个函数。<ul>
<li>因为这个函数适合根据新的<code>props</code>值来计算出是不是要更新内部状态<code>state</code>。更新组件内部状态的方法就是<code>this.setState</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><ul>
<li><code>shouldComponentUpdate(nextProps, nextState)</code><ul>
<li>这个函数重要因为，它决定了一个组件什么时候不需要渲染。</li>
<li>这个函数返回一个布尔值，告诉React库这个组件在这次更新过程中是否要继续。</li>
<li>在更新过程中，React库首先会调用<code>shouldComponentUpdate</code>函数<ul>
<li>如果这个函数返回一个<code>true</code>，那就会继续更新过程，接下来调用render函数。</li>
<li>反之如果得到一个<code>false</code>，那就立刻停止更新过程，也就不会引发后续的渲染了。</li>
</ul>
</li>
<li>说这个函数重要，是因为我们使用恰当的话，能够大大挺高<code>React</code>组件的性能。</li>
</ul>
</li>
</ul>
<h2 id="卸载过程"><a href="#卸载过程" class="headerlink" title="卸载过程"></a>卸载过程</h2><ol>
<li>componentWillUnmount</li>
</ol>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h3><ul>
<li>当React组件要从DOM树上删除掉之前，对应的<code>componentWillUnmount</code>函数会被调用。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;React生命周期&quot;&gt;&lt;a href=&quot;#React生命周期&quot; class=&quot;headerlink&quot; title=&quot;React生命周期&quot;&gt;&lt;/a&gt;React生命周期&lt;/h1&gt;&lt;p&gt;生命周期可能经历如下三个经历：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;装载过程(Mount): 把组件第一次在DOM树中渲染的过程；&lt;/p&gt;
&lt;p&gt;更新过程(Update): 组件被重新渲染的过程;&lt;/p&gt;
&lt;p&gt;卸载过程(Unmount): 组件从DOM中删除的过程;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="React" scheme="http://xuzihao.fun/categories/React/"/>
    
    
      <category term="JavaScript" scheme="http://xuzihao.fun/tags/JavaScript/"/>
    
      <category term="React" scheme="http://xuzihao.fun/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>学习CSS(二)</title>
    <link href="http://xuzihao.fun/%E5%AD%A6%E4%B9%A0CSS(%E4%BA%8C).html"/>
    <id>http://xuzihao.fun/学习CSS(二).html</id>
    <published>2017-09-06T09:38:00.000Z</published>
    <updated>2017-09-07T06:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>页面上的每个元素被看做一个矩形框，这个框由元素的内容、内边距（padding）、边框（border）、和外边距（margin）组成。</p>
<p>外边距叠加</p>
<p>本小节参考<a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="external">W3school</a>。</p>
<p>当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。</p>
<p><img src="/images/css4.gif" alt="css4"></p>
<a id="more"></a>
<p>当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并。</p>
<p><img src="/images/css5.gif" alt="css5"></p>
<p>尽管看上去有些奇怪，但是外边距甚至可以与自身发生合并。</p>
<p>假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并：</p>
<p><img src="/images/css6.gif" alt="css7"></p>
<p>如果这个外边距遇到另一个元素的外边距，它还会发生合并：</p>
<p><img src="/images/css8.gif" alt="css7"></p>
<p>外边距合并初看上去可能有点奇怪，但是实际上，它是有意义的。以由几个段落组成的典型文本页面为例。第一个段落上面的空间等于段落的上外边距。如果没有外边距合并，后续所有段落之间的外边距都将是相邻上外边距和下外边距的和。这意味着段落之间的空间是页面顶部的两倍。如果发生外边距合并，段落之间的上外边距和下外边距就合并在一起，这样各处的距离就一致了。</p>
<h1 id="定位概述"><a href="#定位概述" class="headerlink" title="定位概述"></a>定位概述</h1><p>可视化格式模型和定位模型。</p>
<h2 id="可视化格式模型"><a href="#可视化格式模型" class="headerlink" title="可视化格式模型"></a>可视化格式模型</h2><p><code>h1</code>,<code>p</code>,<code>div</code>等元素常常称为块级元素。</p>
<p><code>strong</code>,<code>span</code>等元素称为行内元素。</p>
<p>当行内元素你把它们的<code>display</code>属性设置成<code>block</code>，此元素会被显示为块级元素。</p>
<p>块级框从上到下一个接一个地垂直排列。</p>
<h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><p>如果对一个元素进行相对定位，其实就是让这个元素“相对于”它的起点移动。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#myBox &#123;</div><div class="line">width: 200px;</div><div class="line">height: 200px;</div><div class="line">background: red;</div><div class="line">&#125;</div><div class="line">#myBox1 &#123;</div><div class="line">position: relative;</div><div class="line">width: 200px;</div><div class="line">height: 200px;</div><div class="line">background: blue;</div><div class="line">&#125;</div><div class="line">#myBox2 &#123;</div><div class="line">position: relative;</div><div class="line">left: 20px;</div><div class="line">top: 20px;</div><div class="line">width: 200px;</div><div class="line">height: 200px;</div><div class="line">background: gray;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myBox"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myBox1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myBox2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="/images/css9.png" alt="css9"></p>
<h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><p>绝对定位使元素的位置与文档流无关。</p>
<p>绝对定位的元素的位置是相对于距离它最近的那个已定位的祖先元素确定的。如果元素没有已定位的祖先元素，那么它的位置是相对于初始包含块的。</p>
<p>接下来我们让一个文本段落对准一个大框的右下角：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#branding &#123;</div><div class="line">width: 20em;</div><div class="line">height: 10em;</div><div class="line">position: relative;</div><div class="line">background: black;</div><div class="line">&#125;</div><div class="line">#branding .tel &#123;</div><div class="line">position: absolute;</div><div class="line">right: 1em;</div><div class="line">bottom: 1em;</div><div class="line">text-align: right;</div><div class="line">color: white;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"branding"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"tel"</span>&gt;</span>Tel: 0845 838 6163<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="/images/css10.png" alt="css10"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;盒模型&quot;&gt;&lt;a href=&quot;#盒模型&quot; class=&quot;headerlink&quot; title=&quot;盒模型&quot;&gt;&lt;/a&gt;盒模型&lt;/h1&gt;&lt;p&gt;页面上的每个元素被看做一个矩形框，这个框由元素的内容、内边距（padding）、边框（border）、和外边距（margin）组成。&lt;/p&gt;
&lt;p&gt;外边距叠加&lt;/p&gt;
&lt;p&gt;本小节参考&lt;a href=&quot;http://www.w3school.com.cn/css/css_margin_collapsing.asp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;W3school&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/css4.gif&quot; alt=&quot;css4&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://xuzihao.fun/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://xuzihao.fun/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>学习CSS(一)</title>
    <link href="http://xuzihao.fun/%E5%AD%A6CSS%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>http://xuzihao.fun/学CSS（一）.html</id>
    <published>2017-09-04T12:26:00.000Z</published>
    <updated>2017-09-06T09:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给自己的要求"><a href="#给自己的要求" class="headerlink" title="给自己的要求"></a>给自己的要求</h1><ul>
<li>class应该用在概念上相似的元素，这些元素可以出现在同一页面上的多个位置。</li>
<li>ID应该用于不同的唯一的元素。</li>
</ul>
<h1 id="DTD（文档类型定义）"><a href="#DTD（文档类型定义）" class="headerlink" title="DTD（文档类型定义）"></a>DTD（文档类型定义）</h1><p>DOCTYPE声明是指HTML文档开头处的一行或两行代码。它描述使用哪个DTD。</p>
<blockquote>
<p>但是在HTML5中就不需要URL，浏览器一般不读取这些文件。而是只识别常见的DOCTYPE声明。</p>
</blockquote>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>选择器最常用的两种： <strong>类型选择器</strong> 和 <strong>后代选择器</strong> 。</p>
<a id="more"></a>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*类型选择器*/</span></div><div class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: black; &#125;</div><div class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">font-weight</span>: bold; &#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*后代选择器*/</span></div><div class="line"><span class="selector-tag">blockquote</span> <span class="selector-tag">p</span> &#123; <span class="attribute">padding</span>: <span class="number">15px</span>; &#125;</div></pre></td></tr></table></figure>
<p>还有两种就是： <strong>ID选择器</strong> 和 <strong>类选择器</strong> 。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#intro</span> &#123; <span class="attribute">font-weight</span>: bold; &#125;			<span class="comment">/*ID选择器*/</span></div><div class="line"><span class="selector-class">.date-posted</span> &#123; <span class="attribute">color</span>: <span class="number">#ccc</span>; &#125;			<span class="comment">/*类选择器*/</span></div></pre></td></tr></table></figure>
<p>但是类选择器和ID选择器用太多也不是很好。下面有一种方法可以以一种方式对主体和副的地方操作css</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#main-content h2 &#123; font-weight: 1.8em; &#125;</div><div class="line">#secondary-content h2 &#123; font-weight: 1.2em; &#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main-content"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">	.....</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"secondary-content"</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">  	....</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123; <span class="attribute">color </span>: blue; &#125;		<span class="comment">/*链接伪类*/</span></div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color </span>: green; &#125;	<span class="comment">/*链接伪类*/</span></div><div class="line"><span class="comment">/*链接伪类只能用于锚元素*/</span></div><div class="line"></div><div class="line">动态伪类</div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123; <span class="attribute">color</span>: red; &#125;		</div><div class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">background-color</span>: red; &#125;</div><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123; <span class="attribute">background-color</span>: yellow; &#125;</div><div class="line"></div><div class="line">伪类链接</div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: olive; &#125;</div></pre></td></tr></table></figure>
<h2 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">  	<span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*删除每个元素上默认的浏览器内边距和外边距*/</span></div></pre></td></tr></table></figure>
<h2 id="高级选择器之—-子选择器"><a href="#高级选择器之—-子选择器" class="headerlink" title="高级选择器之—-子选择器"></a>高级选择器之—-子选择器</h2><p>后代选择器选择一个元素的所有后代，那么子选择器就只选择元素的直接后代啦！</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#nav&gt;li &#123;</div><div class="line">  font-size: 30px;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/home/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/Services/"</span>&gt;</span>Services<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  		<span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/Services/design"</span>&gt;</span>Design<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/Services/development"</span>&gt;</span>Development<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        	<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/Services/consultancy"</span>&gt;</span>Consultancy<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  		<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/contact"</span>&gt;</span>Contact Us<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="/images/css1.png" alt="css1"></p>
<p>子选择器指定列表子元素的样式，但是不影响他的孙元素。</p>
<p>还有根据一个元素与另一个元素的相邻关系对它应用样式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">h2 + p &#123;</div><div class="line">  font-size: 1.4em;</div><div class="line">  font-weight: blod;</div><div class="line">  color: #777;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I'm here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>wow,me too<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="/images/css2.png" alt="css2"></p>
<p>更新于2017-09-05 21：30</p>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[title=hi]</div><div class="line">&#123;</div><div class="line">border:5px solid blue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>可以应用样式：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">title</span>=<span class="string">"hi"</span> <span class="attr">src</span>=<span class="string">"/nihao.gif"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">title</span>=<span class="string">"hi"</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>W3School<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></div></pre></td></tr></table></figure>
<h1 id="层叠和特殊性"><a href="#层叠和特殊性" class="headerlink" title="层叠和特殊性"></a>层叠和特殊性</h1><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>有 <strong>!important</strong> 标志的规则，它优先于任何规则。</p>
<h3 id="特殊性"><a href="#特殊性" class="headerlink" title="特殊性"></a>特殊性</h3><table>
<thead>
<tr>
<th style="text-align:center">选择器</th>
<th style="text-align:center">特殊性</th>
<th style="text-align:center">以10为基数的特殊性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Style=“ ”</td>
<td style="text-align:center">1,0,0,0</td>
<td style="text-align:center">1000</td>
</tr>
<tr>
<td style="text-align:center">#wrapper #content {}</td>
<td style="text-align:center">0,2,0,0</td>
<td style="text-align:center">200</td>
</tr>
<tr>
<td style="text-align:center">#content .datePosted {}</td>
<td style="text-align:center">0,1,1,0</td>
<td style="text-align:center">110</td>
</tr>
<tr>
<td style="text-align:center">div#content {}</td>
<td style="text-align:center">0,1,0,1</td>
<td style="text-align:center">101</td>
</tr>
<tr>
<td style="text-align:center">#content {}</td>
<td style="text-align:center">0,1,0,0</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">p.comment .dateposted {}</td>
<td style="text-align:center">0,0,2,1</td>
<td style="text-align:center">21</td>
</tr>
<tr>
<td style="text-align:center">p.comment {}</td>
<td style="text-align:center">0,0,1,1</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">div p {}</td>
<td style="text-align:center">0,0,0,2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">p {}</td>
<td style="text-align:center">0,0,0,1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#content div#main-content h2&#123;</div><div class="line">color: gray;</div><div class="line">&#125;</div><div class="line">#content #main-content&gt;h2 &#123;</div><div class="line">color: blue;</div><div class="line">&#125;</div><div class="line">body #content div[div="main-content"] h2 &#123;</div><div class="line">color: green;</div><div class="line">&#125;</div><div class="line">#main-content div.news-story h2 &#123;</div><div class="line">color: orange;</div><div class="line">&#125;</div><div class="line">#main-content [class="news-story"] h2 &#123;</div><div class="line">color: yellow;</div><div class="line">&#125;</div><div class="line">div#main-content div.news-story h2.first &#123;</div><div class="line">color: red;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main-content"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>哇<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"news-story"</span>&gt;</span>   </div><div class="line">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"first"</span>&gt;</span>BigBong<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>嘻嘻<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="/images/css3.png" alt="css3"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;给自己的要求&quot;&gt;&lt;a href=&quot;#给自己的要求&quot; class=&quot;headerlink&quot; title=&quot;给自己的要求&quot;&gt;&lt;/a&gt;给自己的要求&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;class应该用在概念上相似的元素，这些元素可以出现在同一页面上的多个位置。&lt;/li&gt;
&lt;li&gt;ID应该用于不同的唯一的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;DTD（文档类型定义）&quot;&gt;&lt;a href=&quot;#DTD（文档类型定义）&quot; class=&quot;headerlink&quot; title=&quot;DTD（文档类型定义）&quot;&gt;&lt;/a&gt;DTD（文档类型定义）&lt;/h1&gt;&lt;p&gt;DOCTYPE声明是指HTML文档开头处的一行或两行代码。它描述使用哪个DTD。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但是在HTML5中就不需要URL，浏览器一般不读取这些文件。而是只识别常见的DOCTYPE声明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;选择器&quot;&gt;&lt;a href=&quot;#选择器&quot; class=&quot;headerlink&quot; title=&quot;选择器&quot;&gt;&lt;/a&gt;选择器&lt;/h1&gt;&lt;p&gt;选择器最常用的两种： &lt;strong&gt;类型选择器&lt;/strong&gt; 和 &lt;strong&gt;后代选择器&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://xuzihao.fun/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://xuzihao.fun/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>使用阿里云oss踩得坑</title>
    <link href="http://xuzihao.fun/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91oss%E8%B8%A9%E5%BE%97%E5%9D%91.html"/>
    <id>http://xuzihao.fun/使用阿里云oss踩得坑.html</id>
    <published>2017-08-22T06:44:24.000Z</published>
    <updated>2017-08-22T06:46:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Provisional-headers-are-shown"><a href="#Provisional-headers-are-shown" class="headerlink" title="Provisional headers are shown"></a>Provisional headers are shown</h1><p>首先我现在console里看见以下报错：</p>
<p><img src="/images/oss1.png" alt="oss1"></p>
<a id="more"></a>
<p>接着我去了network里看：</p>
<p><img src="/images/oss3.png" alt="oss3"></p>
<p>最后找到了根本问题所在：</p>
<p>因为我在<strong>https</strong>的网页中，是不允许我去发<strong>http</strong>的请求，所以我需要去自己发起请求的client代码中加入secure：true。</p>
<p><img src="/images/oss2.png" alt="oss2"></p>
<h1 id="ErrorCode-AccessForbidden"><a href="#ErrorCode-AccessForbidden" class="headerlink" title="ErrorCode: AccessForbidden"></a>ErrorCode: AccessForbidden</h1><p><img src="/images/oss4.png" alt="oss4"></p>
<p>如果遇到以上问题，那肯定是你的 <strong>CORS</strong>没有配置或者配置不对。</p>
<p>我们需要到阿里云的的OSS控制台中做以下设置：</p>
<p><img src="/images/oss5.png" alt="oss5"></p>
<p>以下也是上述没设置好的错，错误为：<strong>出错请求的HTTP状态码</strong></p>
<p><img src="/images/oss6.png" alt="oss6"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Provisional-headers-are-shown&quot;&gt;&lt;a href=&quot;#Provisional-headers-are-shown&quot; class=&quot;headerlink&quot; title=&quot;Provisional headers are shown&quot;&gt;&lt;/a&gt;Provisional headers are shown&lt;/h1&gt;&lt;p&gt;首先我现在console里看见以下报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/oss1.png&quot; alt=&quot;oss1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="阿里云服务的使用" scheme="http://xuzihao.fun/categories/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="JavaScript" scheme="http://xuzihao.fun/tags/JavaScript/"/>
    
      <category term="node.js" scheme="http://xuzihao.fun/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>支付宝小程序踩坑（一）</title>
    <link href="http://xuzihao.fun/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F.html"/>
    <id>http://xuzihao.fun/支付宝小程序.html</id>
    <published>2017-08-20T12:49:24.000Z</published>
    <updated>2017-11-12T07:50:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是支付宝小程序编译器的主界面</p>
<p><img src="/images/paytest1.png" alt="paytest1"></p>
<a id="more"></a>
<p>这是 <strong>hello，world</strong>的文件树。是基于js语言。小程序开发者工具默认支持 ES5/ES6/ES7，推荐使用 ES6 以上语法。而且还内置了 <strong>ESLint</strong> 支持</p>
<p><img src="/images/paytest2.png" alt="paytest2"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是支付宝小程序编译器的主界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/paytest1.png&quot; alt=&quot;paytest1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="http://xuzihao.fun/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://xuzihao.fun/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>CO函数，异步</title>
    <link href="http://xuzihao.fun/CO%E5%87%BD%E6%95%B0%EF%BC%8C%E5%BC%82%E6%AD%A5.html"/>
    <id>http://xuzihao.fun/CO函数，异步.html</id>
    <published>2017-08-18T15:01:50.000Z</published>
    <updated>2017-09-02T00:13:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CO函数库"><a href="#CO函数库" class="headerlink" title="CO函数库"></a>CO函数库</h1><p><a href="https://github.com/tj/co" target="_blank" rel="external">co 函数库</a>是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 <strong>Generator 函数的自动执行</strong>。</p>
<p>有一个 Generator 函数，用于依次读取两个文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</div><div class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</div><div class="line">  <span class="built_in">console</span>.log(f1.toString());</div><div class="line">  <span class="built_in">console</span>.log(f2.toString());</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>co 函数库可以让你不用编写 Generator 函数的执行器。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</div><div class="line">co(gen);</div></pre></td></tr></table></figure>
<p>上面代码中，Generator 函数只要传入 co 函数，就会自动执行。</p>
<p>co 函数返回一个 Promise 对象，因此可以用 then 方法添加回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">co(gen).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Generator 函数执行完成'</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="co-函数库的源码"><a href="#co-函数库的源码" class="headerlink" title="co 函数库的源码"></a>co 函数库的源码</h2><p>co 就是上面那个自动执行器的扩展，它的<a href="https://github.com/tj/co/blob/master/index.js" target="_blank" rel="external">源码</a>只有几十行，非常简单。</p>
<p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在返回的 Promise 对象里面，co 先检查参数 gen 是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为 resolved 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.call(ctx);</div><div class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着，co 将 Generator 函数的内部指针对象的 next 方法，包装成 onFulefilled 函数。这主要是为了能够捕捉抛出的错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.call(ctx);</div><div class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</div><div class="line"></div><div class="line">    onFulfilled();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ret;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        ret = gen.next(res);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="keyword">return</span> reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">    &#125;    </div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，就是关键的 next 函数，它会反复调用自身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</div><div class="line">  <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</div><div class="line">  <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</div><div class="line">  <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></div><div class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码中，next 函数的内部代码，一共只有四行命令。</p>
<blockquote>
<p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p>
<p>第二行，确保每一步的返回值，是 Promise 对象。</p>
<p>第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。</p>
<p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。</p>
</blockquote>
<h2 id="并发的异步操作"><a href="#并发的异步操作" class="headerlink" title="并发的异步操作"></a>并发的异步操作</h2><p>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>
<p>这时，要把并发的操作都放在数组或对象里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> values = [n1,n2,n3];</div><div class="line">  <span class="keyword">yield</span> values.map(somethingAsync);</div><div class="line">&#125;);</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">somethingAsync</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> y</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p># </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CO函数库&quot;&gt;&lt;a href=&quot;#CO函数库&quot; class=&quot;headerlink&quot; title=&quot;CO函数库&quot;&gt;&lt;/a&gt;CO函数库&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tj/co&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;co 函数库&lt;/a&gt;是著名程序员 TJ Holowaychuk 于2013年6月发布的一个小工具，用于 &lt;strong&gt;Generator 函数的自动执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有一个 Generator 函数，用于依次读取两个文件。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; gen = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;* (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; f1 = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; readFile(&lt;span class=&quot;string&quot;&gt;&#39;/etc/fstab&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; f2 = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; readFile(&lt;span class=&quot;string&quot;&gt;&#39;/etc/shells&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(f1.toString());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(f2.toString());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Javascript修仙之路" scheme="http://xuzihao.fun/categories/Javascript%E4%BF%AE%E4%BB%99%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="JavaScript" scheme="http://xuzihao.fun/tags/JavaScript/"/>
    
      <category term="node.js" scheme="http://xuzihao.fun/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript函数</title>
    <link href="http://xuzihao.fun/JavaScript%E5%87%BD%E6%95%B0.html"/>
    <id>http://xuzihao.fun/JavaScript函数.html</id>
    <published>2017-08-16T14:45:00.000Z</published>
    <updated>2017-09-22T09:50:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>在JavaScript中，函数是<strong>一等公民</strong>。函数是<strong>第一型对象</strong>。</p>
<p>所以说，我们可以将其视为其他任意类型的JavaScript对象。</p>
<a id="more"></a>
<p>在JavaScript中函数可以：</p>
<ul>
<li>可以赋值给<strong>变量，数组，或其他对象</strong>的属性</li>
<li>可以通过<strong>字面量</strong>进行创建</li>
<li>将其作为<strong>参数</strong>进行传递</li>
<li>可以作为函数的<strong>返回值</strong>进行返回</li>
<li>可以拥有<strong>动态创建并赋值</strong>的属性</li>
</ul>
<p>最重要是的，它们还可以被<strong>调用</strong>。这些调用通常是以<strong>异步方式</strong>进行调用。</p>
<h1 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h1><p>回调函数的术语源于：我们定义一个函数，以便其他一些代码在适当的时机回头再调用他。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">useless</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> callback();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">'Demo arigato'</span>;</div><div class="line">assert(useless(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> text;</div><div class="line">&#125;) ===text, <span class="string">"This useless function works!"</span> + text);</div><div class="line"><span class="comment">//assert是测试函数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assert</span>(<span class="params">value, desc</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">  li.className = value ? <span class="string">"pase"</span> : <span class="string">"fail"</span>;</div><div class="line">  li.appendChild(<span class="built_in">document</span>.createTextNode(desc));</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"results"</span>).appendChild(li);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="函数字面量"><a href="#函数字面量" class="headerlink" title="函数字面量"></a>函数字面量</h1><p>函数字面量由4个部分组成</p>
<ul>
<li>function关键字</li>
<li>可选名称。</li>
<li>括号内部，一个以逗号分隔的参数列表。</li>
<li>包含在大括号内的一系列JavaScript语句叫 <strong>函数体</strong>。</li>
</ul>
<p>注意：</p>
<blockquote>
<p>所有的函数都有name属性，该属性保存的是他们的名称的字符串。</p>
<p>当然没有名称的函数也有name属性，只是为空字符串。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> canFly = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数我们可以通过它的引用 <strong>canFly</strong> 进行调用。它与canFly函数几乎一模一样，但是不一样的地方在于它的字符串值为” ”，而不是“canFly”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.isDeadly = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们可以（ <strong>window.isDeadly() || isDeadly()</strong> ）去调用这个函数，其实这就跟命名函数几乎一模一样了。</p>
<h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>4个不同的方式可以进行函数调用。</p>
<ol>
<li>作为一个函数进行调用</li>
<li>作为一个方法进行调用，在对象是进行调用，支持面向对象编程</li>
<li>作为构造器进行调用，创建一个新对象</li>
<li>通过<code>apply()</code>或<code>call()</code>方法进行调用。</li>
</ol>
<h2 id="函数传递两个隐式参数"><a href="#函数传递两个隐式参数" class="headerlink" title="函数传递两个隐式参数"></a>函数传递两个隐式参数</h2><p><strong>arguments和this</strong></p>
<p>隐式（limplicit），意味着这些参数不会显示列在函数签名里。但是他们都会默默的传递给函数并存在于函数作用于内。</p>
<h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>它是传递给函数的所有参数的一个集合，它有一个<code>length</code>属性。比如：</p>
<p><code>arguments[2]</code>表示获取第三个参数。</p>
<p>虽然它可以使用数组进行获取，甚至可以用for循环对它进行遍历。但是它确实不是JS数组。</p>
<p>我们只要将它看成一个类数组结构，并且 <strong>只拥有数组</strong> 的某些特性，仅此而已。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this参数引用了与该函数调用进行隐式关联的一个对象，被称为<strong>函数上下文。</strong></p>
<h2 id="作为函数进行调用"><a href="#作为函数进行调用" class="headerlink" title="作为函数进行调用"></a>作为函数进行调用</h2><p>很简单，比如说：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hi</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> hello;</div><div class="line">&#125;</div><div class="line">hi();</div><div class="line"></div><div class="line"><span class="keyword">var</span> xzh = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> xuzihao;</div><div class="line">&#125;</div><div class="line">xzh();</div></pre></td></tr></table></figure>
<p>这就是作为函数调用。这种方法调用函数的上下文就是——-window对象。</p>
<h2 id="作为方法进行调用"><a href="#作为方法进行调用" class="headerlink" title="作为方法进行调用"></a>作为方法进行调用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">o.whatever = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">o.whatever();</div></pre></td></tr></table></figure>
<p>那么<code>o.whatever</code>的函数上下文为<strong>o</strong>。</p>
<h2 id="作为构造器进行调用"><a href="#作为构造器进行调用" class="headerlink" title="作为构造器进行调用"></a>作为构造器进行调用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">creep</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">new</span> creep();</div></pre></td></tr></table></figure>
<h3 id="构造器的超能力"><a href="#构造器的超能力" class="headerlink" title="构造器的超能力"></a>构造器的超能力</h3><p>构造器调用时，下面的特殊行为会发生：</p>
<ul>
<li>创建一个新的空对象</li>
<li>传递给构造器的对象是this参数，从而成为构造器的函数上下文。</li>
<li>如果没有显式的返回值，新创建的对象则作为构造器的返回值进行返回。</li>
</ul>
<h2 id="使用apply-和call-方法进行调用"><a href="#使用apply-和call-方法进行调用" class="headerlink" title="使用apply()和call()方法进行调用"></a>使用apply()和call()方法进行调用</h2><p>可以显式指定任何一个对象作为其函数上下文。</p>
<p>JavaScript的每个函数都有<strong>apply()</strong> 和 <strong>call()</strong>方法。使用其中一个我们都可以实现这种功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">juggle</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</div><div class="line">  	<span class="keyword">for</span>(<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; <span class="built_in">arguments</span>.length; n++)&#123;</div><div class="line">        result += <span class="built_in">arguments</span>[n];</div><div class="line">    &#125;</div><div class="line">  	<span class="keyword">this</span>.result = result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ninja1 = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> ninja2 = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//apply() 传入2个参数： 一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。</span></div><div class="line">juggle.apply(ninja1, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</div><div class="line"><span class="comment">//call() 传入两个参数： 一个是作为函数上下文的对象，另外一个是一个参数列表。</span></div><div class="line">juggle.call(ninja2, <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</div><div class="line"></div><div class="line"><span class="comment">//assert是断言测试用的</span></div><div class="line">assert(ninja1.result === <span class="number">10</span>, <span class="string">"juggled via apply"</span>);</div><div class="line">assert(ninja2.result === <span class="number">26</span>, <span class="string">"juggled via call"</span>);</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>作为函数进行调用：该上下文是方法的拥有者。</li>
<li>作为全局函数进行调用：该上下文永远是windos。</li>
<li>作为构造器函数进行调用：该上下文对象则是新创建的对象实例。</li>
<li>通过函数的apply（）或call（）方法进行调用时，上下文可以设置成任意值。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JavaScript中，函数是&lt;strong&gt;一等公民&lt;/strong&gt;。函数是&lt;strong&gt;第一型对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以说，我们可以将其视为其他任意类型的JavaScript对象。&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript修仙之旅" scheme="http://xuzihao.fun/categories/Javascript%E4%BF%AE%E4%BB%99%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="JavaScript" scheme="http://xuzihao.fun/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React Native iOS/android环境配置</title>
    <link href="http://xuzihao.fun/React%20Native%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html"/>
    <id>http://xuzihao.fun/React Native环境配置.html</id>
    <published>2017-08-14T04:32:53.000Z</published>
    <updated>2017-09-18T01:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Native环境配置"><a href="#React-Native环境配置" class="headerlink" title="React Native环境配置"></a>React Native环境配置</h1><h1 id="Ios开发环境"><a href="#Ios开发环境" class="headerlink" title="Ios开发环境"></a>Ios开发环境</h1><p>因为我是在mac下搭建环境的。所以比较方便。</p>
<ul>
<li><p>Xcode时<strong>必须</strong>的！</p>
</li>
<li><p>brew install node        //电脑需要有<strong>node</strong></p>
</li>
<li><p>brew install watchman    //这是用来监视文件系统中的更改的工具</p>
</li>
<li><p>npm install -g react-native-cli</p>
<p>然后我们打开 <strong>Xcode</strong></p>
<p><img src="/images/xcode.png" alt="xcode"></p>
<a id="more"></a>
</li>
</ul>
<p>接下来我们需要执行命令</p>
<p><strong>react-native init AwesomeProject</strong></p>
<p>Then：我们需要在Xcode里打开</p>
<p><img src="/images/xcode文件.png" alt="xcode文件"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">接着在终端里</div><div class="line">cd AwesomeProject</div><div class="line">then：</div><div class="line">react-native run-ios</div></pre></td></tr></table></figure>
<p>接下来我们等就好了</p>
<p><img src="/images/iphonex.png" alt="iphonex"></p>
<p>这就是成功界面</p>
<p>恭喜🎉！</p>
<h1 id="Android环境"><a href="#Android环境" class="headerlink" title="Android环境"></a>Android环境</h1><p>第一步与ios一样</p>
<ul>
<li>brew install node      </li>
<li>brew install watchman   </li>
</ul>
<p>我们就不做了。</p>
<p>接下来</p>
<h2 id="我们需要安装Java的环境。"><a href="#我们需要安装Java的环境。" class="headerlink" title="我们需要安装Java的环境。"></a>我们需要安装<code>Java</code>的环境。</h2><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">Download and install JDK 8 or newer</a></p>
<h2 id="安装Android环境"><a href="#安装Android环境" class="headerlink" title="安装Android环境"></a>安装<code>Android</code>环境</h2><ol>
<li>安装 <strong><a href="https://developer.android.com/studio/index.html" target="_blank" rel="external">Android studio</a></strong> </li>
<li><img src="/images/custon.png" alt="custon"></li>
<li>勾选<code>Performance</code>和<code>Android Virtual Device</code><img src="/images/sdk.png" alt="sdk"></li>
<li>安装完成后，在Android Studio的启动欢迎界面中选择<code>Configure | SDK Manager</code>。<img src="/images/config.png" alt="config"></li>
<li>在<code>SDK Platforms</code>窗口中，选择<code>Show Package Details</code></li>
</ol>
<p><img src="/images/palt.png" alt="palt"></p>
<p>然后tools里</p>
<p><img src="/images/sdttool.png" alt="sdttool"></p>
<p><img src="/images/sdktools.png" alt="sdktools"></p>
<p><img src="/images/sdksuppt.png" alt="sdksuppt"></p>
<h4 id="ANDROID-HOME环境变量"><a href="#ANDROID-HOME环境变量" class="headerlink" title="ANDROID_HOME环境变量"></a>ANDROID_HOME环境变量</h4><p>确保<code>ANDROID_HOME</code>环境变量正确地指向了你安装的Android SDK的路径。具体的做法是把下面的命令加入到<code>~/.bash_profile</code>文件中：(<strong>译注</strong>：~表示用户目录，即<code>/Users/你的用户名/</code>，而小数点开头的文件在Finder中是隐藏的，并且这个文件有可能并不存在。请在终端下使用<code>vi ~/.bash_profile</code>命令创建或编辑。如不熟悉vi操作，请点击<a href="http://www.eepw.com.cn/article/48018.htm" target="_blank" rel="external">这里</a>学习）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 如果你不是通过Android Studio安装的sdk，则其路径可能不同，请自行确定清楚。</div><div class="line">export ANDROID_HOME=~/Library/Android/sdk</div></pre></td></tr></table></figure>
<p>然后使用下列命令使其立即生效（否则重启后才生效）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure>
<p>可以使用<code>echo $ANDROID_HOME</code>检查此变量是否已正确设置。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>同样我们需要在<code>Android studio</code>中打开创建的文件夹下Android文件</p>
<p>然后去build</p>
<p><img src="/images/studio.png" alt="studio"></p>
<p>圆圈是选手机机型。</p>
<p>我们在正方形框框中先点击锤子然后点击绿色箭头之后在终端里输入以下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">react-native init AwesomeProject</div><div class="line">cd AwesomeProject</div><div class="line">react-native run-android</div></pre></td></tr></table></figure>
<p>下面就是成功画面！恭喜🎉！<img src="/images/Android.png" alt="Android"></p>
<h1 id="在搭建环境下踩得坑"><a href="#在搭建环境下踩得坑" class="headerlink" title="在搭建环境下踩得坑"></a>在搭建环境下踩得坑</h1><h2 id="Android下"><a href="#Android下" class="headerlink" title="Android下"></a>Android下</h2><p><img src="/images/安卓bug.png" alt="安卓bug"></p>
<p>这是我运行安卓的时候遇到的问题。我们需要在 <strong>Android studio</strong>先启动一个手机模拟器再去终端里输入指令：<code>react-native run-android</code> 就可以了</p>
<p><img src="/images/android tools.png" alt="android tools"></p>
<p>这个问题是说Build Tools 23.0.0.1太低至少需要25.0.0</p>
<p>但是我升级过后还不行。发现是配置文件里的问题。</p>
<p><img src="/images/gaibuild.png" alt="gaibuild"></p>
<p>这样就行啦！</p>
<h2 id="Ios下"><a href="#Ios下" class="headerlink" title="Ios下"></a>Ios下</h2><p>具体出错问题描述找不到了，但是情况还是记得的。</p>
<p>就是说我ios的虚拟机打开了但是我在上面看不见自己的项目。</p>
<p>这时候google到答案。。</p>
<p><img src="/images/ios解决问题1.png" alt="ios解决问题1"></p>
<p>需要开一个终端，然后去在你的项目下<code>npm install</code> 就是这样。。具体情况我也不知道发生了什么哈哈哈</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;React-Native环境配置&quot;&gt;&lt;a href=&quot;#React-Native环境配置&quot; class=&quot;headerlink&quot; title=&quot;React Native环境配置&quot;&gt;&lt;/a&gt;React Native环境配置&lt;/h1&gt;&lt;h1 id=&quot;Ios开发环境&quot;&gt;&lt;a href=&quot;#Ios开发环境&quot; class=&quot;headerlink&quot; title=&quot;Ios开发环境&quot;&gt;&lt;/a&gt;Ios开发环境&lt;/h1&gt;&lt;p&gt;因为我是在mac下搭建环境的。所以比较方便。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Xcode时&lt;strong&gt;必须&lt;/strong&gt;的！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;brew install node        //电脑需要有&lt;strong&gt;node&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;brew install watchman    //这是用来监视文件系统中的更改的工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;npm install -g react-native-cli&lt;/p&gt;
&lt;p&gt;然后我们打开 &lt;strong&gt;Xcode&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/xcode.png&quot; alt=&quot;xcode&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React Native" scheme="http://xuzihao.fun/categories/React-Native/"/>
    
    
      <category term="React" scheme="http://xuzihao.fun/tags/React/"/>
    
      <category term="React Native" scheme="http://xuzihao.fun/tags/React-Native/"/>
    
      <category term="iOS" scheme="http://xuzihao.fun/tags/iOS/"/>
    
      <category term="Android" scheme="http://xuzihao.fun/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象</title>
    <link href="http://xuzihao.fun/Javascript%E5%AF%B9%E8%B1%A1.html"/>
    <id>http://xuzihao.fun/Javascript对象.html</id>
    <published>2017-08-02T14:30:44.000Z</published>
    <updated>2017-12-01T14:18:49.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Javascript对象"><a href="#Javascript对象" class="headerlink" title="Javascript对象"></a>Javascript对象</h1><p>在JavaScript中，数组是对象，函数是对象，正则表达式是对象。那么对象自然也是对象。</p>
<ul>
<li>JavaScript中的对象是无类型的。</li>
<li>对象是属性的容器，其中每个属性都拥有名字和值。</li>
<li>JavaScript包含一种原型链的特性，允许对象继承另一个对象的属性。</li>
</ul>
<p><img src="http://ozar6ogjb.bkt.clouddn.com/_proto_.jpg" alt="\__proto__与prototype"></p>
<a id="more"></a>
<ul>
<li>对象最常见的用法<ul>
<li>创建（create）</li>
<li>设置（set）</li>
<li>查找（query）</li>
<li>删除（delete）</li>
<li>检测（test）</li>
<li>枚举（enumerate）</li>
</ul>
</li>
<li>每个属性还有一些与之相关的值，称为<strong>属性特性</strong><ul>
<li>可写</li>
<li>可枚举</li>
<li>可配置</li>
</ul>
</li>
<li>除了包含属性之外，每个对象还拥有三个相关的对象特性<ul>
<li>对象的原型(prototype)</li>
<li>对象的类(class)</li>
<li>对象的扩展标记</li>
</ul>
</li>
<li>内置对象，如<strong>数组，函数，日期，和正则表达式都是内置对象</strong></li>
<li>宿主对象，简单的理解就是BOM、DOM和自己定义的对象</li>
<li>自定义对象，就是我们自己创建的对象</li>
<li>自有属性，直接在对象中定义的属性</li>
<li>继承属性，在对象原型对象中定义的属性。</li>
</ul>
<h2 id="new创建对象"><a href="#new创建对象" class="headerlink" title="new创建对象"></a>new创建对象</h2><p><code>new</code> 运算符创建并初始化一个新对象。关键字new后跟随一个<strong>函数</strong>调用。<br>这个<strong>函数</strong>称做<strong>构造函数</strong>。</p>
<h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> empty_project = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> stooge = &#123;				<span class="comment">//对象字面量</span></div><div class="line">  <span class="string">"first-name"</span>: <span class="string">"Jerome"</span>,</div><div class="line">  <span class="string">"last-name"</span>: <span class="string">"Howard"</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一个对象字面量就是包围在一对花括号中的零或多个“名/值”对。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> flight = &#123;</div><div class="line">  <span class="attr">airline</span>: <span class="string">"Oceanic"</span>,</div><div class="line">  <span class="attr">number</span>: <span class="number">815</span>,</div><div class="line">  <span class="attr">departure</span>: &#123;</div><div class="line">    <span class="attr">IATA</span>: <span class="string">"SYD"</span>,</div><div class="line">    <span class="attr">time</span>: <span class="string">"2014-09-22 14:55"</span>,</div><div class="line">    <span class="attr">city</span>: <span class="string">"Sydney"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">arrival</span>:&#123;</div><div class="line">    <span class="attr">IATA</span>: <span class="string">"LAX"</span>,</div><div class="line">    <span class="attr">time</span>: <span class="string">"2004-09-23 10:42"</span>,</div><div class="line">    <span class="attr">city</span>: <span class="string">"Los Angeles"</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>属性的值可以从包括另一个对象字面量在内的任意表达式中获得。对象是可以嵌套的。</p>
<h2 id="属性的查询"><a href="#属性的查询" class="headerlink" title="属性的查询"></a>属性的查询</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stooge[<span class="string">"first-name"</span>] <span class="comment">//Jerome</span></div><div class="line">flight.departure.IATA <span class="comment">//SYD</span></div></pre></td></tr></table></figure>
<p>需要检索对象里包含的值，可以采用[ ]后缀中括住一个字符串表达式的方式。</p>
<p>但是最好用<code>.</code>表示法。因为它可读性好。</p>
<p>我们去检索不存在的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stooge[<span class="string">"middle-name"</span>]  <span class="comment">//undefined</span></div><div class="line">flight.status          <span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<p>||运算符可以用来填充默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> middle = stooge[<span class="string">"middle-name"</span>] || <span class="string">"(none)"</span>;</div><div class="line"><span class="keyword">var</span> status = flight.status || <span class="string">"unkown"</span>;</div></pre></td></tr></table></figure>
<p>如果我们从undefined的成员属性中取值会导致<code>TypeError</code>异常。这时候我们可以通过 <code>&amp;&amp;</code> 运算符来避免错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">flight.equipment 					<span class="comment">//undefined</span></div><div class="line">flight.equipment.model				<span class="comment">//throw "TypeError"</span></div><div class="line">flight.equipment &amp;&amp; flight.equipment.model 	<span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<h2 id="属性的设置"><a href="#属性的设置" class="headerlink" title="属性的设置"></a>属性的设置</h2><p>对象里的值可以通过赋值语句来更新。如果属性吗已经存在于对象里，那么这个属性的值会被替换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stooge[<span class="string">'first-name'</span>] = <span class="string">'Jerome'</span>;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stooge[<span class="string">'middle-name'</span>] = <span class="string">'Lester'</span>;</div><div class="line">stooge.nickname = <span class="string">'Curly'</span>;</div><div class="line">flight.equipment = &#123;</div><div class="line">  <span class="attr">model</span>: <span class="string">'Boeing 777'</span></div><div class="line">&#125;;</div><div class="line">flight.status = <span class="string">'overdue'</span>;</div></pre></td></tr></table></figure>
<p>那么这些属性全部会扩充到对象中。</p>
<h2 id="关联数组的对象"><a href="#关联数组的对象" class="headerlink" title="关联数组的对象"></a>关联数组的对象</h2><p><code>object[&quot;property&quot;]</code>，这个看起来更像数组，但是这个数组元素是通过字符串索引。这种数组就是<strong>关联数组</strong>，别名“散列”，“映射”，“字典”。<strong>JavaScript对象都是关联数组</strong>。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>对象通过引用来传递，他们永远不会被<strong>复制</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = hi;</div><div class="line">x.hello = <span class="string">'what'</span>;</div><div class="line"><span class="keyword">var</span> how = hi.hello;</div><div class="line">	<span class="comment">// how为what。</span></div><div class="line"><span class="comment">//因为x和hi是指向同一个对象的引用。</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;,b = &#123;&#125;,c = &#123;&#125;;</div><div class="line"><span class="comment">//a,b,c每个都引用一个不同的对象</span></div><div class="line">a = b = c = &#123;&#125;;</div><div class="line"><span class="comment">//a,b,c都是引用同一个空对象</span></div></pre></td></tr></table></figure>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>每个对象都连接着另一个对象相关联，这个对象就是原型。而且每一个对象都可以从原型继承属性。</p>
<p>所有通过对象字面量创建的对象都连接到<code>Object.prototype</code>，它是JavaScript中的标配对象。</p>
<p>那么由new Date()创建的Date对象的属性同时继承自<code>Date.prototype</code>和<code>Object.prototype</code>。这一系列链接在一起的原型对象，就是我们所说的<strong>原型链</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.beget !== <span class="string">'function'</span>)&#123;</div><div class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> another_stooge = <span class="built_in">Object</span>.create(stooge);</div></pre></td></tr></table></figure>
<p>Object增加一个create方法，这个方法创建一个使用原对象作为其原型的新对象。</p>
<h3 id="原型连接在更新时是不起作用的"><a href="#原型连接在更新时是不起作用的" class="headerlink" title="原型连接在更新时是不起作用的"></a>原型连接在更新时是不起作用的</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">another_stooge[<span class="string">'first-name'</span>] = <span class="string">'Harry'</span>;</div><div class="line">another_stooge[<span class="string">'middle-name'</span>] = <span class="string">'Moses'</span>;</div><div class="line">another_stooge.nickname = <span class="string">'Moe'</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>原型连接只有在检索值得时候才被用到。</p>
<p>如果我们尝试去获取对象的某个属性值，但对象没有此属性名。</p>
<p>JavaScript会从原型对象中获取属性值  ——&gt; 原型对象中没，就回去它原型中寻找 ——&gt;直到最后到达终点Object.prototype。</p>
<p>假如想要的属性不存在于原型链，那么结果就只能是undefined。</p>
<p>以上的过程为委托。</p>
</blockquote>
<h3 id="原型关系"><a href="#原型关系" class="headerlink" title="原型关系"></a>原型关系</h3><p>我们添加一个新的属性到<strong>原型</strong>中，该属性会立即对<strong>所有</strong>基于该原型创建的对象可见。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stooge.profession = <span class="string">'actor'</span>;</div><div class="line">another_stooge.profession  <span class="comment">//'actor</span></div></pre></td></tr></table></figure>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>typeof操作符对确定属性的类型很有帮助。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> flight.number	<span class="comment">//number</span></div><div class="line"><span class="keyword">typeof</span> flight.status 	<span class="comment">//string</span></div><div class="line"><span class="keyword">typeof</span> flight.arrival 	<span class="comment">//object</span></div><div class="line"><span class="keyword">typeof</span> flight.manifest 	<span class="comment">//undefined</span></div></pre></td></tr></table></figure>
<p>原型链中的任何值都会产生值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> flight.toString		<span class="comment">//function</span></div><div class="line"><span class="keyword">typeof</span> flight.constructor 	<span class="comment">//function</span></div></pre></td></tr></table></figure>
<p>有两种方法去处理掉这些不需要的属性。</p>
<ul>
<li>第一个是让你的程序做检查并丢弃为函数的属性。</li>
<li>另一个方法是<code>hasOwnProperty</code> 方法，如果对象拥有独有的属性，它将返回true。不会检查原型链</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">flight.hasOwnProperty(<span class="string">'number'</span>)			<span class="comment">//true</span></div><div class="line">flight.hasOwnProperty(<span class="string">'constructor'</span>)	<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>##属性的特性</p>
<p>数据属性的4个特性：</p>
<ul>
<li>它的值</li>
<li>可写性</li>
<li>可枚举性</li>
<li>可配置性</li>
</ul>
<p>存取器属性的4个特性：</p>
<ul>
<li>读取</li>
<li>写入</li>
<li>可枚举性</li>
<li>可配置性</li>
</ul>
<p>为了实现属性特性的查询和设置，我们就有了一个名为 <strong>”属性描述符（property descriptor）”</strong>。这个对象代表了那4个<strong>特性</strong>。</p>
<p>数据属性的描述符对象的属性有<code>value（它的值）</code>, <code>writable（可写性）</code>, <code>enumerable（可枚举性）</code>, <code>configurable（可配置性）</code>。</p>
<p>存取器属性的描述符对象的属性有<code>get属性</code>, <code>set属性</code>代替 <code>value（它的值）</code>, <code>writable（可写性）</code>, <code>enumerable（可枚举性）</code>,    <code>configurable（可配置性）</code>。</p>
<p>而且[<code>writable（可写性）</code>，<code>enumerable（可枚举性）</code>,<code>configurable（可配置性）</code>这仨都是布尔值]。</p>
<p>而且get属性和set属性是函数值。</p>
<p>我们通过调用<code>Object.getOwnPropertyDescriptor()</code>可以获得某个对象特定属性的属性描述符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,<span class="string">"x"</span>);</div><div class="line"><span class="comment">//返回&#123; value: 1, writable: true, enumerable: true, configurable: ture &#125;</span></div></pre></td></tr></table></figure>
<p>要想获得继承属性的特性，需要遍历原型链，<code>Object.getProtorypeOf()</code></p>
<p>要想设置属性的特性，需要调用<code>Object.definePeoperty()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line"><span class="comment">//添加一个不可枚举的数据熟悉</span></div><div class="line"><span class="built_in">Object</span>.definePeoperty(o, <span class="string">"x"</span>, &#123;</div><div class="line">  <span class="attr">value</span>:<span class="number">1</span>,</div><div class="line">  <span class="attr">writable</span>:<span class="literal">true</span>,</div><div class="line">  <span class="attr">enumerable</span>:<span class="literal">false</span>,</div><div class="line">  <span class="attr">configurable</span>:<span class="literal">true</span>,</div><div class="line">&#125;);</div><div class="line"><span class="comment">//属性是存在的，但是不可枚举</span></div><div class="line">o.x; 						<span class="comment">// =&gt; 1</span></div><div class="line"><span class="built_in">Object</span>.keys(o);				<span class="comment">// =&gt; []</span></div><div class="line"></div><div class="line"><span class="comment">//对属性x做修改，让它变为只读</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">"x"</span>,&#123;<span class="attr">writable</span>: flase&#125;);</div><div class="line"></div><div class="line"><span class="comment">//试图去改</span></div><div class="line">o.x = <span class="number">2</span>;				<span class="comment">//操作失败，但是不报错，在严格模式下会抛出类型错误异常</span></div><div class="line">o.x;					<span class="comment">// =&gt; 1</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.definePropetry(o, <span class="string">"x"</span>, &#123;<span class="attr">value</span>:<span class="number">2</span>&#125;);</div><div class="line">o.x;					<span class="comment">// =&gt; 2</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.definePropetry(o, <span class="string">"x"</span>, &#123;<span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;&#125;);</div><div class="line">o.x;					<span class="comment">// =&gt; 0</span></div></pre></td></tr></table></figure>
<h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><p>对象的类属性是一个<strong>字符串</strong>。</p>
<p>##序列化对象</p>
<p>对象序列化是指将对象的状态转换为字符串，也可将字符串还原为对象。</p>
<p><code>JSON.stringify()</code>,<code>JSON.parse()</code>用来序列化和还原JavaScript对象。</p>
<h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">1</span>&#125;.toString();</div><div class="line"></div><div class="line"><span class="comment">// =&gt; [object, Object]</span></div></pre></td></tr></table></figure>
<h3 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString()"></a>toLocaleString()</h3><p>这个方法返回一个表示这个对象的本地化字符串.</p>
<h3 id="toJSON"><a href="#toJSON" class="headerlink" title="toJSON()"></a>toJSON()</h3><p>Object.prototype实际上是没有定义toJSON()方法的，JSON.stringify()方法会调用toJSON()方法。</p>
<h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h3><p>这个方法和<code>toString()</code>非常类似。</p>
<p>当JavaScript需要将对象转换为某种原始值而非字符串的时候才会调用它，尤其是转换为数字的时候。</p>
<h2 id="减少全局变量污染"><a href="#减少全局变量污染" class="headerlink" title="减少全局变量污染"></a>减少全局变量污染</h2><p>最小化使用全局变量的方法之一是为你的应用只创建一个<strong>唯一</strong>的全局变量！！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;; 		<span class="comment">//该变量此时变成你的应用的容器</span></div><div class="line"></div><div class="line">MYAPP.stooge = &#123;</div><div class="line">  <span class="string">"first-name"</span>: <span class="string">"Joe"</span>,</div><div class="line">  <span class="string">"last-name"</span>: <span class="string">"Howard"</span></div><div class="line">&#125;;</div><div class="line">MYAPP.flight = &#123;</div><div class="line">  <span class="attr">airline</span>: <span class="string">"Oceanic"</span>,</div><div class="line">  <span class="attr">number</span>: <span class="number">815</span>,</div><div class="line">  <span class="attr">departure</span>: &#123;</div><div class="line">    <span class="attr">IATA</span>: <span class="string">"SYD"</span>,</div><div class="line">    <span class="attr">time</span>: <span class="string">"2004-09-22 14:55"</span>,</div><div class="line">    <span class="attr">city</span>: <span class="string">"Sydney"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">arrival</span>: &#123;</div><div class="line">    <span class="attr">IATA</span>: <span class="string">"LAX"</span>,</div><div class="line">    <span class="attr">time</span>: <span class="string">"2004-09-23 21:59"</span>,</div><div class="line">    <span class="attr">city</span>: <span class="string">"Los Angeles"</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>只要把全局性的资源都纳入一个名称空间之下，你的<strong>程序与其他应用程序、组件、类库直接发送冲突的可能性就会显著降低。</strong></p>
<p>因为<code>MYAPP.stooge</code>指向的是顶层结构。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Javascript对象&quot;&gt;&lt;a href=&quot;#Javascript对象&quot; class=&quot;headerlink&quot; title=&quot;Javascript对象&quot;&gt;&lt;/a&gt;Javascript对象&lt;/h1&gt;&lt;p&gt;在JavaScript中，数组是对象，函数是对象，正则表达式是对象。那么对象自然也是对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript中的对象是无类型的。&lt;/li&gt;
&lt;li&gt;对象是属性的容器，其中每个属性都拥有名字和值。&lt;/li&gt;
&lt;li&gt;JavaScript包含一种原型链的特性，允许对象继承另一个对象的属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://ozar6ogjb.bkt.clouddn.com/_proto_.jpg&quot; alt=&quot;\__proto__与prototype&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript修仙之旅" scheme="http://xuzihao.fun/categories/Javascript%E4%BF%AE%E4%BB%99%E4%B9%8B%E6%97%85/"/>
    
    
      <category term="JavaScript" scheme="http://xuzihao.fun/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Promise &amp;&amp; Generator &amp;&amp; Async</title>
    <link href="http://xuzihao.fun/%E5%BC%82%E6%AD%A5.html"/>
    <id>http://xuzihao.fun/异步.html</id>
    <published>2017-08-01T11:35:44.000Z</published>
    <updated>2017-09-01T10:03:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h1><h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>JavaScript 语言对异步编程的实现，就是回调函数。<strong>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。</strong>它的英语名字 callback，直译过来就是”<strong>重新调用</strong>“。</p>
<p>读取文件进行处理，是这样写的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>上面代码中，readFile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了 /etc/passwd 这个文件以后，回调函数才会执行。</p>
<p><strong>为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象err？</strong></p>
<p>设计一个回调函数的时候，第一个参数是err，用于优先解决错误，后面再传递参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fs.readFile(filePath, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="comment">//handle the error</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// use the data object</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p>
</blockquote>
<h2 id="那么我们可以用Promise来解决"><a href="#那么我们可以用Promise来解决" class="headerlink" title="那么我们可以用Promise来解决"></a>那么我们可以用Promise来解决</h2><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fs.readFile(fileA, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">  fs.readFile(fileB, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果依次读取多个文件，就会出现多重嵌套。代码就横向发展</p>
<p>Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> readFile = <span class="built_in">require</span>(<span class="string">'fs-readfile-promise'</span>);</div><div class="line"></div><div class="line">readFile(fileA)</div><div class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data.toString());</div><div class="line">&#125;)</div><div class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> readFile(fileB);</div><div class="line">&#125;)</div><div class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data.toString());</div><div class="line">&#125;)</div><div class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们会发现一眼看去都是一堆 then，原来的语义变得很不清楚。</p>
<h2 id="那么我们就要用到Generator函数"><a href="#那么我们就要用到Generator函数" class="headerlink" title="那么我们就要用到Generator函数"></a>那么我们就要用到Generator函数</h2><p>我们可以这样去理解协程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dota2游戏开始了,你开始操刀祈求者--卡尔.</div><div class="line">这时你妈妈打电话让你赶紧把楼顶的被子和衣服收一下,这时候你很着急.</div><div class="line">你游戏才玩到一半,但是又不得不去执行你老妈的指令.</div><div class="line">没办法,你只好敲击F12选择了暂停游戏.</div><div class="line">紧接着你把被子和衣服收好了,再次敲击F12游戏继续开始.</div><div class="line">你开始了自己的3杀/4杀/5杀之旅,很舒服.</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>协程A(游戏开始)开始执行</li>
<li>协程A执行到一半,暂停(敲击F12游戏暂停),执行权交给了协程B(收被子,衣服)</li>
<li>(收好后)协程B交还执行权</li>
<li>协程A(敲击F12游戏继续)恢复执行</li>
</ul>
</blockquote>
<p>用代码来说:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> dota2;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p>
<h1 id="Generator函数概念"><a href="#Generator函数概念" class="headerlink" title="Generator函数概念"></a>Generator函数概念</h1><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</div><div class="line">  <span class="keyword">return</span> y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其他的概念可以看我上篇<a href="http://adherentman.cn/Generator.html" target="_blank" rel="external">Generator函数概念</a></p>
<h1 id="Thunk-函数"><a href="#Thunk-函数" class="headerlink" title="Thunk 函数"></a>Thunk 函数</h1><p>编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;     </div><div class="line">&#125;</div><div class="line"></div><div class="line">f(x + <span class="number">5</span>);</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">thunk</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> thunk() * <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，函数 f 的参数 被thunk函数替换了.</p>
<p><strong>这就是 Thunk 函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。</strong></p>
<h1 id="终极武器—-Async函数"><a href="#终极武器—-Async函数" class="headerlink" title="终极武器—-Async函数"></a>终极武器—-Async函数</h1><p><strong>异步编程的最高境界，就是根本不用关心它是不是异步。</strong></p>
<p>async 函数就是隧道尽头的亮光，很多人认为它是异步操作的终极解决方案。</p>
<p><strong>所谓async函数，其实是Generator函数的语法糖。</strong></p>
<p>前文有一个 Generator 函数，依次读取两个文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span> (error) reject(error);</div><div class="line">      resolve(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</div><div class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</div><div class="line">  <span class="built_in">console</span>.log(f1.toString());</div><div class="line">  <span class="built_in">console</span>.log(f2.toString());</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>写成 async 函数，就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</div><div class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</div><div class="line">  <span class="built_in">console</span>.log(f1.toString());</div><div class="line">  <span class="built_in">console</span>.log(f2.toString());</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</p>
<h2 id="async-函数的优点"><a href="#async-函数的优点" class="headerlink" title="async 函数的优点"></a>async 函数的优点</h2><p>async 函数对 Generator 函数的改进，体现在以下三点。</p>
<p><strong>（1）内置执行器。</strong> Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = asyncReadFile();</div></pre></td></tr></table></figure>
<p> <strong>(2)</strong> 上面的代码调用了asyncReadFile函数,然后他就会自动执行,输出最后的结果.完全不像Generator函数,需要调用next方法,或者co模块,才能得到真正的执行,从而得到最终结果.</p>
<p><strong>（3）更好的语义。</strong> async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p>
<p><strong>（4）更广的适用性。</strong> co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
<p><strong>(5）</strong>返回值是Promise，这比Generator函数返回的是Iterator对象方便多了。你可以用then()指定下一步操作。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><code>async</code>函数的实现就是将<code>Generator</code>函数和自动执行器包装在一个函数中。如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于 </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 自动执行器</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> gen = genF();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">var</span> next = nextF()</div><div class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">        <span class="keyword">return</span> reject(e)</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (next.done) &#123;</div><div class="line">        <span class="keyword">return</span> resolve(next.value)</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(v) &#125;)</div><div class="line">      &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e) &#125;)</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>) &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="async函数用法"><a href="#async函数用法" class="headerlink" title="async函数用法"></a>async函数用法</h2><p>（1）<code>async</code>函数返回一个<code>Promise</code>对象，可以是<code>then()</code>方法添加回调函数。<br>（2）当函数执行时，一旦遇到<code>await()</code>就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<p>下面是一个延迟输出结果的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(resolve, ms)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</div><div class="line">  <span class="keyword">await</span> timeout(ms)</div><div class="line">  <span class="built_in">console</span>.log(value)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 延迟500ms后输出 "Hello World!"</span></div><div class="line">asyncPrint(<span class="string">'Hello World!'</span>, <span class="number">500</span>)</div></pre></td></tr></table></figure>
<h2 id="Async-后面是一个promise，await-后面也要跟一个promise"><a href="#Async-后面是一个promise，await-后面也要跟一个promise" class="headerlink" title="Async 后面是一个promise，await 后面也要跟一个promise"></a>Async 后面是一个promise，await 后面也要跟一个promise</h2><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>（1）<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>reject</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p>
<p>（2）<code>await</code>命令只能用在<code>async</code>函数中，用在普通函数中会报错。</p>
<p>（3）<code>ES6</code>将<code>await</code>增加为保留字。如果使用这个词作为标识符，在<code>ES5</code>中是合法的，但是<code>ES6</code>会抛出 <code>SyntaxError</code>（语法错误）。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>阮一峰 《ES6标准入门》</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;异步操作&quot;&gt;&lt;a href=&quot;#异步操作&quot; class=&quot;headerlink&quot; title=&quot;异步操作&quot;&gt;&lt;/a&gt;异步操作&lt;/h1&gt;&lt;h1 id=&quot;回调函数&quot;&gt;&lt;a href=&quot;#回调函数&quot; class=&quot;headerlink&quot; title=&quot;回调函数&quot;&gt;&lt;/a&gt;回调函数&lt;/h1&gt;&lt;p&gt;JavaScript 语言对异步编程的实现，就是回调函数。&lt;strong&gt;所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。&lt;/strong&gt;它的英语名字 callback，直译过来就是”&lt;strong&gt;重新调用&lt;/strong&gt;“。&lt;/p&gt;
&lt;p&gt;读取文件进行处理，是这样写的:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;fs.readFile(&lt;span class=&quot;string&quot;&gt;&#39;/etc/passwd&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;err, data&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (err) &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; err;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(data);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Javascript修仙之路" scheme="http://xuzihao.fun/categories/Javascript%E4%BF%AE%E4%BB%99%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="JavaScript" scheme="http://xuzihao.fun/tags/JavaScript/"/>
    
      <category term="node.js" scheme="http://xuzihao.fun/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>React-Redux和Redux</title>
    <link href="http://xuzihao.fun/redux.html"/>
    <id>http://xuzihao.fun/redux.html</id>
    <published>2017-07-31T01:18:26.000Z</published>
    <updated>2017-11-09T14:43:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>react无法让两个组件互相交流，使用对方数据。</p>
<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><ul>
<li>需要回调通知state（等同于回调参数）-&gt;action</li>
<li>需要根据回调处理（等同于父级方法） -&gt;reducer</li>
<li>需要state(等同于总状态) -&gt;store</li>
</ul>
<p>现在您只需要记住 <code>reducer</code> 是一个函数，负责更新并返回一个新的<code>state</code></p>
<p>而 <code>initialState</code> 主要用于前后端同构的数据同步</p>
<a id="more"></a>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><ul>
<li>是把数据从应用传到store的有效载荷。</li>
<li>是store数据的唯一来源</li>
<li>描述发生了什么的普通对象</li>
<li>也可以理解成新闻的摘要-“任务列表里添加了学习Redux文档”。</li>
</ul>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><ul>
<li>Redux应用中只有一个单一的store</li>
<li>维持应用的state</li>
<li>提供 getState() 获取state</li>
<li>提供dispatch() 更新state</li>
<li>通过subscribe(listener) 注册监听器</li>
<li>通过subscribe(listener) 返回的函数注销监听器.</li>
<li>会把2个参数传入reducer：当前的state树和action。</li>
</ul>
<h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><h2 id="Reducer-1"><a href="#Reducer-1" class="headerlink" title="Reducer"></a>Reducer</h2><p>reducer就是实现(state,action) -&gt; newState的纯函数. 也就是真正处理state的地方.</p>
<p>Redux不希望我们修改老的state ,而且通过直接返回新的state的方式去修改.</p>
<ul>
<li><strong>永远不要</strong>在 reducer 里做这些操作：<ul>
<li>修改传入参数；</li>
<li>执行有副作用的操作，如 API 请求和路由跳转；</li>
<li>调用非纯函数，如 <code>Date.now()</code> 或 <code>Math.random()</code>。</li>
</ul>
</li>
<li>指明根据action更新state。</li>
</ul>
<p>通俗点讲，就是 <code>reducer</code> 返回啥，<code>state</code> 就被替换成啥</p>
<ul>
<li>view(React)</li>
<li>store(state)</li>
<li>action</li>
<li>reducer</li>
</ul>
<ul>
<li>view(React) = 家具的摆放在视觉的效果上</li>
<li>store(state) = 每个家具在空间内的坐标(如：电视的位置是x:10, y: 400)</li>
<li>action = 小明分配任务(谁应该干什么)</li>
<li>reducer = 具体任务都干些什么(把电视搬到沙发正对面然后靠墙的地方)</li>
</ul>
<p>所以这个过程应该是这样的：</p>
<p><strong>view —&gt; action —&gt; reducer —&gt; store(state) —&gt; view</strong></p>
<h1 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h1><ol>
<li><p>Provider是一个普通组件，可以作为顶层app的分发点，它只需要store属性就可以。他会将state分发给所有被connect的组件，不管它在哪里，被嵌套多少层。</p>
</li>
<li><p>connect是真正的重点，它是一个科里化函数，意思是先接受两个参数（数据绑定mapStateToProps和事件绑定mapDispatchToProps），再接受一个参数（将要绑定的组件本身）：mapStateToProps：构建好Redux系统的时候，它会被自动初始化，但是你的React组件并不知道它的存在，因此你需要分拣出你需要的Redux状态，所以你需要绑定一个函数，它的参数是state，简单返回你关心的几个值。</p>
</li>
<li><p>mapDispatchToProps：声明好的action作为回调，也可以被注入到组件里，就是通过这个函数，它的参数是dispatch，通过redux的辅助方法bindActionCreator绑定所有action以及参数的dispatch，就可以作为属性在组件里面作为函数简单使用了，不需要手动dispatch。这个mapDispatchToProps是可选的，如果不传这个参数redux会简单把dispatch作为属性注入给组件，可以手动当做store.dispatch使用。这也是为什么要科里化的原因。</p>
<p>做好以上流程Redux和React就可以工作了。简单地说就是：</p>
<p>​</p>
<p>1.顶层分发状态，让React组件被动地渲染。</p>
<p>​</p>
<p>2.监听事件，事件有权利回到所有状态顶层影响状态。</p>
</li>
</ol>
<h1 id="Redux-与传统后端-MVC-的对照"><a href="#Redux-与传统后端-MVC-的对照" class="headerlink" title="Redux 与传统后端 MVC 的对照"></a>Redux 与传统后端 MVC 的对照</h1><table>
<thead>
<tr>
<th>Redux</th>
<th>传统后端 MVC</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>store</code></td>
<td>数据库实例</td>
</tr>
<tr>
<td><code>state</code></td>
<td>数据库中存储的数据</td>
</tr>
<tr>
<td><code>dispatch(action)</code></td>
<td>用户发起请求</td>
</tr>
<tr>
<td><code>action: { type, payload }</code></td>
<td><code>type</code> 表示请求的 URL，<code>payload</code> 表示请求的数据</td>
</tr>
<tr>
<td><code>reducer</code></td>
<td>路由 + 控制器（handler）</td>
</tr>
<tr>
<td><code>reducer</code> 中的 <code>switch-case</code> 分支</td>
<td>路由，根据 <code>action.type</code> 路由到对应的控制器</td>
</tr>
<tr>
<td><code>reducer</code> 内部对 <code>state</code> 的处理</td>
<td>控制器对数据库进行增删改操作</td>
</tr>
<tr>
<td><code>reducer</code> 返回 <code>nextState</code></td>
<td>将修改后的记录写回数据库</td>
</tr>
</tbody>
</table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="redux-三个基本原则"><a href="#redux-三个基本原则" class="headerlink" title="redux 三个基本原则"></a>redux 三个基本原则</h2><ol>
<li>整个应用只有唯一一个 Store 实例</li>
<li>State 只能通过触发 Action 来更改</li>
<li>State 的更改 必须写成纯函数(Reducer)，(oldState, action) =&gt; newState，也就是每次更改总是返回一个新的 State</li>
</ol>
<h2 id="redux-两个显著的特点"><a href="#redux-两个显著的特点" class="headerlink" title="redux 两个显著的特点"></a>redux 两个显著的特点</h2><ol>
<li>可预测性（Reducer 是纯函数）。</li>
<li>扩展性强（middleware）。</li>
</ol>
<h2 id="reducer-可以根据场景分为以下几种"><a href="#reducer-可以根据场景分为以下几种" class="headerlink" title="reducer 可以根据场景分为以下几种:"></a>reducer 可以根据场景分为以下几种:</h2><ul>
<li>root reducer :根reducer ,作为createStore的第一个参数</li>
<li>slice reducer : 分片reducer,相对根reducer 来说的.用来操作state的一部分数据.多个分片reducer可以合并成一个根reducer.</li>
<li>higher-order reducer : 高阶reducer 接受reducer作为函数/返回reducer作为返回的函数.</li>
<li>case function: 功能函数,接受指定action后的更新逻辑,可以是简单的reducer函数,也可以接受其他参数.</li>
</ul>
<h2 id="reducer-的最佳实践主要分为以下几个部分"><a href="#reducer-的最佳实践主要分为以下几个部分" class="headerlink" title="reducer 的最佳实践主要分为以下几个部分"></a>reducer 的最佳实践主要分为以下几个部分</h2><ul>
<li>抽离工具函数,以便复用.</li>
<li>抽离功能函数(case function),精简reducer声明部分的代码</li>
<li>根据数据类别拆分,维护多个独立的slice reducer.</li>
<li>合并slice reducer.</li>
<li>通过crossReducer在多个slice reducer中共享数据.</li>
<li>减少reducer的模板代码.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;react无法让两个组件互相交流，使用对方数据。&lt;/p&gt;
&lt;h1 id=&quot;Redux&quot;&gt;&lt;a href=&quot;#Redux&quot; class=&quot;headerlink&quot; title=&quot;Redux&quot;&gt;&lt;/a&gt;Redux&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;需要回调通知state（等同于回调参数）-&amp;gt;action&lt;/li&gt;
&lt;li&gt;需要根据回调处理（等同于父级方法） -&amp;gt;reducer&lt;/li&gt;
&lt;li&gt;需要state(等同于总状态) -&amp;gt;store&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在您只需要记住 &lt;code&gt;reducer&lt;/code&gt; 是一个函数，负责更新并返回一个新的&lt;code&gt;state&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;initialState&lt;/code&gt; 主要用于前后端同构的数据同步&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="http://xuzihao.fun/categories/React/"/>
    
    
      <category term="JavaScript" scheme="http://xuzihao.fun/tags/JavaScript/"/>
    
      <category term="React" scheme="http://xuzihao.fun/tags/React/"/>
    
  </entry>
  
</feed>
